[
  {
    "name": "exists",
    "text": "def exists(x):\n    t = type(x)\n    if t == str:\n        return x.strip() != \"\"\n    if t == list:\n        return len(x) > 0\n    if t == dict:\n        return len(x.keys()) > 0\n    return x != None\n"
  },
  {
    "name": "test",
    "text": "def test(r, s, flags=0):\n    if not isString(s):\n        return\n    return bool(re.search(r, s, flags))\n"
  },
  {
    "name": "isPublicFile",
    "text": "def isPublicFile(x):\n    if isIgnoredFile(x):\n        return 0\n    return test(\"^[a-zA-Z]|^\\d+$\", tail(x))\n"
  },
  {
    "name": "isPrimitive",
    "text": "def isPrimitive(s):\n    return isString(s) or isNumber(s)\n"
  },
  {
    "name": "isFunction",
    "text": "def isFunction(x):\n    return callable(x)\n"
  },
  {
    "name": "isString",
    "text": "def isString(x):\n    return type(x) == str\n"
  },
  {
    "name": "isNumber",
    "text": "def isNumber(x):\n    if isString(x):\n        return test(\"^\\d[.,\\d]*$\", x)\n    return type(x) == int or type(x) == float\n"
  },
  {
    "name": "isArray",
    "text": "def isArray(x):\n    t = type(x).__name__\n    c = ['list', 'tuple', 'dict_keys']\n    return t in c\n"
  },
  {
    "name": "isObject",
    "text": "def isObject(x):\n    return type(x) == dict\n"
  },
  {
    "name": "head",
    "text": "def head(f):\n    return (\n        re.sub(\"/$\", \"\", str(f)).rsplit(\"/\", maxsplit=1)[0]\n        + \"/\"\n    )\n"
  },
  {
    "name": "tail",
    "text": "def tail(x):\n    return re.sub(\"/$\", \"\", str(x)).rsplit(\"/\", maxsplit=1)[\n        -1\n    ]\n"
  },
  {
    "name": "identity",
    "text": "def identity(s):\n    return s\n"
  },
  {
    "name": "getExtension",
    "text": "def getExtension(s):\n    if \"json.js\" in s:\n        return \"json.js\"\n    return search(\"\\.([a-zA-Z]+\\d*)$\", s).lower()\n"
  },
  {
    "name": "unique",
    "text": "def unique(a, b=None):\n    if b:\n        if isArray(a):\n            return difference(a, b)\n        if isObject(a):\n            return filter(a, lambda k, v: k not in b)\n    else:\n        return list(set(a))\n"
  },
  {
    "name": "difference",
    "text": "def difference(a, b):\n    return list(set(a).difference(b))\n"
  },
  {
    "name": "intersection",
    "text": "def intersection(a, b):\n    return list(set(a).intersection(b))\n"
  },
  {
    "name": "toArray",
    "text": "def toArray(x):\n    if isArray(x):\n        return x\n    if isString(x):\n        return split(x, \"\\n\")\n    return [x]\n"
  },
  {
    "name": "every",
    "text": "def every(x, y):\n    if isArray(y):\n        a = list(x).sort()\n        b = list(y).sort()\n        return json.dumps(a) == json.dumps(b)\n\n    for item in list(x):\n        if not y(item):\n            return False\n    return True\n\n"
  },
  {
    "name": "datestamp",
    "text": "def datestamp(x=None, strife=\"%m-%d-%Y\"):\n    if hasattr(x, 'created_utc'):\n        x = x.created_utc\n        strife = 'praw'\n    elif isObject(x)  and x.get('created_utc'):\n        x = x['created_utc']\n        strife = 'praw'\n\n    ref = {\n        \"/\": \"%m/%d/%Y\",\n        \"-\": \"%m-%d-%Y\",\n        \"human\": \"%A %B %d, %-I:%M:%S%p\",\n        \"praw\": \"%m-%d-%Y %-I:%M:%S%p\",\n        'long': \"%A %B %d %Y, %H:%M:%S%p\",\n        'long': \"%m-%d-%Y, %H:%M:%S%p\",\n    }\n    strife = ref.get(strife, strife)\n    if isString(x):\n        if isfile(x):\n            x = mdate(x)\n            return datetime.fromtimestamp(x).strftime(\n                strife\n            )\n        return datetime.strptime(x, strife)\n    if type(x) == float or type(x) == int:\n        return datetime.fromtimestamp(x).strftime(strife)\n    if type(x) == datetime:\n        return x.strftime(strife)\n\n    return datetime.now().strftime(strife)\n"
  },
  {
    "name": "getLast",
    "text": "def getLast(s):\n    return s[-1]\n"
  },
  {
    "name": "search",
    "text": "def search(regex, item, flags=0):\n    match = re.search(regex, item, flags)\n    if not match:\n        return \"\"\n    if match.groups():\n        if len(match.groups()) == 1:\n            return match.groups()[0]\n        return match.groups()\n    return match.group(0)\n"
  },
  {
    "name": "toNumber",
    "text": "def toNumber(x):\n    return int(x) if isNumber(x) else x\n"
  },
  {
    "name": "isUrl",
    "text": "def isUrl(s):\n    return test(\"^http|www|\\.(?:com|net|io|org)\\\\b\", s)\n"
  },
  {
    "name": "clear",
    "text": "def clear(x):\n    if isfile(x):\n        with open(x, \"w\") as f:\n            pass\n\n    elif isdir(x):\n        rmdir(x, None, True)\n"
  },
  {
    "name": "absdir",
    "text": "def absdir(dir=\".\"):\n    if isArray(dir):\n        return dir\n    dir = abspath(dir)\n    return [os.path.join(dir, f) for f in os.listdir(dir)]\n"
  },
  {
    "name": "getCaller",
    "text": "def getCaller(n=0):\n    from inspect import stack\n\n    stack = stack()\n    if n == -1:\n        return stack[2][3]\n    else:\n        return stack[len(stack) - 2][3]\n"
  },
  {
    "name": "filter",
    "text": "def filter(items, f=exists, *args, **kwargs):\n    if not f:\n        return items\n    if isString(f):\n        ref = {\n            'camel_case': '[a-z][A-Z]'\n        }\n        r = f\n        if r in ref:\n            r = ref[r]\n        f = lambda s: test(r, s)\n    if isObject(items):\n        return {k: v for k, v in items.items() if f(k, v)}\n    else:\n        if isArray(f):\n            ignore = f\n            f = lambda x: x not in ignore\n\n        if args and isFunction(args[0]):\n            return [\n                x for x in list(items) if f(x, **kwargs) and every(args, lambda check: check(x))\n            ]\n\n        return [\n            x for x in list(items) if f(x, *args, **kwargs)\n        ]\n"
  },
  {
    "name": "isfile",
    "text": "def isfile(f):\n    return os.path.isfile(abspath(f))\n"
  },
  {
    "name": "isdir",
    "text": "def isdir(f):\n    return isString(f) and os.path.isdir(f)\n    return os.path.isdir(os.path.expanduser(f))\n"
  },
  {
    "name": "toSeconds",
    "text": "def toSeconds(\n    minutes=0, hours=0, seconds=0, days=0, weeks=0, months=0"
  },
  {
    "name": "isRecent",
    "text": "def isRecent(file, before=0, after=0, **kwargs):\n    if isNumber(file):\n        n = int(file)\n    elif os.path.exists(file):\n        n = mdate(file)\n    else:\n        return False\n\n    if before:\n        return n < dategetter(before)\n    if after:\n        return n > dategetter(after)\n\n    seconds = toSeconds(**kwargs)\n    currentTime = timestamp()\n    lastAcceptableTime = currentTime - seconds\n    if n > lastAcceptableTime:\n        return True\n"
  },
  {
    "name": "timestamp",
    "text": "def timestamp(x=int):\n    if type(x) == datetime:\n        return int(x.timestamp())\n    if x == int:\n        return int(datetime.now().timestamp())\n"
  },
  {
    "name": "mdate",
    "text": "def mdate(f):\n    return int(os.path.getmtime(f))\n"
  },
  {
    "name": "npath",
    "text": "def npath(dir=0, file=0):\n    if not dir:\n        return file\n    elif not file:\n        return os.path.join(os.getcwd(), dir)\n    if isfile(dir):\n        if not getExtension(file):\n            file = addExtension(file, getExtension(dir))\n        dir = head(dir)\n    return os.path.join(dir, tail(file))\n"
  },
  {
    "name": "normpath",
    "text": "def normpath(dir, file):\n    dir = abspath(dir) if isdir(dir) else head(dir)\n    return os.path.join(dir, tail(file))\n"
  },
  {
    "name": "abspath",
    "text": "def abspath(file=None):\n    if file == None:\n        return os.path.expanduser(\"~/\")\n    elif file == \".\":\n        return os.getcwd()\n    elif file.startswith(\"~\"):\n        return os.path.expanduser(file)\n    elif file.startswith(\"./\"):\n        return os.path.join(os.getcwd(), file[2:])\n    else:\n        return os.path.abspath(file)\n"
  },
  {
    "name": "ofile",
    "text": "def ofile(f):\n    if hasattr(f, 'permalink'):\n        return openBrowser('https://redd.it/' + f.id)\n    return map(f, openBrowser)\n"
  },
  {
    "name": "cfiles",
    "text": "def cfiles(files, dir, ask=0):\n    if ask:\n        prompt(files, tempbudir, 'are you sure you want to copy these files and overwrite existing files in the directory?')\n\n    mkdir(dir)\n    for f in files:\n        if isRemovableFile(f):\n            rfile(f)\n        else:\n            cfile(f, dir)\n    if ask:\n        printdir(dir)\n"
  },
  {
    "name": "cfile",
    "text": "def cfile(f, t):\n    mfile(f, t, mode=\"copy\")\n"
  },
  {
    "name": "mfile",
    "text": "def mfile(f, t, mode=\"move\"):\n    assert isfile(f)\n    if t in env.dirdict:\n        t = env.dirdict[t]\n\n    if not getExtension(t) and not isdir(t):\n        a = prompt('no extension for', t, 'did you forget it?')\n        if a:\n            t = addExtension(t, getExtension(f))\n        else:\n            prompt('are you sure you want to make a directory?', t)\n            mkdir(t)\n    elif not getExtension(t):\n        t = normpath(t, f)\n\n    if tail(f) == tail(t):\n        print(mode, \"file\", tail(f), \"to\", head(t))\n    else:\n        print(f\"{mode} file: {f} to {t}\")\n\n    if mode == \"move\":\n        try:\n            shutil.move(f, t)\n            return 1\n        except Exception as e:\n            return 0\n            pass\n\n    elif mode == \"copy\":\n        try:\n            shutil.copy(f, t)\n            return 1\n        except Exception as e:\n            return 0\n            pass\n"
  },
  {
    "name": "rfile",
    "text": "def rfile(f):\n    if '.gitignore' in f:\n        return\n    mfile(f, \"/home/kdog3682/TRASH\")\n"
  },
  {
    "name": "cfile",
    "text": "def cfile(f, t):\n    if not getExtension(t):\n        t = normpath(t, f)\n    shutil.copy(f, t)\n    print(f\"copying file: {f} to {t}\")\n"
  },
  {
    "name": "cdir",
    "text": "def cdir(dir, t):\n    newDir = npath(t, dir)\n    if isdir(newDir):\n        if prompt(\"it is already a dir\", newDir):\n            return\n    prompt(newDir)\n    shutil.copytree(dir, newDir)\n    print(f\"copying directory: {newDir}\")\n"
  },
  {
    "name": "isMacbook",
    "text": "def isMacbook():\n    return not os.path.exists(\"/mnt\")\n"
  },
  {
    "name": "isCurrentDir",
    "text": "def isCurrentDir(d):\n    return abspath(os.getcwd()) == abspath(d)\n"
  },
  {
    "name": "chdir",
    "text": "def chdir(d, force=0):\n    d = dirgetter(d)\n    if not getExtension(d) and not isdir(d):\n        if not force:\n            prompt(\"mkdir?\", d)\n        mkdir(d)\n    if isdir(d) and not isCurrentDir(d):\n        print(f\"changing to directory: {d}\")\n        os.chdir(d)\n"
  },
  {
    "name": "prompt",
    "text": "def prompt(*args, **kwargs):\n    mode = kwargs.pop('mode', None)\n    if mode == 'clip':\n        clip(args[0])\n        return input('awaiting input:\\n')\n\n    for arg in args:\n        if arg:\n            if isString(arg):\n                print(arg)\n            else:\n                pprint(arg)\n    if kwargs:\n        pprint(kwargs)\n    return input() or kwargs.get('fallback', '')\n"
  },
  {
    "name": "isIgnoredFile",
    "text": "def isIgnoredFile(name):\n    name = tail(name)\n    ignore = [\n        \"vosk-api\",\n        \"__pycache__\",\n        \"node_modules\",\n        \".git\",\n    ]\n    ignoreRE = \"^(?:\\W)\"\n    recursiveIgnoreRE = \"^(?:LICENSE|README\\.[mM][dD])$\"\n    return name in ignore or test(ignoreRE, name)\n"
  },
  {
    "name": "fileInfo",
    "text": "def fileInfo(f, r=0):\n    if isfile(f):\n        strife = \"%A %B %d %Y, %-I:%M:%S%p\"\n        name = tail(f)\n        date = datestamp(f, strife)\n        size = fsize(f)\n        return {\n            \"name\": tail(f),\n            \"size\": fsize(f),\n            \"date\": date,\n        }\n    else:\n        print([\"not a file\", f])\n"
  },
  {
    "name": "dirgetter",
    "text": "def dirgetter(dir=None):\n    if not dir:\n        return os.getcwd()\n    value = dirdict.get(dir, dir)\n    assert isdir(value)\n    return value\n    return dirdict.get(dir, os.path.expanduser(dir))\n\n    key = \"macbook\" if isMacbook() else \"chromebook\"\n    dicts = {\"macbook\": macdirdict, \"chromebook\": dirdict}\n    dict = dicts[key]\n\n    dir = dict.get(dir, dir)\n    assert isdir(dir)\n    return dir\n"
  },
  {
    "name": "number",
    "text": "def number(items):\n    for i, item in enumerate(items):\n        print(i + 1, item)\n"
  },
  {
    "name": "askToRemove",
    "text": "def askToRemove(file):\n    pprint(read(file))\n    print(file)\n    a = input()\n    if a:\n        rfile(file)\n"
  },
  {
    "name": "fixBrowserPath",
    "text": "def fixBrowserPath(f):\n    if not f:\n        return \n    if isfile(f):\n        return f\n        prompt(f)\n    aliases = {\n        'red': 'reddit',\n    }\n    if f in aliases:\n        return fixUrl(aliases[f])\n    ref = {\n        'json': [dldir, jsondir],\n        'pdf': [dldir, pdfdir],\n    }\n    e = getExtension(f)\n\n    if e:\n        for dir in ref.get(e, []):\n            temp = npath(dir, f)\n            if isfile(temp):\n                return temp\n            raise Exception('cant find the file')\n\n\n    if isUrl(f):\n        return f\n\n    return f\"https://google.com/search?q={f}\"\n    \n"
  },
  {
    "name": "openBrowser",
    "text": "def openBrowser(f):\n    if not f:\n        return \n    f = fixBrowserPath(f)\n    webbrowser.open(f)\n"
  },
  {
    "name": "choose",
    "text": "def choose(x, mode=0, filter=0, auto=1):\n    if isString(x) and isdir(x):\n        x = absdir(x)\n    else:\n        x = list(x)\n    if not isPrimitive(x[0]):\n        mode = 1\n    if auto and len(x) == 1:\n        return x[0]\n\n    if isString(x[0]) and isfile(x[0]):\n        x = map(x, tail)\n    a = prompt2(x)\n    if not a:\n        return\n    if filter:\n        while isWord(a):\n            newList = [\n                el\n                for el in x\n                if test(a, filter(el), flags=re.I)\n            ]\n            if newList:\n                x = newList\n\n            a = prompt2(x)\n\n    if a == \"x\":\n        return []\n\n    value = None\n    if not a:\n        return x\n    else:\n        value = [\n            x[int(n) - 1] for n in a.strip().split(\" \")\n        ]\n\n    if value:\n        if mode == 1:\n            return value[0]\n        if mode == 0:\n            return unique(value)\n"
  },
  {
    "name": "find",
    "text": "def find(arr, fn, mode=None, flags=0):\n    fn = testf(fn)\n\n    if isObject(arr):\n        for k, v in arr.items():\n            if fn in v:\n                return os.path.join(k, fn)\n        return\n\n    for i, item in enumerate(list(arr)):\n        if ftest(fn, item, flags=flags):\n            return i if mode == int else item\n"
  },
  {
    "name": "createKwargs",
    "text": "def createKwargs(s):\n    if not s:\n        return {}\n\n    dict = {\n        \"backup\": \"dir=pub after=8pm js=1 copy=bu\",\n        \"i\": \"ignore\",\n        \"budir\": \"dir=bu\",\n        \"old\": \"old=1\",\n        \"budir\": \"dir=bu\",\n        \"pdfjson\": \"json=1\",\n        \"root\": \"dir=root\",\n        \"pdf\": \"pdf=1\",\n        \"5pm\": \"after=5pm\",\n        \"6pm\": \"after=6pm\",\n        \"7pm\": \"after=7pm\",\n        \"8pm\": \"after=8pm\",\n        \"9pm\": \"after=9pm\",\n        \"10pm\": \"after=10pm\",\n        \"11pm\": \"after=11pm\",\n        \"midnight\": \"after=12am\",\n        \"noon\": \"after=12pm\",\n        \"1pm\": \"after=1pm\",\n        \"2pm\": \"after=2pm\",\n        \"3pm\": \"after=3pm\",\n        \"4pm\": \"after=4pm\",\n        \"pub\": \"dir=pub\",\n        \"cwf\": \"dir=cwf\",\n        \"dl\": \"dir=dl\",\n        \"c\": \"copy\",\n        \"cp\": \"copy\",\n        \"debug\": \"mode=debug\",\n        \"open\": \"mode=open\",\n        \"o\": \"mode=open\",\n        \"d\": \"mode=debug\",\n        \"n\": \"name\",\n        \"r\": \"mode=review\",\n        \"today\": \"date=today\",\n        \"t\": \"text\",\n        \"ye\": \"date=yesterday\",\n        \"sm\": \"small=2000\",\n        \"this\": \"date=today\",\n        \"tf\": \"testfunction\",\n        \"mv\": \"move\",\n        \"of\": \"onlyFiles=1\",\n        \"h\": \"html\",\n        \"i\": \"mode=info\",\n        \"s\": \"mode=save\",\n        \"big\": \"big=100000\",\n    }\n    s, quote = mreplace('\"(.*?)\"', s)\n    s = dreplace(s, dict, template=\"(?<![\\w=])(?:$1)\\\\b\")\n    regex = \"(\\S+?) *= *(\\S+?)(?= |$)\"\n    s, items = mreplace(regex, s)\n    f = lambda x: int(x) if isNumber(x) else x\n\n    items1 = {k: f(v) for k, v in items}\n    items2 = {a: 1 for a in split(s, \" \")}\n    items1.update(items2)\n    if quote:\n        items1[\"text\"] = quote[0]\n    return items1\n"
  },
  {
    "name": "configurable",
    "text": "def configurable(fn):\n    def wrapper(s=\"\", **bargs):\n        if s:\n            s += \" of\"\n        kwargs = createKwargs(s)\n        kwargs.update(bargs)\n        return fn(**kwargs)\n\n    return wrapper\n"
  },
  {
    "name": "sort",
    "text": "def sort(x, f=int, reverse=0):\n    if isObject(x):\n        return {\n            k: v\n            for k, v in sorted(\n                x.items(),\n                key=lambda item: f(item[1]),\n                reverse=reverse,\n            )\n        }\n    else:\n        if isString(f):\n            prev = f\n            f = lambda x: x.get(prev)\n        return sorted(list(x), key=f, reverse=reverse)\n"
  },
  {
    "name": "append",
    "text": "def append(f, s):\n    if f.endswith('.json'):\n        return appendjson(f, s)\n    if isObject(s):\n        s = s.values()\n\n    value = toString(s)\n\n    if value:\n        with open(f, \"a\") as _:\n            _.write(\"\\n\" + value)\n            print(f\"appending file: {f}\")\n"
  },
  {
    "name": "fixUrl",
    "text": "def fixUrl(s):\n    s = re.sub(\"(?:https://)?view-source:\", \"\", s)\n    if \".\" not in s:\n        s += \".com\"\n    if not test(\"^http\", s):\n        s = \"https://\" + s\n    return s\n"
  },
  {
    "name": "getDomainName",
    "text": "def getDomainName(url):\n    return re.sub(\"(?<!/)/\\w.*$\", \"\", fixUrl(url))\n"
  },
  {
    "name": "downloadWebsite",
    "text": "def downloadWebsite(url):\n    chdir(pubdir)\n    downloader = lambda x: write(\n        tail(x), request(x), open=1\n    )\n    domainName = getDomainName(url)\n\n    s = request(url)\n\n    def runner(x):\n        m = x.group(1)\n        if m.startswith(\"/\"):\n            m = os.path.join(domainName, m[1:])\n\n        # print(m)\n        # downloader(m)\n        return quote(tail(m))\n\n    regex = \"['\\\"]\" + \"(\\S+\\.(?:js|css))\" + \"['\\\"]\"\n    s = re.sub(regex, runner, s)\n    write(\"index.html\", s, open=1)\n"
  },
  {
    "name": "toNumber",
    "text": "def toNumber(x):\n    if isNumber(x):\n        return int(x)\n    return x\n"
  },
  {
    "name": "toString",
    "text": "def toString(x):\n    return str(x) if isPrimitive(x) else join(x)\n"
  },
  {
    "name": "gatherArgs",
    "text": "def gatherArgs(args):\n    if isArray(args[0]):\n        return args[0]\n    return args\n"
  },
  {
    "name": "join",
    "text": "def join(*args, delimiter=\"\\n\"):\n    if not args:\n        return \"\"\n\n    if not args[0]:\n        return \"\"\n\n    s = \"\"\n    for item in gatherArgs(args):\n        if isArray(item):\n            item = join(item)\n        s += item\n        s += \"\\n\\n\" if \"\\n\" in item else delimiter\n\n    return backspace(s) if delimiter else s\n"
  },
  {
    "name": "moveClipToLogJson",
    "text": "def moveClipToLogJson(key):\n    value = clip()\n    logger(key=key, value=value)\n"
  },
  {
    "name": "logger",
    "text": "def logger(**kwargs):\n    if not kwargs:\n        return \n\n    from collections import OrderedDict\n    store = OrderedDict()\n    store['action'] = getCaller()\n    store['date'] = datestamp()\n    entries = sort(kwargs.items(), lambda x: len(json.dumps(x)))\n    for a,b in entries:\n        store[a] = b\n\n    appendjson(glogfile, store, mode=list)\n"
  },
  {
    "name": "backup",
    "text": "def backup(f):\n    if isArray(f):\n        assert every(f, isfile)\n        dirName = budir + prompt('Creating new Directory: Name for the back-up directory (it will be located in drive/budir)?')\n        cfiles(f, dirName)\n        logger(action='backup', dirName=dirName, files=f)\n    elif isfile(f):\n        shutil.copy(f, npath(budir, f + \".backup\"))\n    elif isdir(f):\n        return print('no dirs yet')\n\n    print(\"backed up\", f)\n"
  },
  {
    "name": "backspace",
    "text": "def backspace(s):\n    return s[:-1]\n"
  },
  {
    "name": "camelCase",
    "text": "def camelCase(s):\n    s = uncapitalize(s.strip())\n    s = re.sub(\"[- .](\\w)\", lambda x: x.group(1).upper(), s)\n    return s\n"
  },
  {
    "name": "decode",
    "text": "def decode(x):\n    return x.decode(\"utf-8\")\n"
  },
  {
    "name": "node",
    "text": "def node(*args):\n    return system(\"node\", *args)\n"
  },
  {
    "name": "quote",
    "text": "def quote(s):\n    return (\n        '\"\"\"\\n' + s.strip() + '\\n\"\"\"'\n        if \"\\n\" in s\n        else '\"' + s + '\"'\n    )\n"
  },
  {
    "name": "some",
    "text": "def some(items, x):\n    for item in items:\n        if ftest(x, item):\n            return True\n"
  },
  {
    "name": "addExtension",
    "text": "def addExtension(s, extension=\"py\", force=0):\n    if not s:\n        return \"\"\n    return (\n        s\n        if getExtension(s) and force == 0\n        else s + \".\" + extension\n    )\n"
  },
  {
    "name": "ftest",
    "text": "def ftest(f, arg, flags=0):\n    if isArray(f):\n        return every(f, lambda f: ftest(f, arg))\n    if isString(f):\n        return test(f, arg, flags=flags)\n    if isFunction(f):\n        return f(arg)\n    return True\n"
  },
  {
    "name": "handleError",
    "text": "def handleError(e):\n    print([getCaller(), \"error\", str(e)])\n"
  },
  {
    "name": "rigidSort",
    "text": "def rigidSort(items, order, f=identity):\n    order = {k: i for k in order}\n    items.sort(key=lambda x: order[f(x)])\n    return items\n"
  },
  {
    "name": "breaker",
    "text": "def breaker(n=10):\n    raise Exception(\"\")\n    # env.breaker_count += 1\n    # if env.breaker_count >= n:\n        # raise Exception()\n"
  },
  {
    "name": "_setup_chromebook",
    "text": "def _setup_chromebook():\n    os.system(\"clear\")\n    print(\"Install Pip Libraries\")\n"
  },
  {
    "name": "_cleanup_base",
    "text": "def _cleanup_base():\n    # cleanup base.py\n    # uses globals() to organize everything\n\n    from inspect import getsource\n\n    lib = globals()\n    preset = {\"pprint\": \"from pprint import pprint\"}\n\n    f = testf(\"^__\", 0, 1)\n    keys = filter(list(lib.keys()), f).sort()\n    keys.sort()\n\n    def f(key):\n        v = lib.get(key)\n        t = type(v)\n        if t == str:\n            s = f\"{key} = '{str(v)}'\"\n            name = \"primitives\"\n        elif t == int or t == float:\n            s = f\"{key} = {str(v)}\"\n            name = \"primitives\"\n        elif t == module:\n            s = str(v)\n            name = search(\"<module '([\\w-]+)'\", s)\n            if name == key:\n                s = f\"import {name}\"\n            else:\n                s = f\"import {key} as {name}\"\n            name = \"modules\"\n\n        elif key in preset:\n            name = \"modules\"\n            s = preset[key]\n        else:\n            s = getsource(v)\n\n        if name:\n            pass\n        elif test(\"^_\", s):\n            name = \"apps\"\n        elif t == type:\n            name = \"classes\"\n        elif t == function:\n            name = \"functions\"\n\n        storage.add(name, s)\n\n    storage = Storage()\n    map(keys, f)\n    items = storage.store.items()\n    order = [\n        \"modules\",\n        \"primitives\",\n        \"functions\",\n        \"classes\",\n        \"apps\",\n    ]\n    rigidSort(items, order, lambda x: x[0])\n    s = \"\"\n    for k, v in items:\n        v.sort()\n        s += join(v)\n        s += \"\\n\\n\"\n    return s\n    breaker(3)\n"
  },
  {
    "name": "testf",
    "text": "def testf(r, flags=0, reverse=0):\n    if isFunction(r):\n        return r\n    if reverse:\n        return lambda x: not test(r, x, flags)\n    else:\n        return lambda x: test(r, x, flags)\n"
  },
  {
    "name": "rmdir",
    "text": "def rmdir(dir, force=0, create=0, ask=0):\n    if not isdir(dir):\n        return \n\n    def remove(dir):\n        assert(dir != '/home/kdog3682')\n        assert(dir != '/home/kdog3682/2023')\n        assert(dir != '/home/kdog3682/RESOURCES')\n\n        if ask:\n            if not prompt('remove the directory? ' + dir):\n                return \n        shutil.rmtree(dir)\n        print(\"removing dir\", dir)\n\n    if (\n        len(os.listdir(dir)) < 10\n        and absdir(dir) not in dirdict.values()\n    ):\n        remove(dir)\n\n    elif (\n        len(os.listdir(dir)) == 0\n        or force\n        or prompt(\"rmdir for sure?\",dir)\n    ):\n        remove(dir)\n\n    if create:\n        mkdir(dir)\n"
  },
  {
    "name": "mkdir",
    "text": "def mkdir(dir):\n    if isfile(dir):\n        raise Exception('the dir is a file: ' + dir)\n\n    if isdir(dir):\n        print(\"dir alrady exists. early return\")\n        return dir\n    elif getExtension(dir):\n        raise Exception(\"dir has an extension...\")\n    else:\n        os.makedirs(dir)\n        print(f\"creating new directory: {dir}\")\n        return dir\n        return True\n"
  },
  {
    "name": "write",
    "text": "def write(f, s, open=0, **kwargs):\n    try:\n        _write(f, s, open)\n        r = '^/mnt'\n        if kwargs.get('save') or test(r, f):\n            save(f)\n    except Exception as e:\n        print(e)\n        return\n        dir = head(f)\n        mkdir(dir)\n        _write(f, s, open)\n"
  },
  {
    "name": "_write",
    "text": "def _write(f, s, _open=0):\n    if not exists(s):\n        return\n    e = getExtension(f)\n\n    if e == \"recent\":\n        with open(f, \"w\") as _f:\n            if isString(s):\n                _f.write(s)\n            else:\n                json.dump(s, _f, indent=2)\n\n    elif e == \"json\":\n        with open(f, \"w\") as _f:\n            json.dump(s, _f, indent=2)\n    else:\n        with open(f, \"w\") as _f:\n            _f.write(toString(s))\n\n    print(f\"writing file: {f}\")\n    if _open:\n        ofile(f)\n"
  },
  {
    "name": "uncapitalize",
    "text": "def uncapitalize(s):\n    return re.sub(\n        \"[a-zA-Z]\", lambda x: x.group(0).lower(), s, count=1\n    )\n"
  },
  {
    "name": "lineCount",
    "text": "def lineCount(s):\n    return len(re.findall(\"\\n\", s))\n"
  },
  {
    "name": "stringify",
    "text": "def stringify(x):\n    if type(x) == bytes:\n        return x.decode()\n    if isPrimitive(x):\n        return str(x)\n    return json.dumps(x, indent=4)\n"
  },
  {
    "name": "removeComments",
    "text": "def removeComments(s, e=None):\n    raise Exception()\n    js = \"(?://|/\\*[\\w\\W]+?\\*/)\"\n    html = \"<!--[\\w\\W]*?-->\"\n    start = \"^ *\"\n    end = \".*\\n+\"\n\n    if not e:\n        if test(html, s):\n            e = \"html\"\n\n        elif test(js, s):\n            e = \"js\"\n\n    r = start + locals().get(e, \"js\") + end\n    return re.sub(r, \"\", s, flags=re.M)\n"
  },
  {
    "name": "removeExtension",
    "text": "def removeExtension(s):\n    return re.sub(\"(?:\\.json)?\\.\\w+$\", \"\", s)\n"
  },
  {
    "name": "createVariable",
    "text": "def createVariable(name, s, lang=\"py\"):\n    if test(\"^(fun|def|class)\", s):\n        return s\n    prefix = \"const \" if lang == \"js\" else \"\"\n    if not name:\n        name = \"PLACE_HOLDER\"\n    if isString(s) and not isJsonParsable(s):\n        s = quote(s)\n    s = stringify(s)\n    return prefix + name + \" = \" + s\n"
  },
  {
    "name": "unidecode",
    "text": "def unidecode(s):\n    from unidecode import unidecode\n\n    return unidecode(s)\n"
  },
  {
    "name": "wrap",
    "text": "def wrap(a, b=\"()\"):\n    dict = {\n        \"()\": [\"(\", \")\"],\n        \"[]\": [\"[\", \"]\"],\n        \"{}\": [\"{\", \"}\"],\n    }\n    a, c = dict.get(b, [b, b])\n    return f\"{b}{a}{c}\"\n"
  },
  {
    "name": "templater",
    "text": "def templater(template, ref):\n\n    template = template.strip()\n    if isPrimitive(ref):\n        ref = [str(ref)]\n    regex = \"\\$(\\w+)\"\n\n    def parser(x):\n        if isArray(ref):\n            return ref[int(x) - 1]\n\n        if isObject(ref):\n            return ref.get(x, fallback(x))\n\n        if isFunction(ref):\n            return ref(x)\n\n    def runner(x):\n        return parser(x.group(1))\n\n    return re.sub(regex, runner, template)\n"
  },
  {
    "name": "map",
    "text": "def map(items, fn, *args, filter=1, **kwargs):\n    if not items:\n        return []\n    if isString(fn):\n        _key = fn\n        if isObject(items[0]):\n            fn = lambda x: x.get(_key)\n        else:\n            fn = lambda x: search(_key, x)\n    if isNestedArray(items):\n        return [fn(a, b) for a, b in items]\n\n    if isObject(items):\n        store = {}\n        for k, v in items.items():\n            value = fn(k, v)\n            if value:\n                store[k] = value\n            elif filter:\n                continue\n            else:\n                store[k] = v\n        return store\n\n    store = []\n    for item in toArray(items):\n        try:\n            value = fn(item, *args, **kwargs)\n            if not (filter and not value):\n                store.append(value)\n        except Exception as e:\n            prompt(item, error='ERROR AT MAP', message=e)\n            continue\n    return store\n"
  },
  {
    "name": "raw",
    "text": "def raw(f):\n    with open(f, \"rb\") as f:\n        return f.read()\n"
  },
  {
    "name": "read",
    "text": "def read(file):\n    e = getExtension(file)\n    mode = \"rb\" if (e in imge or e == 'ssssrt') else \"r\"\n    try:\n        with open(file, mode) as f:\n            return json.load(f) if e == \"json\" else f.read()\n    except Exception as e:\n        if type(e) == UnicodeDecodeError:\n            raise e\n        else:\n            return None\n"
  },
  {
    "name": "snakeCase",
    "text": "def snakeCase(s):\n    return re.sub(\n        \"([a-z])([A-Z])\",\n        lambda x: x.group(1) + \"-\" + x.group(2).lower(),\n        s,\n    )\n"
  },
  {
    "name": "pop",
    "text": "def pop(x, key):\n    if isNumber(key):\n        return x.pop(key)\n    elif isArray(x):\n        return x.pop(x.index(key))\n    else:\n        return x.pop(key, None)\n"
  },
  {
    "name": "parseJSON",
    "text": "def parseJSON(x):\n    if not isString(x):\n        return x\n\n    x = x.strip()\n    try:\n        return json.loads(x) if isJsonParsable(x) else x\n    except Exception as e:\n        prompt(text=x, error=str(e))\n    \n"
  },
  {
    "name": "isJsonParsable",
    "text": "def isJsonParsable(x):\n    return isString(x) and test(\"^[{\\[]\", x)\n"
  },
  {
    "name": "request",
    "text": "def request(url, delay=0):\n    from requests import get\n\n    if delay:\n        import time\n        time.sleep(delay)\n\n    r = get(fixUrl(url), {\"user-agent\": BROWSER_AGENT})\n    return parseJSON(r.text) if r.status_code == 200 else \"\"\n"
  },
  {
    "name": "stringcall",
    "text": "def stringcall(fn, args):\n    f = lambda x: int(x) if isNumber(x) else quote(x)\n    return fn + \"(\" + \", \".join(map(args, f)) + \")\"\n"
  },
  {
    "name": "clip",
    "text": "def clip(s=0, name=0):\n    presetClipFiles = [\"reddit\", \"booga\"]\n    if s == 2:\n        return parseJSON(read(jsdir + \"clip2.js\"))\n    if s in presetClipFiles:\n        return read(clipdir + s + \".json\")\n\n    n = None\n    if isNumber(s):\n        n = s\n        s = None\n\n    if not s:\n        data = parseJSON(normRead(clipfile))\n        if isArray(data) and n:\n            return data[0:n]\n        return data\n    if isString(s) and isdir(s):\n        s = os.listdir(s)\n    if s:\n        write(name or clipfile, stringify(s), open=1)\n"
  },
  {
    "name": "googleYouTubeVideosFromUrl",
    "text": "def googleYouTubeVideosFromUrl():\n    url = \"https://www.youtube.com/watch?v=qNgZxjJBey4&ab_channel=Mario%27sMathTutoring\"\n    url = re.sub(\n        \"watch\\?.+?channel=(.*?)\",\n        lambda x: \"c/\" + x.group(1),\n        url,\n    )\n    url = re.sub(\"%\\d+\", \"\", url)\n    data = request(url)\n    id = search('externalId.*?(\\w.*?)\"', data)\n    clip(id)\n"
  },
  {
    "name": "mergefiles",
    "text": "def mergefiles(s):\n    return join(map(s, read))\n"
  },
  {
    "name": "removeJavascriptStuff",
    "text": "def removeJavascriptStuff(s):\n    s = re.sub(\n        \"^(console|module|exports).+\", \"\", s, flags=re.M\n    )\n    s = re.sub(\n        \"^(class|if) [\\w\\W]+?\\n}\\n\", \"\", s, flags=re.M\n    )\n    return s\n"
  },
  {
    "name": "appScript",
    "text": "def appScript(f, data=None, use=\"\"):\n    namer = lambda f: normDirPath(addExtension(f, \"js\"))\n    files = map(split(use, \",? +\"), namer)\n    files.append(env.appscriptfile)\n    s = \"\"\n    if use:\n        s += removeJavascriptStuff(normRead(\"utils.js\"))\n    s += mergefiles(files)\n    s += \"\\n\\n\"\n    s += toCallable(f, data)\n    google_request(s)\n    print(\"called google\")\n"
  },
  {
    "name": "appScript",
    "text": "def appScript(f, data=None):\n    s = read(env.appscriptfile) + \"\\n\\n\"\n    s += toCallable(f, data)\n    google_request(s)\n"
  },
  {
    "name": "googlePrint",
    "text": "def googlePrint(s):\n    clip(s)\n"
  },
  {
    "name": "googleOpen",
    "text": "def googleOpen(o):\n    webbrowser.open(o)"
  },
  {
    "name": "googleValue",
    "text": "def googleValue(s):\n    pprint(s)\n"
  },
  {
    "name": "googleLogs",
    "text": "def googleLogs(s):\n    for item in toArray(s):\n        print(smallify(item))\n"
  },
  {
    "name": "googleWrite",
    "text": "def googleWrite(obj):\n    file = obj.get(\"file\")\n    value = obj.get(\"value\")\n    normWrite(file, value, open=1)\n"
  },
  {
    "name": "googleCreateVariable",
    "text": "def googleCreateVariable(obj):\n    file = obj.get(\"file\")\n    value = obj.get(\"value\")\n    name = obj.get(\"name\")\n    lang = getExtension(file)\n    if isObject(value):\n        payload = join(\n            [\n                createVariable(k, v, lang)\n                for k, v in value.items()\n            ]\n        )\n    else:\n        payload = createVariable(name, value, lang)\n\n    prompt(abspath(file), payload, 'appendVargoogle?')\n    append(file, payload)\n"
  },
  {
    "name": "googleAppScript",
    "text": "def googleAppScript(f=\"\", *args):\n    s = read(env.GOOGLE_APPSCRIPT_FILE).strip()\n    r = \"^(?:(?:// *|import).+)(?:\\n+(?:// *|import).+)*\"\n    s, imports = mget(r, s, flags=re.M, mode=str)\n    # gas\n    store = []\n    if imports:\n        imports = re.findall(\n            \"^import (\\S+)\", imports, flags=re.M\n        )\n        for i in imports:\n            if i == \"clip\":\n                print(\"adding clip import\")\n                store.append(\n                    createVariable(\"clip\", clip(), \"js\")\n                )\n            elif i == \"clip2\":\n                store.append(\n                    createVariable(\"clip2\", clip(2), \"js\")\n                )\n            elif getExtension(i) == \"js\":\n                store.append(normRead(i))\n            else:\n                file = normRead(i + \".temp.json\")\n                data = createVariable(\n                    camelCase(i), file, \"js\"\n                )\n                store.append(data)\n\n        s = join(store) + \"\\n\\n\" + s\n\n    callable = f if '\\n' in f else toCallable(f, *args)\n    s += \"\\n\\n\" + callable\n    ref = {\n        \"print\": googlePrint,\n        \"open\": googleOpen,\n        \"write\": googleWrite,\n        \"clip\": googlePrint,\n        \"clip\": googlePrint,\n        \"value\": googleValue,\n        \"vim\": googleVim,\n        \"logs\": googleLogs,\n        \"error\": lambda x: print(x),\n        \"createVariable\": googleCreateVariable,\n        \"appendVariable\": googleCreateVariable,\n    }\n\n    data = google_request(s)\n    try:\n\n\n        print({'data': data})\n        print(\"starting google appscript function series\")\n        for k, v in data.items():\n            if v and ref[k]:\n                print('::' + k + '::\\n')\n                ref[k](v)\n    \n        print(linebreak)\n        print('done with google appscript')\n    except Exception as e:\n        print(data)\n    \n"
  },
  {
    "name": "googleVim",
    "text": "def googleVim(s):\n    appendVim(\"filedict\", s)\n"
  },
  {
    "name": "googleTranslate",
    "text": "def googleTranslate(x, lang=\"chinese\"):\n    dict = {\"chinese\": \"Chinese\", \"spanish\": \"Spanish\"}\n    s = f\"{read(appscriptfile)}\\n\\nlanguageString = `\\n{textgetter(x)}\\n`.trim()\\n\\n\"\n    s += f\"translate{dict.get(lang, 'chinese')}(languageString)\"\n\n    def spanish(x):\n        return {\n            \"input\": x.get(\"input\"),\n            \"value\": x.get(\"value\"),\n            \"lang\": \"spanish\",\n        }\n\n    def chinese(x):\n        value = x.get(\"value\")\n        original = x.get(\"input\")\n        data = read(chifile)\n        data = map(list(value), lambda x: data.get(x, x))\n        data = \"\".join(data)\n        return {\n            \"input\": original,\n            \"value\": value,\n            \"pinyin\": data,\n            \"lang\": \"chinese\",\n        }\n\n    value = google_request(s, locals().get(lang))\n    return value.get(\"value\")\n    return value\n    pprint(value)\n"
  },
  {
    "name": "google_request",
    "text": "def google_request(data):\n    from requests import post\n\n    response = post(env.appscripturl, stringify(data))\n    try:\n        value = json.loads(response.text)\n    except:\n        value = response.text\n\n    #print(\"--------------------------------------\")\n    #pprint(value)\n    #print(\"--------------------------------------\")\n    return value\n"
  },
  {
    "name": "split",
    "text": "def split(s, r=\" \", flags=0):\n    if r == 'linebreak':\n        flags = re.M\n        r = '^----+'\n\n    return map(\n        filter(re.split(r, s.strip(), flags=flags)), trim\n    )\n"
  },
  {
    "name": "trim",
    "text": "def trim(s):\n    return s.strip()\n"
  },
  {
    "name": "splitonce",
    "text": "def splitonce(s, r=\" \"):\n    if isArray(s):\n        return [s[0], s[1:]]\n    return force(re.split(r, s, maxsplit=1))\n"
  },
  {
    "name": "force",
    "text": "def force(arr, n=2):\n    while len(arr) < n:\n        arr.append(\"\")\n    return arr\n"
  },
  {
    "name": "_drive",
    "text": "def _drive(files):\n    map(files, cfile, drivedir)\n"
  },
  {
    "name": "fsize",
    "text": "def fsize(f):\n    return os.path.getsize(f)\n"
  },
  {
    "name": "isRemovableFile",
    "text": "def isRemovableFile(file):\n    removeRE = \"\\\\bboo\\\\b|debug|dela|foo|\\(|^-?\\d+$\"\n    removeList = [\"log\", \"aux\", \"mhtml\", \"tex\", \"zip\"]\n    e = getExtension(file)\n    size = fsize(file)\n\n    return (\n        (e and size < 100)\n        or test(removeRE, tail(file))\n        or e in removeList\n        or e == \"js\"\n        and size < 100\n        or size == 0\n        or (e == \"json\" and size < 1000)\n    )\n"
  },
  {
    "name": "_cleandir",
    "text": "def _cleandir(dir=\".\"):\n    def f(file):\n        if isRemovableFile(file):\n            rfile(file)\n        else:\n            return 1\n\n    return filter(absdir(dir), f)\n"
  },
  {
    "name": "getArgsKwargs",
    "text": "def getArgsKwargs(s):\n    r = \"(\\w+) *= *(\\S+?)(?= |$)\"\n    s, kwargs = mreplace(r, s)\n    args = split(s, \" \")\n    return args, {k: v for k, v in kwargs}\n"
  },
  {
    "name": "dategetter",
    "text": "def dategetter(s, mode=int):\n    today = datetime.today()\n    year = today.year\n    day = 1\n    value = 0\n\n    if s == True:\n        value = today.replace(minute=today.minute - 10)\n    elif test(\"^\\d\", s):\n        a, b, c = search('(\\d+):?(\\d*) *([ap]m)?', s, flags=re.I)\n        print(a, b, c)\n        offset = 0 if test(\"am\", s, flags=re.I) else 12\n        hour = int(a) + offset\n        minute = int(b)\n        #date = datetime()\n        day = (\n            today.day - 1\n            if today.hour < hour\n            else today.day\n        )\n        value = today.replace(\n            day=day, hour=hour, minute=minute, second=0\n        )\n        #strife = \"%A %B %d, %-I:%M:%S%p\"\n        #print(datestamp(value, strife))\n        #return\n    elif s == \"yesterday\":\n        value = today.replace(day=today.day - 1)\n    elif s == \"today\":\n        value = today\n    elif s == \"month\":\n        value = today.replace(day=1)\n\n    return int(value.timestamp()) if mode == int else value\n"
  },
  {
    "name": "isSameDate",
    "text": "def isSameDate(date, f):\n\n    fdate = datetime.fromtimestamp(mdate(f))\n    date = dategetter(date, None)\n    return date.day == fdate.day\n"
  },
  {
    "name": "trycatch",
    "text": "def trycatch(fn):\n    def runner(*args, **kwargs):\n        try:\n            return fn(*args, **kwargs)\n        except Exception as e:\n            print(\"hiiiiiiiiiii\", str(e), *args)\n            raise Exception()\n            return\n\n    return runner\n"
  },
  {
    "name": "mreplace",
    "text": "def mreplace(r, s, **kwargs):\n    store = []\n\n    def runner(x):\n        if x.groups():\n            store.append(\n                x.group(1)\n                if len(x.groups()) == 1\n                else x.groups()\n            )\n        else:\n            store.append(x.group(0))\n\n        return \"\"\n\n    text = re.sub(r, runner, s, **kwargs).strip()\n    return text.strip(), store\n"
  },
  {
    "name": "flat",
    "text": "def flat(items, depth=None):\n    def runner(items, limit=0):\n        for item in items:\n            if isArray(item) and (\n                not depth or limit < depth\n            ):\n                runner(item, limit + 1)\n            else:\n                store.append(item)\n\n    store = []\n    runner(items)\n    return store\n"
  },
  {
    "name": "changeExtension",
    "text": "def changeExtension(s, e, unique=False):\n    # if isArray(s):\n    # return map(s, lambda x: changeExtension(x, e, unique))\n\n    def incrementName(s):\n        count = 1\n        while isfile(s):\n            count += 1\n            s = re.sub(\"(?=\\.)\", str(count), s)\n        return s\n\n    name = re.sub(\"(?:\\.\\w+)?$\", \".\" + e, s, count=1)\n    if unique:\n        name = incrementName(name)\n    return name\n"
  },
  {
    "name": "capitalize",
    "text": "def capitalize(s):\n    return s[0].upper() + s[1:]\n"
  },
  {
    "name": "getfiles",
    "text": "def getfiles(dir, recursive=0, mode=dict, sort=0, **kwargs):\n\n    if recursive and not mode == list:\n        mode = dict\n\n    checkpoint = checkpointf(**kwargs)\n\n    def runner(dir):\n        store = []\n        files = absdir(dir)\n        for file in files:\n            name = tail(file)\n\n            if isIgnoredFile(name):\n                continue\n\n            elif isfile(file):\n                if checkpoint(file):\n                    if mode == dict:\n                        store.append(name)\n                    else:\n                        output.append(file)\n            elif isdir(file) and recursive:\n                runner(file)\n\n        if mode == dict:\n            if sort:\n                store = map(\n                    store, lambda x: os.path.join(dir, x)\n                )\n                if sort == datestamp:\n                    store = {\n                        tail(f): datestamp(f)\n                        for f in sorted(store, key=mdate)\n                    }\n                else:\n                    store.sort()\n            output[dir] = store\n\n    output = {} if mode == dict else []\n    runner(dirgetter(dir))\n    return output\n"
  },
  {
    "name": "reWrap",
    "text": "def reWrap(dict, template = ''):\n    ref = {\n        '': '(?:$1)',\n        'b': \"\\\\b(?:$1)\\\\b\",\n    }\n    template = ref.get(template, template)\n    keys = list(dict.keys() if isObject(dict) else dict)\n    symbols = map(keys, re.escape)\n    s = \"|\".join(symbols)\n    return re.sub('\\$1', s, template)\n"
  },
  {
    "name": "ncg",
    "text": "def ncg(template, ref):\n    if not template:\n        template = \"(?:$1)\"\n    if NCG_TEMPLATE_LIBRARY.get(template):\n        template = NCG_TEMPLATE_LIBRARY.get(template)\n    s = \"|\".join(list(ref.keys()))\n    r = template.replace(\"$1\", s)\n    return r\n"
  },
  {
    "name": "dreplace",
    "text": "def dreplace(s, dict, flags=0, template=''):\n\n    regex = reWrap(dict, template)\n    def parser(x):\n        value = (\n            dict.get(x.group(1))\n            if x.groups()\n            else dict.get(x.group(0))\n        )\n        if None == value:\n            prompt(dreplace_error=x)\n        return value\n\n    return re.sub(regex, parser, s, flags=flags)\n"
  },
  {
    "name": "execute",
    "text": "def execute(s):\n    if isfile(s):\n        e = getExtension(s)\n        if e == \"py\" and not tail(s) == \"base.py\":\n            print(f\"executing file: file{s}\")\n            s = read(s)\n        else:\n            return\n\n    try:\n        if test(\"\\n|^\\w+ \\w+\", s.strip()):\n            return exec(s)\n        else:\n            return eval(s)\n    except Exception as e:\n        handleError(e)\n"
  },
  {
    "name": "toKwargs",
    "text": "def toKwargs():\n    ref = {\n        \"ds\": \"doubleSided\",\n        \"c\": \"copies\",\n        \"ls\": \"landscape\",\n    }\n    f = lambda x: ref.get(x)\n    # s = \"ds c ls\"\n    s = input(\"input  \")\n    args = {k: 1 for k in map(split(s), f)}\n    return args\n"
  },
  {
    "name": "runMacbook",
    "text": "def runMacbook():\n    kwargs = toKwargs()\n    printer(**kwargs)\n"
  },
  {
    "name": "_sweep",
    "text": "def _sweep(items):\n    partitioner = Partitioner(items)\n\n    store = partitioner.storage.store\n    tempest(store, \"sweep.json\")\n    log(\"partitioner-inputs\", partitioner.inputs)\n"
  },
  {
    "name": "partitionByFunction",
    "text": "def partitionByFunction(arr, f):\n    store = [[], []]\n    for item in arr:\n        if f(item):\n            store[0].append(item)\n        else:\n            store[1].append(item)\n    return store\n"
  },
  {
    "name": "partition",
    "text": "def partition(arr, n=2):\n    if isString(n):\n        n = testf(n)\n    if isFunction(n):\n        return partitionByFunction(arr, n)\n\n    store = []\n    for i in range(0, len(arr), n):\n        store.append(arr[i : i + n])\n    return store\n"
  },
  {
    "name": "includef",
    "text": "def includef(items):\n    return lambda x: x not in items\n"
  },
  {
    "name": "_cleanup",
    "text": "def _cleanup():\n    ref = read(\"sweep.json\")\n    chdir(drivedir)\n    files = os.listdir(drivedir)\n    ref = edit(ref, lambda k, v: filter(v, includef(files)))\n    pprint(ref)\n    return\n\n    for k, v in ref.items():\n        if k == \"trash\" or k == \"pdf\":\n            map(v, rfile)\n        elif k == \"gsheet\":\n            continue\n        else:\n            dir = drivedir + k.upper()\n            mkdir(dir)\n            map(v, mfile, dir)\n"
  },
  {
    "name": "edit",
    "text": "def edit(o, fn):\n    if isObject(o):\n        store = {}\n        for k, v in o.items():\n            value = fn(k, v)\n            if value == None:\n                value = v\n            store[k] = value\n        return store\n\n    if isArray(o):\n        for i, item in enumerate(o):\n            o[i] = fn(o[i]) or item\n        return o\n"
  },
  {
    "name": "downloadGithubFile",
    "text": "def downloadGithubFile(\n    file, user=\"kdog3682\", repo=\"codemirror\""
  },
  {
    "name": "downloadIt",
    "text": "def downloadIt(f):\n    if isUrl(f):\n        name = tail(f)\n        if isfile(name):\n            return name\n        write(name, request(f))\n        return name\n    return f\n"
  },
  {
    "name": "tempest",
    "text": "def tempest(data=0, name=0):\n    f = \"temp.json\"\n    if not data:\n        print(\"no data\")\n        return\n    write(f, data)\n    ofile(f)\n    return\n    if not data:\n        return\n\n    if not name:\n        name = addExtension(\n            tail(sys.argv[0]), \"json\", force=1\n        )\n\n    if isRecent(name, minutes=5):\n        prev = read(name)\n        if deepEqual(data, prev):\n            return prev\n\n    if not data:\n        lib = globals()\n        if lib.get(\"store\"):\n            data = lib.get(\"store\")\n    if not data:\n        print(\"no data\")\n        return\n\n    write(name, data)\n    ofile(name)\n    return \"\"\n"
  },
  {
    "name": "self",
    "text": "def self():\n    return sys.argv[0]\n"
  },
  {
    "name": "deepEqual",
    "text": "def deepEqual(_v1, _v2):\n    import operator\n    import types\n\n    def _deep_dict_eq(d1, d2):\n        k1 = sorted(d1.keys())\n        k2 = sorted(d2.keys())\n        if k1 != k2:  # keys should be exactly equal\n            return False\n        return sum(\n            deepEqual(d1[k], d2[k]) for k in k1\n        ) == len(k1)\n\n    def _deep_iter_eq(l1, l2):\n        if len(l1) != len(l2):\n            return False\n        return sum(\n            deepEqual(v1, v2) for v1, v2 in zip(l1, l2)\n        ) == len(l1)\n\n    op = operator.eq\n    c1, c2 = (_v1, _v2)\n\n    for t in [str]:\n        if isinstance(_v1, t):\n            break\n    else:\n        if isinstance(_v1, dict):\n            op = _deep_dict_eq\n        else:\n            try:\n                c1, c2 = (list(iter(_v1)), list(iter(_v2)))\n            except TypeError:\n                c1, c2 = _v1, _v2\n            else:\n                op = _deep_iter_eq\n\n    return op(c1, c2)\n    # print(deepEqual([{'a':1}, 1], [1, {'a': 1}]))\n    # fails because of the type ordering\n"
  },
  {
    "name": "getFileDependencies",
    "text": "def getFileDependencies(file):\n    e = getExtension(file)\n    if e == \"js\":\n        regex = \"require\\(['\\\"]?\\.?/?([\\w.]+)\"\n    if e == \"py\":\n        regex = \"(?:\\n|^)from ([\\w]+) import\"\n    if e == \"html\":\n        regex = (\n            \"['\\\"]\"\n            + \"(\\S+\\.(?:js|css|jpeg|png|svg|jpg))\"\n            + \"['\\\"]\"\n        )\n\n    files = unique(\n        re.findall(regex, removeComments(read(file)))\n    )\n    if e == \"html\":\n        files.append(file)\n    elif e == \"py\":\n        files = map(files, lambda x: addExtension(x, \"py\"))\n    return files\n"
  },
  {
    "name": "queryString",
    "text": "def queryString(base=\"quotable.io\", root=\"quotes\", ref={}):\n    def runner(ref):\n        s = \"\"\n        for k, v in ref.items():\n            s += k + \"=\" + str(v) + \"&\"\n        return s[:-1]\n\n    return (\n        \"https://\" + base + \"/\" + root + \"?\" + runner(ref)\n    )\n"
  },
  {
    "name": "_gzip",
    "text": "def _gzip(file):\n    import gzip\n\n    with gzip.open(file, mode=\"rb\") as f:\n        data = json.loads(f.read().decode(\"utf-8\"))\n        return data\n"
  },
  {
    "name": "log",
    "text": "def log(key=0, files=0, file=0):\n    if files:\n        files.sort()\n        data = map(\n            files,\n            lambda x: datestamp() + \" \" + key + \" \" + x,\n        )\n        pprint(data)\n        input()\n\n    elif file:\n        data = datestamp() + \" \" + file\n\n    append(\"/home/kdog3682/logs.txt\", join(data))\n"
  },
  {
    "name": "isWord",
    "text": "def isWord(s):\n    return test(\"^[a-zA-Z]+$\", s)\n"
  },
  {
    "name": "inferlang",
    "text": "def inferlang(s):\n    if isString(s) and len(s) <= 4 and isWord(s):\n        return s\n    if s in utfe:\n        return s\n    if getExtension(s):\n        return getExtension(s)\n    match = search(\n        \"^(?:\\{|\\[]\\$|mkdir|touch|cd|npm|touch|function|def|<|\\.|let|var|const)\",\n        s,\n        flags=re.M,\n    )\n    ref = {\n        \"[\": \"json\",\n        \"{\": \"json\",\n        \"touch\": \"npm\",\n        \"mkdir\": \"npm\",\n        \"cd\": \"npm\",\n        \"$\": \"npm\",\n        \"touch\": \"npm\",\n        \"nano\": \"npm\",\n        \"var\": \"js\",\n        \"let\": \"js\",\n        \"function\": \"js\",\n        \"const\": \"js\",\n        \"def\": \"py\",\n        \"<\": \"html\",\n        \".\": \"css\",\n    }\n    return ref.get(match)\n"
  },
  {
    "name": "getJspy",
    "text": "def getJspy():\n    import inspect\n\n    locals = inspect.currentframe().f_back.f_locals\n    indexes = [\"js\", \"py\", \"vim\", \"bash\", \"css\", \"html\"]\n    #ref = locals()\n    pprint(locals)\n"
  },
  {
    "name": "jspy",
    "text": "def jspy(lang, key):\n    lang = inferlang(lang)\n\n    namePY = \"^(?:\\w+(?= )|(?<=def |class )\\w+)\"\n    nameJS = (\n        \"^(?:(?:async )?function|def|class|const) ([\\w\\$]+)\"\n    )\n    callablePY = \"\\w\\w\\w+\\.(?!log|toString)[a-z]\\w+(?=\\()\"\n    callablePY = \"[\\w\\.]{8,}(?=\\()\"\n    callableJS = (\n        \"new \\w+|\\w\\w\\w+\\.(?!log|toString)[a-z]\\w+(?=\\()\"\n    )\n    # variableJS = '(?:const )?\\w+ = (?:.+?[^\\[\\{](?=\\n)|[\\w\\W]+?\\n[\\]\\}])'\n    variableJS = \"^(?:const )?\\w+ = \\w.+\"\n    cleanupJS = \"^(?:const )?\\w+ = \\w.+\"\n    cleanupJS = \"^\\w+(?:\\.\\w+)*\\(.+\"\n    cleanupPY = \"^(?:const )?\\w+ = \\w.+|^(?:new \\w+|\\w\\w\\w+\\.(?!log|toString)[a-z]\\w+\\().+\"\n    variablePY = \"\\w+ = (?:.+[^\\[\\{]|[\\w\\W]+?\\n[\\]\\}]\"\n    commentJS = \"// \"\n    commentPY = \"# \"\n    functionJS = \"(?:(?<=\\n)|^)(?:(?:async )?function|class) \\w+\\\\b[\\w\\W]+?\\n}(?=\\n|$)\"\n    functionJS = \"(?:(?<=\\n)|^)(?:const [\\w\\$]+ = [\\[\\{][\\w\\W]+?\\n[\\]\\}]|(?:(?:async )?function|class) [\\w\\$]+\\\\b[\\w\\W]+?\\n})(?=\\n|$)\"\n    functionPY = (\n        \"^(?:@.+\\n)*(?:def|class) \\w+\\\\b[\\w\\W]+?(?=\\n\\S)\"\n    )\n\n    functionBodyJS = (\n        \"^(?:(?:async )?function|class) [\\w\\W]+\\n}\"\n    )\n    functionBodyPY = \"^(?:def|class) [\\w\\W]+(?=\\n\\S+)\"\n\n    codeJS = \"(?:(?<=\\n)|^)(?:(?:(?:async )?function|class) \\w+\\\\b|const \\w+ *= *[\\[\\{])[\\w\\W]+?\\n[\\]\\}]\"\n    codePY = \"^(?:def|class) [\\w\\W]+(?=\\n\\S+)\"\n    linebreakJS = (\n        \"/* ------------------------------------- */\"\n    )\n    linebreakPY = \"# -------------------------------------\"\n\n    indexes = [\"js\", \"py\", \"vim\", \"bash\", \"css\", \"html\"]\n\n    ref = {\n        \"compiler\": [\"node\", \"python3\", None, \"bash\"],\n        \"runtime\": [\"node\", \"python3\", None, \"bash\"],\n        \"const\": [\"const \", \"\", \"let\"],\n        \"callableRE\": [callableJS, callablePY],\n        \"nameRE\": [nameJS, namePY],\n        \"functionRE\": [functionJS, functionPY],\n        \"functionBodyRE\": [functionBodyJS, functionBodyPY],\n        \"commentRE\": [commentJS, commentPY],\n        \"superComment\": [\"//// \", \"#### \"],\n        \"//\": ['//', '#'],\n        \"variableRE\": [variableJS, variablePY],\n        \"cleanupRE\": [cleanupJS, cleanupPY],\n        \"codeRE\": [codeJS, codePY],\n        \"linebreak\": [linebreakJS, linebreakPY],\n        \"comment\": [commentJS, commentPY],\n    }\n\n    value = ref[key][indexes.index(lang)]\n    return value\n"
  },
  {
    "name": "prepend",
    "text": "def prepend(file, content):\n    write(file, content + \"\\n\\n\" + read(file))\n"
  },
  {
    "name": "getFunctionName",
    "text": "def getFunctionName(s):\n    rA = \"^(?:@.+\\n)*(?:(?:async )?function|def|class|const|var|let) ([\\w\\$]+)\"\n    rA = \"^(?:@.+\\n)*(?:(?:async )?function[!*]?|def|class|const|var) ([\\w\\$]+)\"\n    rB = \"^([\\w\\$]+) =\"\n    return search(rA, s) or search(rB, s)\n"
  },
  {
    "name": "getFunctionNames",
    "text": "def getFunctionNames(s):\n    r = \"^(?:(?:async )?function|class|def) ([\\w\\$]+)\"\n    return unique(re.findall(r, textgetter(s), flags=re.M))\n"
  },
  {
    "name": "textgetter",
    "text": "def textgetter(x):\n    if isArray(x):\n        return x\n    if x == 'self':\n        return read(currentFile())\n    if isfile(x):\n        return read(x)\n    if len(x) > 100:\n        return x\n    if isUrl(x):\n        return request(x)\n    return x\n"
  },
  {
    "name": "functiongetter",
    "text": "def functiongetter(x, lang=None):\n    regex = jspy(lang or x, \"functionRE\")\n    matches = re.findall(regex, textgetter(x))\n    return {getFunctionName(item): item for item in matches}\n"
  },
  {
    "name": "worwo",
    "text": "def worwo(fn, args):\n    return fn(*args) if exists(args) else fn()\n"
  },
  {
    "name": "isLibraryFile",
    "text": "def isLibraryFile(f):\n    library = [\n        \"jshint.js\",\n        \"jshint.js\",\n        \"vue.js\",\n        \"socket.io.js\",\n        \"codemirror.js\",\n        \"lorem.js\",\n        \"vue3.js\",\n        \"katex.min.js\",\n        \"vuex.min.js\",\n        \"nerdamer.js\",\n        \"katex.min.css\",\n        \"jquery.min.js\",\n        \"mathquill.min.js\",\n        \"mathquill.css\",\n        \"prosemirror.js\",\n        \"prosemirror.css\",\n        \"standalone.min.js\",\n        \"jsxgraphcore.js\",\n        \"jsxgraph.css\",\n        \"parser-babel.js\",\n        \"parser-html.min.js\",\n    ]\n    name = tail(f)\n    r = '\\.(?:esm|min)'\n    return name in library or test(r, name)\n"
  },
  {
    "name": "reduce",
    "text": "def reduce(items, fn):\n    store = {}\n\n    if isObject(items):\n        for k, v in items.items():\n            value = fn(k, v)\n\n            if not value:\n                continue\n            elif isArray(value) and len(value) == 2:\n                if value[1] != None:\n                    store[value[0]] = value[1]\n            else:\n                store[k] = value\n\n    else:\n        for item in list(items):\n            value = fn(item)\n\n            if not value:\n                continue\n            elif isArray(value) and len(value) == 2:\n                store[value[0]] = value[1]\n            else:\n                store[item] = value\n\n    return store\n"
  },
  {
    "name": "hasLookAround",
    "text": "def hasLookAround(s):\n    return test(\"\\(\\?\\<\", s)\n"
  },
  {
    "name": "btest",
    "text": "def btest(r, s):\n    return test(\"\\\\b\" + r + \"\\\\b\", s, flags=re.I)\n"
  },
  {
    "name": "curpath",
    "text": "def curpath():\n    print(abspath(os.getcwd()))\n"
  },
  {
    "name": "sendToOutboundDrive",
    "text": "def sendToOutboundDrive(file=None):\n    return cfile(file, outdir)\n"
  },
  {
    "name": "sendEmail",
    "text": "def sendEmail():\n    s = read(\"letters.txt\")\n    subject, body = splitonce(s, \"\\n\")\n    to = \"nadiranarine@gmail.com\"\n    to = \"kdog3682@gmail.com\"\n\n    callable = f\"\"\"\n        email2({{\n            'subject': '{subject}',\n            'body': `{body}`,\n            'to': '{to}',\n        }})\n    \"\"\"\n    googleAppScript(callable)\n"
  },
  {
    "name": "filegetter",
    "text": "def filegetter(s):\n    if s.endswith(\"files.txt\"):\n        try:\n            data = read(s)\n            files = split(data, \"\\n+\")\n            number(files)\n            return files\n        except Exception as e:\n            return []\n"
  },
  {
    "name": "fixChromebookFilePath",
    "text": "def fixChromebookFilePath(s):\n    if \"penguin\" in s:\n        s = re.sub(\n            \".*?penguin\", \"/home/kdog3682\", s, count=1\n        )\n        s = re.sub(\"%20\", \" \", s)\n    return s\n\n"
  },
  {
    "name": "lastFile",
    "text": "def lastFile(key):\n    f = mostRecent(dirgetter(key))\n    assert isfile(f)\n    return f\n"
  },
  {
    "name": "macPrint",
    "text": "def macPrint():\n    url = macdirdict.get(\"drive\")\n    cmd = \"lp -o sides=two-sided-long-edge \" + url\n    os.system(cmd)\n\n"
  },
  {
    "name": "printer",
    "text": "def printer(\n    file=None, doubleSided=1, copies=1, landscape=0"
  },
  {
    "name": "foo",
    "text": "def foo():\n    f = \"/home/kdog3682/CWF.files.json\"\n    data = read(f)\n    store = []\n    for k, v in data.items():\n        chdir(k)\n        a = choose(v)\n        store.append(map(a, abspath))\n"
  },
  {
    "name": "foo1",
    "text": "def foo1():\n    # files  =  temp()\n    # y  =  files.get('y')\n    b = read(\"/home/kdog3682/CWF.files.json\")\n\n    def p(v):\n        partitioner = Partitioner(v)\n        return partitioner.storage.store\n\n    files = {\n        k: p(v)\n        for k, v in b.items()\n        if not \"vosk\" in k and isdir(k)\n    }\n    tempest(files)\n    return\n    store = []\n    trash = []\n    folders = ff(onlyFolders=1, dir=\"cwf\", public=1)\n    _sweep(folders)\n    # prompt(folders)\n    # map(folders, rmdir, 1)\n    # log('removing', folders)\n    # return\n\n    for f in folders:\n        if f == \"public\":\n            input(\"skipping public\")\n            continue\n        files = os.listdir(f)\n        a = choose(files)\n        if len(a) == len(files):\n            a = None\n        if a:\n            store += map(a, lambda x: os.path.join(f, x))\n        if input(\"delete dir? \" + f):\n            trash.append(f)\n\n    write(\"files.json\", store)\n    prompt(store)\n    ofile(\"files.json\")\n    dirs = choose(trash)\n    map(dirs, rmdir)\n"
  },
  {
    "name": "rmdirs",
    "text": "def rmdirs(dirs):\n    log(\"rmdir\", dirs)\n    map(dirs, lambda x: rmdir(x, 1))\n"
  },
  {
    "name": "happend",
    "text": "def happend(file, data, open=0):\n    if not data:\n        return\n    file = toRoot(file)\n    append(file, data)\n    ofile(file)\n"
  },
  {
    "name": "hwrite",
    "text": "def hwrite(file, data, open=0):\n    if not data:\n        return\n    file = toRoot(file)\n    write(file, data)\n    if open:\n        ofile(file)\n"
  },
  {
    "name": "hread",
    "text": "def hread(file):\n    return ofile(toRoot(file))\n    return read(toRoot(file))\n"
  },
  {
    "name": "hjson",
    "text": "def hjson(key, *args):\n    data = key if isObject(key) else {key: args}\n    prev = read(\"jspy.json\") or {}\n    prev.update(data)\n    hwrite(\"jspy.json\", data, open=1)\n"
  },
  {
    "name": "jspydata",
    "text": "def jspydata(lang=\"js\"):\n    ref = {\"python\": {}}\n    # try:\n    # parent = getCaller()\n    # ref = hread('jspy.json')\n    # indexes = ['js', 'py', 'vim', 'bash', 'css', 'html']\n    # data = ref[parent][indexes.index(lang)]\n    # return data\n    # except Exception as e:\n    # return\n"
  },
  {
    "name": "build_my_functions",
    "text": "def build_my_functions(lang):\n    path = lang + \".functions.json\"\n    files = ff(lang)\n    data = {tail(f): getFunctionNames(f) for f in files}\n    hwrite(path, data)\n\n    # \"leftovers.py\",\n    # \"ignore.py\",\n    # \"combine.py\",\n    # \"websterdictionary.json\",\n    # \"wordlist.json\",\n    # \"googlewordlist.txt\",\n    # \"commonwords.json\",\n    # \"top3000words.json\",\n    # \"paction.js\",\n    # \"twil.js\",\n"
  },
  {
    "name": "_gr",
    "text": "def _gr(inpath, r, outpath, flags=0):\n    if isNumber(r):\n        r = f\"\\\\b[a-z]{{{r}}}\\\\b\"\n    s = textgetter(inpath)\n    m = sort(\n        filter(unique(re.findall(r, s, flags)), ignoreWords)\n    )\n    print(len(m))\n    write(outpath, m, open=1)\n    return m\n"
  },
  {
    "name": "clipf",
    "text": "def clipf(fn):\n    def decorator(self, *args, **kwargs):\n        value = fn(self, *args, **kwargs)\n        clip(value)\n\n    return decorator\n"
  },
  {
    "name": "earlyReturn",
    "text": "def earlyReturn(fn):\n    def decorator(self, *args, **kwargs):\n        value = fn(self, *args, **kwargs)\n        self.value = value\n        return value\n\n    return decorator\n"
  },
  {
    "name": "stateCache",
    "text": "def stateCache(fn):\n    def decorator(self, *args, **kwargs):\n        value = fn(self, *args, **kwargs)\n        self.value = value\n        return value\n\n    return decorator\n"
  },
  {
    "name": "getsetf",
    "text": "def getsetf(file, prepend=0, name=0, append=0):\n    def wrapper(fn):\n        def decorator():\n            data = parseJSON(read(file))\n            value = fn(data)\n            if name:\n                if isNestedArray(value):\n                    value = dict(value)\n                value = createVariable(name, value, \"\")\n            if prepend:\n                write(\n                    prepend, value + \"\\n\\n\" + read(prepend)\n                )\n\n            elif append:\n                write(append, read(append) + \"\\n\\n\" + value)\n            else:\n                write(file, value, open=1)\n\n        return decorator\n\n    return wrapper\n"
  },
  {
    "name": "stateAction",
    "text": "def stateAction(f=0):\n    def wrapper(fn):\n        def decorator(self, *args, **kwargs):\n            value = fn(self, *args, **kwargs)\n            clip()\n\n        return decorator\n\n    return wrapper\n"
  },
  {
    "name": "logf",
    "text": "def logf(fn):\n    def decorator(*args, **kwargs):\n        value = fn(*args, **kwargs)\n        return value\n\n    return decorator\n"
  },
  {
    "name": "find_file",
    "text": "def find_file(q, dir=dldir):\n    with CD(dir):\n        files = sorted(os.listdir(dir), key=mdate)\n        for file in files:\n            if test(q, file):\n                return abspath(file)\n"
  },
  {
    "name": "p",
    "text": "def p(k, v):\n    if v < 10000:\n        return\n    return v\n    if test(\"[^'\\w]\", k):\n        return\n    if v < 1000:\n        return 1000\n    if v < 10000:\n        return 10000\n    if v < 100_000:\n        return 100_000\n    if v < 1_000_000:\n        return 1_000_000\n"
  },
  {
    "name": "A1",
    "text": "def A1(dir):\n    path = (\n        f\"/home/kdog3682/CWF/public/{dir}.functions.json.js\"\n    )\n    prompt(path)\n\n    def runner(f):\n        store = []\n        file = tail(f)\n        date = mdate(f)\n        lib = functiongetter(read(f), f)\n        for name, value in lib.items():\n            store.append(\n                {\n                    \"file\": file,\n                    \"date\": date,\n                    \"name\": name,\n                    \"value\": value,\n                }\n            )\n        return store\n\n    data = ff(dir=dir, fn=runner, js=1)\n    write(path, data, open=1)\n"
  },
  {
    "name": "scrapeEmojis",
    "text": "def scrapeEmojis():\n    chdir(\"cwf\")\n    request = RequestLimiter()\n\n    u = \"https://emojipedia.org/noto-emoji/\"\n    r = 'href=\"([\\w-]{3,})\"'\n    r2 = 'value=\"(.*?)\"'\n    store = {}\n\n    def f(x):\n        url = u + x\n        m = search(r2, request.get(url))\n        if m:\n            store[x] = m\n\n    data = gr(r)\n    map(data, f)\n    write(\"emojis.json\", store, open=1)\n"
  },
  {
    "name": "srequest",
    "text": "def srequest(url):\n    if isRecent(\"request.temp.txt\", minutes=50):\n        print(\"returning recent file\")\n        return read(\"request.temp.txt\")\n\n    s = request(url)\n    if not s:\n        print('no text')\n    write(\"request.temp.txt\", s, open=1)\n    return s\n"
  },
  {
    "name": "finder",
    "text": "def finder(url, term):\n    s = srequest(url)\n    templates = [\n        \"(?:b)>$1</(?:b)\",\n        \"(?:name|value) *= *[\\\"']$1[\\\"']\",\n    ]\n\n    for template in templates:\n        r1 = templater(template, term)\n        a1 = search(r1, s)\n        if a1:\n            r = r1.replace(term, \"([\\w-.]+)\")\n            m = rf(r, s)\n            write(\"found.json\", m, open=1)\n            return m\n"
  },
  {
    "name": "rf",
    "text": "def rf(r, s, flags=0):\n    m = re.findall(r, s, flags)\n    if not m:\n        return []\n    f = lambda x: x not in ignoreWords and len(x) > 2\n    return sort(filter(unique(m), f))\n"
  },
  {
    "name": "gr",
    "text": "def gr():\n    # s = map(re.findall(r, globalconfig.strip(), flags = re.M), filter)\n    last = re.split(\n        \"\\n+\", globalconfig.strip(), flags=re.M\n    )[-1]\n    r = \"^(\\S+) (.*?) (\\S+) *$|^(\\S+) *\\n(\\S.+) *\\n(\\S+)$\"\n    s = filter(search(r, last))\n    if s:\n        if \"finder\" in s[0] and \"http\" in s[1]:\n            fn, *args = s\n            print(args)\n            return globals().get(fn)(*args)\n        if \"\\\\\" in s[1]:\n            inpath, regex, outpath = s\n            outpath = addExtension(outpath, \"json\")\n            _gr(inpath, regex, outpath)\n            return\n\n    r = \"^(\\S+) (\\S.+)$\"\n    s = search(r, last)\n    if s:\n        a, b = s\n        if a == \"read\":\n            value = read(b)\n            pprint(value)\n            return value\n"
  },
  {
    "name": "saveas",
    "text": "def saveas(inpath, outpath):\n    if isfile(outpath) and not prompt(\n        \"overrwrite?\", outpath\n    ):\n        return\n\n    outpath = normpath(inpath, outpath)\n    outpath = addExtension(outpath, getExtension(inpath))\n    prompt(\"move it?\", inpath, outpath)\n    write(outpath, read(inpath))\n    clear(inpath)\n"
  },
  {
    "name": "isf",
    "text": "def isf(file):\n    a = pubdir + file\n    if isfile(a):\n        print(a)\n        return\n\n    a = cwfdir + file\n    if isfile(a):\n        print(a)\n        return\n    print(\"not a file\")\n"
  },
  {
    "name": "boo",
    "text": "def boo():\n    \"\"\"\n    the rootdir always refers to ~/\n    this may not be active\n    it is not active\n    todo\n    \"\"\"\n\n    files = ff(txt=1, dir=\"root\", ignore=\"logs|questions\")\n    data = split(join(map(files, read)), \"\\n\\n+\")\n    write(\"data.json.js\", data)\n    prompt(files)\n    map(files, rfile)\n"
  },
  {
    "name": "error",
    "text": "def error():\n    pass\n"
  },
  {
    "name": "incorporateCss",
    "text": "def incorporateCss(outpath=None):\n    file = mostRecent(dldir, css=1)\n    # raise Exception(file)\n    s = read(file)\n    append(\n        \"/home/kdog3682/CWF/public/\" + outpath + \".css\", s\n    )\n"
  },
  {
    "name": "temp",
    "text": "def temp():\n    return read(tempfile)\n"
  },
  {
    "name": "_addcss",
    "text": "def _addcss(file=None):\n    last = mostRecent(dldir)\n    if getExtension(last) == \"css\":\n        append(\n            \"/home/kdog3682/CWF/public/new.css\", read(last)\n        )\n"
  },
  {
    "name": "ldf",
    "text": "def ldf(x):\n    dir = drivedir\n    e = None\n    if isdir(x):\n        dir = x\n    else:\n        e = [x]\n    files = filter(absdir(dir), checkpointf(extensions=e))\n    recent = mostRecent(files, hours=10)\n    pprint(recent)\n    return recent\n\n"
  },
  {
    "name": "namer",
    "text": "def namer(x):\n    print(getCaller(-1) + \":\", x)\n"
  },
  {
    "name": "_asset",
    "text": "def _asset(name, data):\n    append(\n        \"/home/kdog3682/CWF/public/\" + name,\n        createVariable(\n            removeExtension(name), data, lang=\"js\"\n        ),\n    )\n\n"
  },
  {
    "name": "sendTextMessages",
    "text": "def sendTextMessages(f):\n    s = textgetter(f)\n    r = \"^ *(?:// *)?\" + datestamp()\n    s = re.split(r, s, flags=re.M)\n    s = s[-1]\n    s = removeComments(s, f)\n    s = split(s, \"^--+\", flags=re.M)\n\n    def fn(s):\n        print(s)\n        lang = search(\"hi|hola|hello|nihao\", s, flags=re.I)\n        ref = {\n            \"hi\": \"english\",\n            \"hola\": \"spanish\",\n            \"hello\": \"english\",\n            \"nihao\": \"chinese\",\n        }\n        lang = ref.get(lang.lower(), \"english\")\n        if lang == \"english\":\n            return s\n\n        return googleTranslate(s, lang)\n\n    return map(map(s, fn), _twilio)\n"
  },
  {
    "name": "writeAllFunctions",
    "text": "def writeAllFunctions(key=\"pub\", query=0):\n    ref = {\n        \"pub\": {\"js\": 1, \"dir\": \"pub\"},\n        \"jch\": {\"js\": 1, \"dir\": \"jch\"},\n    }\n\n    lang = \"js\" if ref[key].get(\"js\") else \"py\"\n    name = join(\n        \"functions\", key, lang, \"json\", delimiter=\".\"\n    )\n    kwargs = ref[key]\n    if query:\n        data = read(name)\n        data = filter(data, lambda k, v: some(v, query))\n        files = 0\n        with CD(dirgetter(kwargs.get(\"dir\"))):\n            files = map(list(data.keys()), abspath)\n        print(files)\n        write(\"temp-bookmarks.files.txt\", files)\n        return\n    return\n\n    files = ff(**kwargs)\n\n    def f(f):\n        return [tail(f), sort(getFunctionNames(read(f)))]\n\n    append(\"bookmarks.files.txt\", name)\n    write(name, reduce(files, f), open=1)\n"
  },
  {
    "name": "writeStringToCurrentFile",
    "text": "def writeStringToCurrentFile(s):\n    frame = inspect.currentframe()\n    frame = inspect.getouterframes(frame)[1]\n    s = (\n        inspect.getframeinfo(frame[0])\n        .code_context[0]\n        .strip()\n    )\n    args = s[s.find(\"(\") + 1 : -1].split(\",\")\n\n    names = []\n    for i in args:\n        if i.find(\"=\") != -1:\n            names.append(i.split(\"=\")[1].strip())\n        else:\n            names.append(i)\n\n    argName = names[0]\n"
  },
  {
    "name": "currentify",
    "text": "def currentify():\n    file = glf()\n    dest = \"/home/kdog3682/CWF/public/current.txt\"\n    if test(\"^\\w+\\.\\w+$\", tail(file)):\n        dest = tail(file)\n    cfile(file, pubdir + dest)\n"
  },
  {
    "name": "hasNewline",
    "text": "def hasNewline(s):\n    return \"\\n\" in s\n"
  },
  {
    "name": "regexjoin",
    "text": "def regexjoin(*args):\n    return \"|\".join(list(args))\n"
  },
  {
    "name": "findall",
    "text": "def findall(r, text):\n    def parser(s):\n        if isArray(s):\n            s = smallify(filter(s))\n        return s\n\n    m = re.findall(r, text)\n    return [parser(x) for x in m]\n"
  },
  {
    "name": "smallify",
    "text": "def smallify(items):\n    return items[0] if len(items) == 1 else items\n"
  },
  {
    "name": "mainScrape",
    "text": "def mainScrape():\n\n    r = regexjoin(\n        regexdiv(\"pre\"),\n        regexdiv(\"code\"),\n        regexdiv(\"div\", attrs='class=\"highlight'),\n    )\n    url, regex = splitonce(prompt(\"url and regex*\"))\n    text = request(url)\n    if regex:\n        regex = RegexLib.get(regex, regex)\n        m = sorted(unique(findall(regex, text)))\n        write(\n            \"scrape.js\", createVariable(\"temp\", m), open=1\n        )\n    else:\n        m = findall(r, text)\n        m = filter(m, lambda x: len(x) > 100)\n        m = map(m, getPureHtml)\n        s = \"\\n\\n\".join(m)\n        s = removeComments(s)\n        write(\"scrape.js\", s, open=1)\n"
  },
  {
    "name": "getPureHtml",
    "text": "def getPureHtml(s):\n    import bs4\n    return bs4.BeautifulSoup(s, \"html.parser\").get_text()\n"
  },
  {
    "name": "regexdiv",
    "text": "def regexdiv(\n    tag, attrs=0, content=\"[\\w\\W]+?\", after=\"\", before=\"\""
  },
  {
    "name": "parens",
    "text": "def parens(s):\n    return f\"({s})\"\n"
  },
  {
    "name": "super",
    "text": "def super(s):\n    # input('starting super!!!')\n    arg = search(\".+$\", s.strip()).strip()\n    a, b = splitonce(arg)\n    myFunctions = globals()\n    if a in myFunctions:\n        f = myFunctions[a]\n        f(b) if b else f()\n        return\n\n    else:\n        r = regexdiv(\"table\")\n        m = re.findall(r, request(arg))\n        # write('scrape.json', m)\n"
  },
  {
    "name": "createShellArgs",
    "text": "def createShellArgs(args):\n    raise Exception()\n    def parser(arg):\n        if \"zz\" in arg:\n            value = shellunescape(arg)\n            if isJsonParsable(value):\n                return re.sub(\"\\\\\\\\\", \"\", value)\n            else:\n                return wrap(value, '\"\"\"')\n        elif isNumber(arg):\n            return arg\n        elif \"=\" in arg:\n            f = lambda x: parser(x.group(0))\n            return re.sub(\"(?<==)\\w+\", f, arg)\n        else:\n            return wrap(arg, '\"')\n\n    return join(map(args, parser), delimiter=\", \")\n"
  },
  {
    "name": "shellescape",
    "text": "def shellescape(s):\n    dict = reverse(shellescapedict)\n    regex = reWrap(dict)\n    def parser(x):\n        value = (\n            dict.get(x.group(1))\n            if x.groups()\n            else dict.get(x.group(0))\n        )\n        if not value: prompt(x=x, error='shellescape')\n        return 'zz' + value\n\n    return re.sub(regex, parser, s)\n\n"
  },
  {
    "name": "shellunescape",
    "text": "def shellunescape(s):\n    if not isString(s):\n        return s\n    if 'zz' not in s:\n        return s\n    s = dreplace(s, shellescapedict, template=\"zz($1)\")\n    return parseJSON(s)\n"
  },
  {
    "name": "createGoogleSecret",
    "text": "def createGoogleSecret():\n    data = {\n        \"web\": {\n            \"client_id\": env.google_client_id,\n            \"client_secret\": env.google_client_secret,\n            \"redirect_uris\": [],\n            \"auth_uri\": \"https://accounts.google.com/o/oauth2/auth\",\n            \"token_uri\": \"https://accounts.google.com/o/oauth2/token\",\n        }\n    }\n    write(\"client_secrets.json\", data)\n"
  },
  {
    "name": "isMovie",
    "text": "def isMovie(s):\n    return s.endswith(\"MOV\")\n"
  },
  {
    "name": "sendToDrive",
    "text": "def sendToDrive(file=None, n=1):\n    cfile(mostRecent(dldir, n), drivedir)\n"
  },
  {
    "name": "recentPdfs",
    "text": "def recentPdfs(dir=dldir):\n    return ff(\"dl pdf\")\n"
  },
  {
    "name": "sortfiles",
    "text": "def sortfiles(files):\n    data = map(files, lambda f: (tail(f), datestamp(f)))\n"
  },
  {
    "name": "partitionByDate",
    "text": "def partitionByDate(files):\n    files = sort(files, mdate, reverse=1)\n    lastDate = timestamp()\n    for file in files:\n        date = mdate(file)\n"
  },
  {
    "name": "outboundData",
    "text": "def outboundData():\n    chdir(\"pub\")\n    f = prompt(\"choose file name\")\n    f = addExtension(f, \"json\")\n    data = createVariable(\n        \"outboundData\", read(f), lang=None\n    )\n    write(\"outbound-data.js\", data)\n"
  },
  {
    "name": "inboundData",
    "text": "def inboundData():\n    data = read(glf())\n    store = dataFile()\n    savedIndexes = data.get(\"saved\")\n    values = [store[i] for i in savedIndexes]\n    tempest(values)\n    return values\n"
  },
  {
    "name": "dataFile",
    "text": "def dataFile():\n    return mostRecent(dldir, name=\"pdf.json$\")\n"
  },
  {
    "name": "toRoot",
    "text": "def toRoot(s):\n    return rootdir + tail(s)\n"
  },
  {
    "name": "itest",
    "text": "def itest(r, s):\n    return test(r, s, flags=re.I)\n"
  },
  {
    "name": "pdf0901",
    "text": "def pdf0901():\n    file = \"/mnt/chromeos/MyFiles/Downloads/Acing the New SAT Math PDF Book.pdf.json\"\n    pages = read(file)\n    tests = []\n    exercises = []\n\n    for i, page in enumerate(pages):\n        i = i + 1\n        if itest(\"exercises? (?:-|\\\\\\\\u|\\u2013)\", page):\n            exercises.append(i)\n        elif itest(\"chapter\\s+\\d+\\s+practice\\s+test\", page):\n            tests.append(i)\n\n    tests = tests[5:]\n    store = []\n    count = 0\n    length = len(tests)\n    i = -1\n    answers = []\n\n    while count < length:\n        i += 1\n        count += 1\n        if count == 3:\n            count = 0\n            try:\n                a = tests[i - 2]\n                b = tests[i - 1]\n                store.extend(list(range(a, b)))\n                answers.append(b + 1)\n            except Exception as e:\n                break\n\n    write(\n        \"pages.json\",\n        {\n            \"exercises\": exercises,\n            \"answers\": answers,\n            \"tests\": store,\n        },\n        open=1,\n    )\n"
  },
  {
    "name": "earlyExit",
    "text": "def earlyExit(*args):\n    for arg in args:\n        print(arg)\n    a = input(\"\")\n    if a:\n        raise Exception(\"early exit\")\n"
  },
  {
    "name": "saveClip",
    "text": "def saveClip():\n    name = prompt(\"choose a save clip destination\")\n    earlyExit(\n        name, \"are you sure? type any input to cancel\"\n    )\n    dest1 = normpath(drivedir, name)\n    dest2 = normpath(pubdir, name)\n    cfile(\"/home/kdog3682/CWF/public/.clip.js\", dest1)\n    cfile(\"/home/kdog3682/CWF/public/.clip.js\", dest2)\n"
  },
  {
    "name": "openLastFile",
    "text": "def openLastFile():\n    ofile(glf(dldir))\n"
  },
  {
    "name": "readClip",
    "text": "def readClip():\n    v = parseJSON(\n        read(\"/home/kdog3682/CWF/public/.clip.js\")\n    )\n    return v\n"
  },
  {
    "name": "fixFileNameFactory",
    "text": "def fixFileNameFactory(dir):\n    chdir(dir)\n    files = os.listdir(dldir)\n\n    def fixFileName(file):\n        if not isfile(file):\n            r = \"^\" + search(\"\\w+\", file)\n            f = testf(r, flags=re.I)\n            file = find(files, f)\n            if not file:\n                raise Exception(\"no file\", item.get(\"file\"))\n        return file\n\n    return fixFileName\n"
  },
  {
    "name": "sortByNumber",
    "text": "def sortByNumber(arr):\n    def f(s):\n        return int(search(\"\\d+\", s))\n\n    return sort(arr, f)\n"
  },
  {
    "name": "newlineIndent",
    "text": "def newlineIndent(x):\n    s = join(x)\n    return \"\\n\" + re.sub(\"^\", \"    \", s, flags=re.M) + \"\\n\"\n"
  },
  {
    "name": "divify",
    "text": "def divify(tag, content):\n    if not isString(content):\n        content = newlineIndent(content)\n\n    return f\"<{tag}>{content}</{tag}>\"\n"
  },
  {
    "name": "text",
    "text": "def text(*args):\n    args = flat(args)\n    s = join(args)\n    f = \"text.txt\"\n    write(f, s)\n    ofile(f)\n    raise Exception()\n"
  },
  {
    "name": "toCallable",
    "text": "def toCallable(f, *args):\n    if not f:\n        return \"\"\n    if test(\"^\\w+\\(\", f):\n        return f\n    payload = \", \".join(map(filter(args), toStringArgument))\n    return f + parens(payload)\n"
  },
  {
    "name": "toStringArgument",
    "text": "def toStringArgument(s):\n    if isString(s):\n        return quote(s)\n    return json.dumps(s)\n"
  },
  {
    "name": "delagoogleEmail",
    "text": "def delagoogleEmail(obj):\n    googleAppScript(toCallable(\"email4\", obj))\n"
  },
  {
    "name": "listdir",
    "text": "def listdir(x):\n    return os.listdir(x)\n"
  },
  {
    "name": "python3",
    "text": "def python3(*args):\n    system(\"python\", *args)\n"
  },
  {
    "name": "emptydir",
    "text": "def emptydir(dir):\n    if isdir(dir):\n        files = absdir(dir)\n        if len(files) == 0:\n            print(\"directory already empty\")\n        else:\n            map(files, os.remove)\n"
  },
  {
    "name": "dumpJson",
    "text": "def dumpJson(payload):\n    if isString(payload):\n        return payload\n    return json.dumps(payload)\n"
  },
  {
    "name": "mimeTypeFromFile",
    "text": "def mimeTypeFromFile(file):\n    ref = {\n        \"txt\": \"text/plain\",\n        \"rtf\": \"application/rtf\",\n        \"pdf\": \"application/pdf\",\n        \"jpg\": \"jpeg\",\n        \"html\": \"text/html\",\n        \"zip\": \"application/zip\",\n        \"png\": \"image/png\",\n        \"svg\": \"image/svg+xml\",\n    }\n    return ref[getExtension(file)]\n"
  },
  {
    "name": "upcomingDate",
    "text": "def upcomingDate(day, mode=0, strife=\"/\", next=0):\n    day = capitalize(day)\n    today = datetime.now()\n\n    def increment():\n        nonlocal today\n        today = today + timedelta(days=1)\n\n    while 1:\n        weekday = weekdays[today.weekday()]\n        if weekday == day:\n            if next:\n                today = today + timedelta(weeks=next)\n            if mode == list:\n                return [today.month, today.day, today.year]\n            if mode == datetime:\n                return today\n            return datestamp(today, strife=strife)\n        else:\n            increment()\n"
  },
  {
    "name": "downloadYoutube",
    "text": "def downloadYoutube(urls):\n    import youtube_dl\n\n    outpath = (\n        \"/home/kdog3682/CWF/public/music/%(title)s.%(ext)s\"\n    )\n    urls = toArray(urls)\n    if isObject(urls[0]):\n        urls = [url.get(\"url\") for url in urls]\n\n    options = {\n        \"format\": \"bestaudio/best\",\n        \"outtmpl\": outpath,\n        \"postprocessors\": [\n            {\n                \"key\": \"FFmpegExtractAudio\",\n                \"preferredcodec\": \"mp3\",\n                \"preferredquality\": \"192\",\n            }\n        ],\n    }\n    with youtube_dl.YoutubeDL(options) as ydl:\n        ydl.download(urls)\n"
  },
  {
    "name": "consolidate",
    "text": "def consolidate(file):\n    lang = getExtension(file)\n    comment = jspy(lang, \"superComment\") + file + \"\\n\\n\"\n    append(\n        \"/home/kdog3682/consolidate.\" + lang,\n        comment + read(file) + \"\\n\",\n    )\n    print(\"consolidated\", file)\n"
  },
  {
    "name": "review",
    "text": "def review(key, move=0, mode=0, **kwargs):\n    files = ff(key, **kwargs)\n    if not files:\n        return \n\n    removed = []\n    moved = []\n    os.system(\"clear\")\n\n    for file in files:\n        if alwaysDelete(file):\n            rfile(file)\n            removed.append(files)\n            continue\n\n        if mode == 'open':\n            if isUtf(file):\n                ofile(file)\n\n        elif isImage(file):\n            ofile(file)\n\n        a = prompt(tail(file), \"d=delete, c=consolidate\\n\\n\")\n        if a == \"d\":\n            rfile(file)\n            removed.append(files)\n        elif a == \"c\":\n            consolidate(file)\n            rfile(file)\n        elif a == \"m\":\n            if move:\n                mfile(file, move)\n                moved.append(file)\n        elif a:\n            if move:\n                mfile(file, changeFileName(file, a, move))\n        elif mode == 'delete':\n            pass\n            #print('delete mode')\n            \n    pprint(removed)\n"
  },
  {
    "name": "unmove",
    "text": "def unmove():\n    mfile(getLast(absdir(trashdir)), cwfdir)\n    # print(glf(trashdir))\n    # mfile(glf(trashdir), cwfdir)\n"
  },
  {
    "name": "blackify",
    "text": "def blackify(s):\n    import black\n\n    return black.format_str(\n        s,\n        mode=black.Mode(\n            target_versions={black.TargetVersion.PY36}\n        ),\n    )\n"
  },
  {
    "name": "dostufff",
    "text": "def dostufff(todo):\n\n    chdir(pubdir)\n    store = {}\n    for k, v in todo.items():\n        if v.startswith(\"off\"):\n            continue\n        elif v == \"d\" or v == \"\" or isRemovableFile(k):\n            try:\n                rfile(k)\n            except Exception as e:\n                continue\n        elif v == \"fn\" or v == \"c\":\n            consolidate(k)\n            rfile(k)\n        else:\n            store[k] = v\n\n    clip(store)\n\n"
  },
  {
    "name": "dirFromFile",
    "text": "def dirFromFile(f):\n    if f.startswith(\"/\"):\n        return head(f)\n    e = getExtension(f)\n    if e == 'py': return pydir\n    return dir2023\n    #return dirdict.get(e, pubdir)\n"
  },
  {
    "name": "dirFromFile2",
    "text": "def dirFromFile2(f):\n    e = getExtension(f)\n    if e == 'py': return pydir\n    return dir2023\n"
  },
  {
    "name": "mlf",
    "text": "def mlf(name=0):\n    f = glf()\n    if is_json(f) and dprompt(f, 'is a json file. do you want to javascriptify it?'):\n        return write(npath(dir2023, changeExtension(f, 'js')), createVariable(file_name(f), read(f), 'js'))\n\n    if name:\n        file = dldir + addExtension(name, getExtension(f))\n        prompt(file)\n        return mfile(f, file)\n    return mfile(f, dirFromFile2(f))\n"
  },
  {
    "name": "moveback",
    "text": "def moveback():\n    f = getLast(absdir(trashdir))\n    d = dirFromFile(f)\n    prompt(d, f)\n    mfile(f, d)\n"
  },
  {
    "name": "renameQuizzes",
    "text": "def renameQuizzes():\n    chdir(dldir)\n    ref = {\n        \"g4 quiz.pdf\": \"Grade 4 Quiz.pdf\",\n        \"g5quiz.pdf\": \"Grade 5 Quiz.pdf\",\n    }\n    for k, v in ref.items():\n        if isfile(k):\n            mfile(k, v)\n"
  },
  {
    "name": "removeDateStamp",
    "text": "def removeDateStamp(s):\n    datestampRE = \"\\d+[-/]\\d+[-/]\\d+\"\n    return re.sub(\"-?\" + datestampRE, \"\", s)\n"
  },
  {
    "name": "autodir",
    "text": "def autodir(file):\n    dir = dirFromFile(file)\n    chdir(dir)\n    return dir\n"
  },
  {
    "name": "isRecentFile",
    "text": "def isRecentFile(f, days=1, **kwargs):\n    return isfile(f) and isRecent(f, days=days, **kwargs)\n\n"
  },
  {
    "name": "recentFiles",
    "text": "def recentFiles():\n    dirs = [rootdir, pubdir, cwfdir]\n    store = []\n    for dir in dirs:\n        store.extend(ff(dir=dir, days=1))\n    return store\n"
  },
  {
    "name": "noDots",
    "text": "def noDots(x):\n    def runner(x):\n        return re.sub(\"(?<=/)\\.(?=[^/]+$)\", \"\", x)\n\n    if isString(x):\n        return runner(x)\n    return map(x, runner)\n"
  },
  {
    "name": "deleteFiles",
    "text": "def deleteFiles(files, save=0, title=0):\n    map(files, mfile, trashdir)\n    if save:\n\n        def infoRunner(f):\n            return [tail(f), datestamp(f)]\n\n        info = map(files, infoRunner)\n        payload = prettyTable(info, title=title)\n        happend(save, payload)\n        print(\"Finished deleting files\")\n\n\n\n\n\n"
  },
  {
    "name": "changeFileName",
    "text": "def changeFileName(file, newName=0, dir=0):\n\n    if not newName: newName = prompt(file, \"new name?\")\n    head, tail = os.path.split(file)\n    if dir: head = dir\n\n    if isFunction(newName):\n        newName = newName(removeExtension(tail))\n\n    newName = addExtension(newName, getExtension(tail))\n    return os.path.join(head, newName)\n\n"
  },
  {
    "name": "fs1",
    "text": "def fs1(s):\n\n    def allFiles(**kwargs):\n        dirs = [rootdir, pubdir, cwfdir]\n        store = []\n        for dir in dirs:\n            store.extend(ff(dir=dir, **kwargs))\n        return store\n\n    \"\"\"\n    1. grab all pdf json txt files\n    2. make directories for pdf json and text\n    3. iterate thru files and move them to the dir\n    \"\"\"\n    files = allFiles(pdf=1, json=1, txt=1)\n\n    ref = {\"pdf\": pdfdir, \"json\": jsondir, \"txt\": txtdir}\n    for dir in ref.values():\n        if not isdir(dir):\n            mkdir(dir)\n\n    for file in files:\n        e = getExtension(file)\n        if e == \"json\":\n            if review11(file):\n                continue\n        d = ref.get(e, \"\")\n        if d:\n            mfile(file, d)\n"
  },
  {
    "name": "uploadResumeAndCoverLetter",
    "text": "def uploadResumeAndCoverLetter():\n    files = mostRecent(dldir, n=5, minutes=10, reverse=1)\n    #pprint(map(files, fileInfo))\n    #pprint(files)\n    #return\n    donecv = 0\n    doneres = 0\n    for file in files:\n        if donecv and doneres:\n            print('done')\n\n        if test(\"cv|cover|letter\", file, flags=re.I):\n            if donecv:\n                continue\n            donecv = file\n        else:\n            if doneres:\n                continue\n            doneres = file\n\n    cvout = npath(dldir, cvfile)\n    resout = npath(dldir, resumefile)\n    prompt(donecv=donecv, doneres=doneres, cvout=cvout, resout=resout)\n    mfile(donecv, cvout)\n    mfile(doneres, resout)"
  },
  {
    "name": "isUtf",
    "text": "def isUtf(file):\n    return getExtension(file) in utfe\n"
  },
  {
    "name": "isImage",
    "text": "def isImage(file):\n    return getExtension(file) in imge\n"
  },
  {
    "name": "isPrivateFile",
    "text": "def isPrivateFile(f):\n    return tail(f).startswith(\".\")\n"
  },
  {
    "name": "alwaysDelete",
    "text": "def alwaysDelete(f):\n    deleteList = [\".clip.js\", \"passwords.csv\"]\n    keepList = ['scratchpad.txt', 'notes.txt']\n    deleteRE = 'view-source|released-items|\\\\bboo\\\\b|debug|dela|foo|\\(|^-?\\d+$'\n    deleteExtensions = [\"log\", \"aux\", \"mhtml\", \"tex\", \"zip\"]\n    name = tail(f)\n    if '\\\\'  in f:\n        return True\n    if isPrivateFile(f):\n        return False\n    if name in keepList:\n        return False\n    if name in deleteList:\n        return True\n    if test(deleteRE, name, flags=re.I):\n        return True \n    if fsize(f) < 20:\n        return True\n    if getExtension(f) in deleteExtensionsList:\n        return True\n"
  },
  {
    "name": "cleanupfiles",
    "text": "def cleanupfiles(dir, f):\n    files = filter(absdir(dir), f)\n    deleteFiles(files, save=\"deleted-files.log.txt\")\n"
  },
  {
    "name": "currentFile",
    "text": "def currentFile():\n    return sys.argv[0]\n"
  },
  {
    "name": "ase",
    "text": "def ase(f):\n    s = parseJSON(read(clipfile))\n    if isArray(s):\n        s = map(unique(s), f)\n    else:\n        s = f(s)\n\n    append(currentFile(), createVariable(\"temp\", s))\n"
  },
  {
    "name": "isRemovablePdfFile",
    "text": "def isRemovablePdfFile(f):\n    name = tail(f)[0:-4]\n    if len(name) < 4 or test(\"sdf|asd|\\(\\d\", name):\n        return 1\n"
  },
  {
    "name": "isWebsite",
    "text": "def isWebsite(url):\n    from requests import get\n\n    return get(url).status_code == 200\n"
  },
  {
    "name": "toLocalFile",
    "text": "def toLocalFile(key):\n    name = localfiledict.get(key, key)\n    dir = \"CWF/public\"\n    return os.path.join(\n        \"file:///media/fuse/crostini_25bd1ae3ef71bac8d459747ce670faa67d509f14_termina_penguin/\",\n        dir,\n        name,\n    )\n"
  },
  {
    "name": "rnl",
    "text": "def rnl():  # name: renameLastFile\n    f = glf()\n    print(f)\n    s = input(\"new name: \")\n    mfile(f, changeFileName(f, s))\n"
  },
  {
    "name": "mget",
    "text": "def mget(r, s, flags=0, mode=dict):\n    store = []\n\n    def parser(x):\n        if x.groups():\n            store.append(\n                x.group(1)\n                if len(x.groups()) == 1\n                else x.groups()\n            )\n        else:\n            store.append(x.group(0))\n\n        return \"\"\n\n    s = re.sub(r, parser, s, flags=flags).strip()\n\n    if mode == list:\n        return [s.strip(), store]\n    if mode == str:\n        if not store:\n            config = \"\"\n        else:\n            config = store[0]\n        return [s, config]\n\n    if not store:\n        config = {}\n    elif isNestedArray(store):\n        config = {k: v for k, v in store}\n    else:\n        config = {k: True for k in store}\n\n    return s, config\n"
  },
  {
    "name": "isNestedArray",
    "text": "def isNestedArray(x):\n    return isArray(x) and exists(x[0]) and isArray(x[0])\n"
  },
  {
    "name": "smartRead",
    "text": "def smartRead(file):\n    dirs = unique(list(dirdict.values()))\n    for dir in dirs:\n        f = os.path.join(dir, file)\n        if isfile(f):\n            return pprint(read(f))\n\n"
  },
  {
    "name": "delta",
    "text": "def delta(a, b):\n    return abs(a - b)\n"
  },
  {
    "name": "getFilesByTimeStamp",
    "text": "def getFilesByTimeStamp():\n    files = mostRecent(dldir, 10, js=1, css=1)\n    files.reverse()\n\n    last = 0\n    store = []\n\n    for file in files:\n        date = mdate(file)\n        if last == 0 or delta(date, last) < ONE_MINUTE:\n            store.append(file)\n            last = date\n        else:\n            return store\n"
  },
  {
    "name": "moveFilesByTimeStamp",
    "text": "def moveFilesByTimeStamp():\n    return map(getFilesByTimeStamp(), mfile, jsdir)\n"
  },
  {
    "name": "filePicker",
    "text": "def filePicker(dir, key=\"open\"):\n    items = (\n        dir\n        if isArray(dir)\n        else sorted(absdir(dirdict.get(dir)), key=mdate)\n    )\n    files = choose(items)\n\n    if key == \"open\":\n        map(files, ofile)\n    elif key == \"rename\":\n        for file in files:\n            mfile(\n                file,\n                changeFileName(\n                    file, input(file + \"\\nnew name? \")\n                ),\n            )\n\n    else:\n        print(files[0])\n        return files[0]\n"
  },
  {
    "name": "h",
    "text": "def h(data=0):\n    hfile = normpath(jsondir, \"temp.json\")\n    if data:\n        write(hfile, data, open=1)\n    else:\n        return read(hfile)\n"
  },
  {
    "name": "unzip",
    "text": "def unzip(file, to):\n    import zipfile\n\n    with zipfile.ZipFile(file, \"r\") as z:\n        z.extractall(to)\n"
  },
  {
    "name": "ranger",
    "text": "def ranger(a):\n    return list(range(a[0], a[1] + 1))\n\n"
  },
  {
    "name": "prompt2",
    "text": "def prompt2(x):\n    os.system(\"clear\")\n    number(x)\n    a = input(\"choose 1 based indexes or regex\\n\\n\")\n    return a\n"
  },
  {
    "name": "findFile",
    "text": "def findFile(f):\n    dirs = unique(dirdict.values())\n    store = []\n    for dir in dirs:\n        file = npath(dir, f)\n        if isfile(file):\n            size = fsize(file)\n            if size > 10:\n                print('valid')\n                print(size)\n                print(file)\n                return file\n\n"
  },
  {
    "name": "shell",
    "text": "def shell(cmd):\n    os.system(cmd)\n\n"
  },
  {
    "name": "normDirPath",
    "text": "def normDirPath(file):\n    dir = dirFromFile(file)\n    return npath(dir, file)\n"
  },
  {
    "name": "normFactory",
    "text": "def normFactory(fn):\n    def lambdaNorm(file, *args, **kwargs):\n        return fn(normDirPath(file), *args, **kwargs)\n\n    return lambdaNorm\n"
  },
  {
    "name": "moveToAppropiateDir",
    "text": "def moveToAppropiateDir(name=0):\n    file = glf()\n    name = changeFileName(file, name)\n    path = normpath(dirFromFile(file), name)\n    mfile(file, path)\n\n"
  },
  {
    "name": "plf",
    "text": "def plf():\n    write(\".foooooo\", glf(), open=1)\n\n"
  },
  {
    "name": "extracter",
    "text": "def extracter(r):\n    store = []\n    for item in h():\n        name = search(r, item)\n        if name:\n            store.append(name.strip())\n    clip(store)\n"
  },
  {
    "name": "vimFileOpener",
    "text": "def vimFileOpener(arg=0, cf=0):\n    file = cf\n    if arg in urldict:\n        file = fixUrl(urldict[arg])\n    elif arg in localfiledict:\n        file = toLocalFile(arg)\n    elif arg in list(localfiledict.values()):\n        file = toLocalFile(arg)\n    elif isUrl(arg) or getExtension(arg):\n        file = arg\n    elif arg:\n        file = googleSearchQuery(arg)\n    openBrowser(file)\n"
  },
  {
    "name": "isPdf",
    "text": "def isPdf(s):\n    return isString(s) and getExtension(s) == \"pdf\"\n"
  },
  {
    "name": "googleSearchQuery",
    "text": "def googleSearchQuery(s):\n    s = s.replace(\" \", \"+\")\n    return f\"https://google.com/search?q={s}\"\n"
  },
  {
    "name": "revertFile",
    "text": "def revertFile(name=None):\n    dir = localbackupdir\n    print(\"getting file from dir:\", dir)\n    file = os.path.join(dir, name) if name else  mostRecent(dir)\n    todir = dirFromFile(tail(file))\n    newName = prompt(fileInfo(file, r=1), dir=dir, todir=todir)\n    if newName:\n        todir = npath(todir, addExtension(newName, getExtension(file)))\n        prompt(outpath=todir)\n    cfile(file, todir)\n\n    return \n    print(\"getting file from budir\", budir)\n    file = mostRecent(budir)\n    dir = dirFromFile(tail(file))\n    prompt(fileInfo(file, r=1), dir)\n    cfile(file, dir)\n"
  },
  {
    "name": "writeBuffer",
    "text": "def writeBuffer(name, data):\n    with open(name, \"wb\") as f:\n        f.write(data)\n    print(\"writing name\", name)\n"
  },
  {
    "name": "parseGoogleDate",
    "text": "def parseGoogleDate(s):\n    return s[5:10] + \"-\" + s[0:4]\n\n"
  },
  {
    "name": "unescapeHtml",
    "text": "def unescapeHtml(s):\n    import html\n\n    return html.unescape(s)\n\n"
  },
  {
    "name": "javascript",
    "text": "def javascript(file, *args):\n    file = npath(jsdir, addExtension(file, \"js\"))\n    response = SystemCommand(\"node\", file, *args)\n    if response.error:\n        return -1\n"
  },
  {
    "name": "isJson",
    "text": "def isJson(f):\n    return getExtension(f) == \"json\"\n\n"
  },
  {
    "name": "changeLastJsonFileToJavascriptAsset",
    "text": "def changeLastJsonFileToJavascriptAsset():\n    name = glf()\n    assert isJson(name)\n    data = json.dumps(read(name))\n    name = camelCase(tail(name))\n    s = \"var \" + name + \" = \" + data\n    normAppend(\"json.js\", s)\n\n"
  },
  {
    "name": "linegetter",
    "text": "def linegetter(s, trim=1, fn=0, filter=0, u=0, skip=0):\n    s = splitOnWord(s, \"breaker\")\n    s = re.sub('^ *#.+\\n+', '', s, flags=re.M)\n    lines = re.split(\"\\n+\", smartDedent(textgetter(s)))\n    if trim:\n        lines = map(lines, lambda x: x.strip())\n    if filter:\n        lines = [x for x in lines if filter(x)]\n    if skip:\n        lines = lines[skip:]\n    if fn:\n        lines = map(lines, fn)\n    if u:\n        lines = unique(lines)\n    return lines\n"
  },
  {
    "name": "smartDedent",
    "text": "def smartDedent(s):\n    s = re.sub(\"^ *\\n*|\\n *$\", \"\", s)\n    if test(\"^\\S\", s):\n        return s\n    spaces = search(\"^ *(?=\\S)\", s, flags=re.M)\n    secondLineSpaces = search(\"\\n *(?=\\S)\", s)\n    if (\n        not spaces\n        and secondLineSpaces\n        and len(secondLineSpaces) > 4\n    ):\n        return re.sub(\n            \"^\" + secondLineSpaces[5:], \"\", s, flags=re.M\n        ).trim()\n\n    return re.sub(\"^\" + spaces, \"\", s, flags=re.M).strip()\n\n"
  },
  {
    "name": "lowerCase",
    "text": "def lowerCase(s):\n    return s.lower()\n"
  },
  {
    "name": "filterTwice",
    "text": "def filterTwice(items, ref):\n    a = []\n    b = []\n    for item in items:\n        if item in ref:\n            a.append(item)\n        else:\n            b.append(item)\n    return [a, b]\n"
  },
  {
    "name": "addWordsToDictionaryf",
    "text": "def addWordsToDictionaryf(s, corpus=None):\n    known = normRead(\"known.json\") or []\n    s = textgetter(s)\n    words = unique(\n        map(re.findall(\"\\\\b[a-zA-Z]{2,}\\\\b\", s), lowerCase)\n    )\n    words = filter(words, known)\n    if not corpus:\n        corpus = normRead(\"corpus.json\")\n\n    knownWords, unknownWords = filterTwice(words, corpus)\n\n    determined = {}\n    undetermined = []\n\n    for word in unknownWords:\n        a = prompt(word)\n        if a:\n            determined[word] = a\n        else:\n            undetermined.append(word)\n\n    appendjson(normDirPath(\"known.json\"), knownWords)\n    appendjson(normDirPath(\"words.json\"), determined)\n    appendjson(\n        normDirPath(\"undetermined.json\"), undetermined\n    )\n\n"
  },
  {
    "name": "push",
    "text": "def push(store, data=0):\n    if not data:\n        return \n    elif isArray(data):\n        store.extend(data)\n    else:\n        store.append(data)\n"
  },
  {
    "name": "appendjson",
    "text": "def appendjson(file, data, mode=0, ask = 0):\n    if not data:\n        return\n    if ask:\n        prompt(data, 'continue to append?\\nPress ctrl-c to exit\\n')\n    placeholder = [] if mode == list or isArray(data) else {}\n    store = readjson(file, placeholder)\n\n    if mode == list and not isArray(store):\n        store = [store]\n\n    if isArray(store):\n        push(store, data)\n    elif isObject(store):\n        store.update(data)\n\n    #return pprint(stringify(store)) #debugAppendJson\n    write(file, store)\n"
  },
  {
    "name": "readjson",
    "text": "def readjson(file, placeholder={}):\n    try:\n        with open(file) as f:\n            return json.load(f)\n    except Exception as e:\n        return placeholder\n\n"
  },
  {
    "name": "rangeFromString",
    "text": "def rangeFromString(s, offset=1):\n    if isArray(s):\n        return s\n\n    def f(s):\n        if \"-\" in s:\n            a, b = split(s, \" *- *\")\n            store = []\n            for i in range(int(a), int(b) + 1):\n                store.append(i - offset)\n            return store\n        elif s == \"x\":\n            return None\n        else:\n            return [int(s) - offset]\n\n    return flat(map(split(s, \", *| +(?=\\w)\"), f, filter=0))\n"
  },
  {
    "name": "zulustamp",
    "text": "def zulustamp(date):\n    return date.strftime(\"%Y-%m-%dT%H:%M:%SZ\")\n"
  },
  {
    "name": "hms",
    "text": "def hms():\n    return datetime.now().strftime(\"%c\")\n    return datetime.now().strftime(\"%H:%M:%S\")\n"
  },
  {
    "name": "flatdir",
    "text": "def flatdir(dir):\n    files = getfiles(dir, recursive=1, mode=list)\n    map(files, mfile, dldir)\n    rmdir(dir)\n    return map(files, lambda x: npath(dldir, x))\n"
  },
  {
    "name": "dread",
    "text": "def dread(name):\n    return read(dldir + addExtension(name, \"json\"))\n"
  },
  {
    "name": "dwrite",
    "text": "def dwrite(name, data):\n    write(dldir + addExtension(name, \"json\"), data, open=1)\n"
  },
  {
    "name": "getPokemonData",
    "text": "def getPokemonData():\n    store = []\n    for i in range(1, 151):\n        url = \"https://pokeapi.co/api/v2/pokemon/\" + str(i)\n        data = request(url)\n        types = [\n            el.get(\"type\").get(\"name\")\n            for el in data.get(\"types\")\n        ]\n        name = data.get(\"name\")\n        store.append(\n            {\n                \"name\": name,\n                \"types\": types,\n            }\n        )\n        print(\"okay\", i)\n\n    print(len(store))\n    dwrite(\"pokemon\", store)\n"
  },
  {
    "name": "toVariable",
    "text": "def toVariable(a, b):\n    return a + \" = \" + dumpJson(b)\n    prefix = \"var\"\n    return prefix + \" \" + a + \" = \" + dumpJson(b)\n"
  },
  {
    "name": "createPokemonTemplateComponents",
    "text": "def createPokemonTemplateComponents(amount=1):\n    data = dread(\"pokemon\")\n    store = []\n\n    def g(x):\n        # local attrs\n        attr, value = x.groups(1)\n        attrs[attr] = {\"default\": value}\n        return \":\" + attr + '=\"' + attr + '\"'\n\n    def f(x):\n        # local name\n        styleString = (\n            ' class=\"'\n            + \"pokemon\"\n            + \"-icon\\\" :style=\\\"{'width': size + 'px', 'height': size + 'px'}\\\"\"\n        )\n        s = x.group(0)\n        s = re.sub(\n            ' *(xml).*?\".*?\"', styleString, s, count=1\n        )\n        s = re.sub(' *(ver).*?\".*?\"', \"\", s, count=1)\n        # s = re.sub('(width|height|viewbox).*?\"(.*?)\"', g, s, count=3, flags=re.I)\n        return s\n\n    for n in range(1, amount + 1):\n\n        name = data[n - 1].get(\"name\")\n        name = camelCase(name)\n        attrs = {\n            #'name': {'default': name},\n            \"size\": {\"default\": \"100\"},\n        }\n        s = decode(\n            read(\"pokemon-svg/svg/\" + str(n) + \".svg\")\n        )\n        # s = re.sub('[\\w\\W]+?(?=<g)', '', s, count=1)\n        s = re.sub(\"[\\w\\W]+?(?=<svg)\", \"\", s, count=1)\n        s = re.sub(\"[\\w\\W]+?>\", f, s, count=1)\n        # s = re.sub('</svg>\\s*$', '', s, count=1)\n        #'template': '<template>' + s + '</template>',\n        payload = {\n            #'name': name,\n            \"props\": attrs,\n            \"template\": s,\n        }\n        # s = toVariable(name, payload)\n        store.append(payload)\n\n    clip(join(store))\n\n"
  },
  {
    "name": "renameClipFile",
    "text": "def renameClipFile():\n    f = input(\"rename clip file as?\")\n    mfile(\n        normDirPath(clipfile),\n        normDirPath(addExtension(f, \"js\")),\n    )\n"
  },
  {
    "name": "downloadPdfsFromUrl",
    "text": "def downloadPdfsFromUrl(url=None):\n    if not url:\n        url = input(\"url? \")\n    s = request(url)\n    domain = getDomainName(url)\n    r = \"href=['\\\"]?(\\S+?(?:\\.pdf|view))\"\n    m = unique(re.findall(r, s))\n    for file in m:\n        name = tail(file)\n        if isfile(examdir + name):\n            continue\n        try:\n            data = request(domain + file)\n            if len(data) < 10000:\n                print(\"is small\", file)\n                continue\n            write(examdir + name, data)\n        except Exception as e:\n            print(\"error\", name)\n            pass\n"
  },
  {
    "name": "googleId",
    "text": "def googleId(s):\n    return search(\"d/(.*?)/\", s) or s\n\n"
  },
  {
    "name": "upcomingDateObject",
    "text": "def upcomingDateObject(s):\n    date = upcomingDate(s, datetime)\n    string = datestamp(date, \"/\")\n    array = [date.month, date.day, date.year]\n    dueDateObject = date + timedelta(days=8)\n    dueDate = {\n        \"month\": dueDateObject.month,\n        \"day\": dueDateObject.day,\n        \"year\": dueDateObject.year,\n    }\n\n    dueTime = {\n        \"hours\": 1,  # 9PM\n        \"minutes\": 0,\n        \"seconds\": 0,\n    }\n\n    scheduledDate = date.replace(\n        hour=9, minute=0, second=0, day=date.day + 0\n    )\n    currentDate = datetime.now()\n\n    if scheduledDate.day == currentDate.day:\n        scheduledTime = None\n    else:\n        scheduledTime = zulustamp(scheduledDate)\n\n    return {\n        \"array\": array,\n        \"string\": string,\n        \"dueDate\": dueDate,\n        \"dueTime\": dueTime,\n        \"scheduledTime\": scheduledTime,\n    }\n"
  },
  {
    "name": "cleanupFileName",
    "text": "def cleanupFileName(fileName, date=0, prepend=0):\n    if prepend:\n        fileName = prependFilePath(tail(fileName), prepend)\n    fileName = appendFileName(fileName, date)\n    return removeExtension(fileName)\n"
  },
  {
    "name": "appendFileName",
    "text": "def appendFileName(file, payload=\"\"):\n    if not payload:\n        return file\n    if test(\"^\\.\", payload):\n        space = \"\"\n    else:\n        space = \" \"\n    if test(\"\\.\\w+$\", file):\n        s = re.sub(\n            \"(?=\\.\\w+$)\", space + payload, file, count=1\n        )\n    else:\n        s = file + space + payload\n    return s\n"
  },
  {
    "name": "prependFilePath",
    "text": "def prependFilePath(file, payload):\n    if payload:\n        payload = capitalize(payload + \" \")\n    else:\n        return file\n    head, name = os.path.split(file)\n    r = \"(?<=(^(?:[a-zA-Z]+ *\\d+ +)))\"\n    if test(r, name):\n        return re.sub(r, payload, name)\n    return os.path.join(head, payload + name)\n\n"
  },
  {
    "name": "nodemon",
    "text": "def nodemon():\n    chdir(servedir)\n    s = nodedir + \"nodemon/bin/nodemon.js\"\n    runjs(s + \" \" + \"server.js\")\n\n"
  },
  {
    "name": "hrefRE",
    "text": "def hrefRE(s, e=0):\n    if e:\n        s += \"\\.\" + e\n    r = \"href=['\\\"]?\" + parens(s)\n    return r\n"
  },
  {
    "name": "foo",
    "text": "def foo():\n    chdir(dldir)\n    url = \"view-source:https://commons.wikimedia.org/wiki/Category:SVG_chess_pieces\"\n    r = hrefRE(\"[/\\w:_]+\", \"svg\")\n    domain = getDomainName(url)\n    m = unique(re.findall(r, request(url)))\n    links = map(m, lambda x: domain + x)\n    prompt(links)\n    for link in links:\n        name = tail(link)\n        try:\n            write(name, request(link))\n        except Exception as e:\n            print(\"error\", name)\n\n"
  },
  {
    "name": "rnc",
    "text": "def rnc(s):\n    month = datetime.now().strftime(\"%B\").lower()\n    s = addExtension(s, \"json\")\n    s = appendFileName(s, \".\" + month)\n    s = clipdir + tail(s)\n    cfile(clipfile, s)\n"
  },
  {
    "name": "clips",
    "text": "def clips():\n    files = ff(dir=jsondir, name=\"\\.clip\")\n    chooseAndOpen(files)\n"
  },
  {
    "name": "chooseAndOpen",
    "text": "def chooseAndOpen(files):\n    files = choose(files)\n    ofile(files)\n\n"
  },
  {
    "name": "activityLog",
    "text": "def activityLog(name=0, oncePerDay=0):\n    data = normRead(\"activities.log\")\n    date = datestamp()\n"
  },
  {
    "name": "toFactory",
    "text": "def toFactory(lang):\n    def runner(x):\n        return addExtension(x, lang)\n\n    return runner\n"
  },
  {
    "name": "gitCloner",
    "text": "def gitCloner(url):\n    chdir(jsdir)\n    name = tail(url)\n    response = SystemCommand(\"git clone\", url)\n    if response.error:\n        return\n\n    dir = normpath(jsdir, name)\n\n"
  },
  {
    "name": "temp",
    "text": "def temp(s):\n    write(\"temp.js\", s, open=1)\n"
  },
  {
    "name": "inferKeyFromText",
    "text": "def inferKeyFromText(s):\n    ref = {\n        \"pre\": 5,\n        \"li\": 50,\n    }\n\n    for k, v in ref.items():\n        c = len(re.findall(\"<\" + k + \"\\\\b\", s))\n        if c > v:\n            return k\n\n    raise Exception(\"no key found\")\n"
  },
  {
    "name": "htmlBodyParser",
    "text": "def htmlBodyParser(s):\n    import bs4\n    import html\n\n    body = bs4.BeautifulSoup(s, \"html.parser\").body\n    s = []\n    for item in body.find_all(recursive=False):\n        text = item.get_text()\n        s.append(text)\n    return s\n"
  },
  {
    "name": "liParser",
    "text": "def liParser(s):\n    import bs4\n    import html\n\n    s = bs4.BeautifulSoup(s, \"html.parser\").get_text()\n    s = html.unescape(s)\n    s = s.replace(r\"\\r\", \"\")\n    return s\n"
  },
  {
    "name": "getFirstWord",
    "text": "def getFirstWord(s):\n    return search(\"[a-zA-Z]+\", s)\n\n"
  },
  {
    "name": "foo",
    "text": "def foo(s):\n    return map(\n        s,\n        lambda x: [getFirstWord(tail(x)), x]\n        if getExtension(x)\n        else None,\n    )\n\n"
  },
  {
    "name": "foo",
    "text": "def foo(s):\n    return ref\n\n"
  },
  {
    "name": "olf",
    "text": "def olf():\n    ofile(glf())\n\n"
  },
  {
    "name": "findInDir",
    "text": "def findInDir(dir, key):\n    files = printdir(dir)\n    return find(files, testf(key))\n"
  },
  {
    "name": "xsplit",
    "text": "def xsplit(s, r=\" \"):\n    return split(s, r) if isString(s) else s\n"
  },
  {
    "name": "objectf",
    "text": "def objectf(s):\n    keys = xsplit(s)\n\n    def runner(o):\n        return {k: v for k, v in o.items() if k in keys}\n\n    return runner\n"
  },
  {
    "name": "doYesterday",
    "text": "def doYesterday():\n    files = unique(xsplit(textgetter(filelogfile), \"\\n+\"))\n"
  },
  {
    "name": "evaljs",
    "text": "def evaljs(s):\n    file = \"temp.js.txt\"\n    write(file, s)\n    response = SystemCommand(\"node\", file)\n\n    s = \"\"\"\n    console.log(2)\n    console.log(3)\n    console.log({a:1})\n    console.log(JSON.stringify([{a:2}], null, 4))\n\n\n    \"\"\"\n\n    s = \"\"\"\n    var x = require(\"@lezer/html/dist/index.cjs\")\n    t=`<body><p>hi</p></body>`\n    console.log(x.parser.parse(t))\n\n    \"\"\"\n    # evaljs(s)\n    # the response is not easy to manage\n    # creating a grammar file\n"
  },
  {
    "name": "ff",
    "text": "def ff(\n    dir=dir2023,\n    mode=0,\n    recursion=0,\n    once=0,\n    sort=0,\n    partition=0,\n    reverse=0,\n    recursive=0,\n    **kwargs,"
  },
  {
    "name": "openOrPrint",
    "text": "def openOrPrint(x, dir=0, r=\"index.cjs\"):\n    with CD(dir):\n        if isfile(x):\n            ofile(x)\n        elif isdir(x):\n            files = os.listdir(x)\n            target = find(files, r)\n            if target:\n                ofile(os.path.join(x, target))\n            else:\n                pprint(files)\n"
  },
  {
    "name": "makeEmojis",
    "text": "def makeEmojis():\n    items = read(dldir + \"emoji.json\").get(\"emojis\")\n    store = {}\n    # for k,v in items.items():\n    # store[k] = v.get('skins')[0].get('native')\n    # normWrite('emoji.json', store)\n    # https://api.github.com/emojis # has all of the emojis as png files which is different from utf...\n    # The above is to parse them out.\n    ################################################33\n\n    ################################################\n    url = \"https://openmoji.org/library\"\n    ta = TextAnalysis(url, \"imgsrc\")\n    normWrite(\"svg-emoji.json\", ta.results)\n    # build the links perhaps\n    ################################################\n"
  },
  {
    "name": "changeFileName2",
    "text": "def changeFileName2(file, dir=0, newName=0):\n    if not newName: newName = prompt(file, \"new name?\")\n    if not dir: dir = head(file)\n    return npath(dir, addExtension(newName, getExtension(file)))\n"
  },
  {
    "name": "gfn",
    "text": "def gfn():\n    def dateSearch(s):\n        return search(\"^______+ = \" + date, s, flags=re.M)\n\n    return getFunctionNames(\n        dateSearch(normRead(\"class.js\"))\n    )\n"
  },
  {
    "name": "abrev",
    "text": "def abrev(s):\n    r = \"\\W|(\\d)\"\n    items = filter(re.split(r, s))\n    return \"\".join(map(items, lambda x: x[0])).lower()\n"
  },
  {
    "name": "appendVariable",
    "text": "def appendVariable(x, name=\"temp\", outpath=0, str=0):\n    if isString(x) and isfile(x):\n        name = camelCase(removeExtension(x))\n        x = read(x)\n        outpath = dir2023 + \"variables.js\"\n\n    s = createVariable(name, x)\n    if str:\n        s = join(s)\n\n    append(outpath or currentFile(), s)\n"
  },
  {
    "name": "mostRecentDirectoryFiles",
    "text": "def mostRecentDirectoryFiles(key, e=\"pdf\", amount=10):\n    v = ff(dirgetter(key), sort=1, e=e)[-amount:]\n    os.system(\"clear\")\n    pprint(v)\n    return v\n"
  },
  {
    "name": "openLastGoogleDoc",
    "text": "def openLastGoogleDoc():\n    return openBrowser(read(\"google-doc-file.txt\").strip())\n"
  },
  {
    "name": "editMathcha",
    "text": "def editMathcha(f=\"\", fn=0):\n    text = fn(byteRead(f))\n    byteWrite(f, text)\n"
  },
  {
    "name": "byteRead",
    "text": "def byteRead(file):\n    with open(file, \"rb\") as f:\n        return f.read()\n"
  },
  {
    "name": "byteWrite",
    "text": "def byteWrite(file, value):\n    with open(file, \"wb\") as f:\n        f.write(value)\n        print(\"successfully wrote byte file!\", file)\n"
  },
  {
    "name": "mathchaReplace",
    "text": "def mathchaReplace(s):\n    prompt(s)\n    dict = {\n        #'ab': 'AB',\n        #'123': 'ONETWOTHREE',\n        #'sdf': 'SDF',\n        #'12': 'ONETWO',\n        #'abc': 'ABC',\n        \"QRKQRK\": \"booper\"\n    }\n    return byteReplace(s, dict, \"b\")\n"
  },
  {
    "name": "byteReplace",
    "text": "def byteReplace(s, dict, template=\"b\", flags=0):\n    regex = str.encode(ncg(template, dict))\n    print(regex)\n\n    def parser(x):\n        return str.encode(\n            dict.get(x.group(1).decode())\n            if x.groups()\n            else dict.get(x.group(0).decode())\n        )\n\n    return re.sub(regex, parser, s, flags=flags)\n\n"
  },
  {
    "name": "depfindFile",
    "text": "def depfindFile(root, name):\n    def runner(dir):\n        files = absdir(dir)\n        for f in files:\n            if isIgnoredFile(f):\n                continue\n            if isdir(f):\n                if test(name, tail(f), flags=re.I):\n                    print(\"found\")\n                    print(f)\n                    return f\n                else:\n                    print(f)\n                    runner(f)\n\n    return runner(root)\n"
  },
  {
    "name": "depfindDir",
    "text": "def depfindDir(root, name):\n    def runner(dir):\n        files = absdir(dir)\n        for f in files:\n            if isIgnoredFile(f):\n                continue\n            if isdir(f):\n                if test(name, tail(f), flags=re.I):\n                    print(\"found\")\n                    print(f)\n                    return f\n                else:\n                    print(f)\n                    runner(f)\n\n    return runner(root)\n"
  },
  {
    "name": "isVeryRecentFile",
    "text": "def isVeryRecentFile(f):\n    return isRecentFile(f, minutes=4000)\n"
  },
  {
    "name": "printIt",
    "text": "def printIt(fn):\n    def decorator(*args, **kwargs):\n        printIt = kwargs.pop(\"printIt\", None)\n        if printIt and isVeryRecentFile(clipfile):\n            print(\"returning very recent file\")\n            return read(clipfile)\n        value = fn(*args, **kwargs)\n        if printIt:\n            clip(value)\n        return value\n\n    return decorator\n\n"
  },
  {
    "name": "mdir",
    "text": "def mdir(f, t):\n    assert isdir(f)\n    a, b = re.sub(\"/ *$\", \"\", f).rsplit(\"/\", maxsplit=1)\n    dest = os.path.join(a, t)\n    prompt(\"moving\", \"from\", f, \"to\", dest)\n    shutil.move(f, dest)\n"
  },
  {
    "name": "getLastPdf",
    "text": "def getLastPdf(name=\"\"):\n    file = glf(name=name, e=\"pdf\")\n    return file\n\n"
  },
  {
    "name": "scrapeOrdering",
    "text": "def scrapeOrdering():\n    def f(s):\n        if s == \"x\" or not s or s == 0:\n            return 0\n        return int(s)\n\n    s = map(\n        split(\n            prompt(\"fix:order = G9, V2, V1, M2, M1\"), \" \"\n        ),\n        f,\n    )\n    return list(reversed(s))\n"
  },
  {
    "name": "choosefiles",
    "text": "def choosefiles(dir=dldir, key=\"\", groups=3):\n    files = choose(\n        map(\n            sorted(absdir(dir), key=mdate, reverse=True),\n            tail,\n        )\n    )\n    pprint(files)\n    return files\n\n"
  },
  {
    "name": "arrayToObject",
    "text": "def arrayToObject(a, f):\n    return {f(x): x for x in a}\n"
  },
  {
    "name": "mergeFirstPageOfEachFile",
    "text": "def mergeFirstPageOfEachFile(files):\n    f = lambda x: x.pages[0:1]\n    return pdfCreate(files, f)\n"
  },
  {
    "name": "getFilesRecursive",
    "text": "def getFilesRecursive(dir, recursion=0):\n    store = []\n    def runner(dir, depth=0):\n        files = absdir(dir)\n        for file in files:\n            if isIgnoredFile(tail(file)):\n                continue\n            elif isdir(file):\n                if recursion and depth == recursion:\n                    store.append(file)\n                else:\n                    runner(file, depth + 1)\n            else:\n                store.append(file)\n    runner(dir)\n    return store\n        "
  },
  {
    "name": "is_empty_dir",
    "text": "def is_empty_dir(dir):\n    def runner(dir):\n        for file in absdir(dir):\n            if isfile(file):\n                return False\n            elif not runner(file):\n                return False\n\n        return True\n\n    return runner(dir)\n"
  },
  {
    "name": "printDirRecursive",
    "text": "def printDirRecursive(dir, **kwargs):\n\n    checkpoint = checkpointf(**kwargs)\n\n    def runner(dir):\n        store = {}\n        children = []\n        store[\"dir\"] = dir\n        store[\"children\"] = children\n\n        files = absdir(dir)\n        for file in files:\n            name = tail(file)\n\n            if isIgnoredFile(name):\n                continue\n\n            elif isfile(file):\n                if checkpoint(file):\n                    children.append({\"file\": name})\n            elif isdir(file):\n                if is_empty_dir(file):\n                    print('is empty dir remove it?')\n                    rmdir(file)\n                else:\n                    children.append(runner(file))\n        return store\n\n    return runner(dir)\n"
  },
  {
    "name": "getLastNumber",
    "text": "def getLastNumber(s):\n    n = search(\"(\\d+) *(?:\\.\\w+)?$\", s)\n    return int(n)\n"
  },
  {
    "name": "pdfIt",
    "text": "def pdfIt(f):\n    name = changeExtension(f, \"pdf\")\n    mfile(f, name)\n"
  },
  {
    "name": "recentFileCache",
    "text": "def recentFileCache(fn):\n    def decorator(file, *args, **kwargs):\n        reset = kwargs.pop(\"reset\", None)\n        value = fn(file, *args, **kwargs)\n        recentfile = file + \".recent\"\n        if not reset and isRecentFile(recentfile, hours=2):\n            print(\"returning recent file\")\n            return parseJSON(read(recentfile))\n        else:\n            write(recentfile, value, open=1)\n            return value\n\n    return decorator\n"
  },
  {
    "name": "choosePDFS",
    "text": "def choosePDFS():\n    files = choose(mostRecentDirectoryFiles(dldir))\n    return files\n"
  },
  {
    "name": "oncef",
    "text": "def oncef():\n    go = True\n\n    def lamb(arg):\n        nonlocal go\n        if go and arg:\n            go = False\n            return True\n\n    return lamb\n"
  },
  {
    "name": "infof",
    "text": "def infof(f):\n    def lamb(file, *args):\n        value = f(file, *args)\n        return {\"file\": tail(file), \"value\": value}\n\n    return lamb\n"
  },
  {
    "name": "mapdir",
    "text": "def mapdir(files, dir):\n    return map(files, lambda x: normpath(dir, x))\n\n"
  },
  {
    "name": "objectClassName",
    "text": "def objectClassName(x):\n    s = str(type(x))\n    return search(\"<\\w+ '(?:__main__\\.|base\\.)?(\\w+)\", s)\n\n"
  },
  {
    "name": "toJSON",
    "text": "def toJSON(x):\n    name = objectClassName(x)\n    if test(\"Storage$\", name):\n        return x.store\n"
  },
  {
    "name": "getTime",
    "text": "def getTime():\n    return int(datetime.timestamp(datetime.now()))\n"
  },
  {
    "name": "getFileName",
    "text": "def getFileName(file):\n    return removeExtension(tail(file))\n"
  },
  {
    "name": "promptOutpath",
    "text": "def promptOutpath(s=0, fallback=\"\", fn=0):\n    out = s or prompt(\"outpath?\") or fallback\n    if fn:\n        out = fn(out)\n    return npath(dldir, out)\n\n"
  },
  {
    "name": "getNodeFile",
    "text": "def getNodeFile(name):\n    files = [\n        f\"{nodedir}{name}/dist/{name}.js\",\n        f\"{nodedir}{name}/dist/index.js\",\n    ]\n    file = find(files, isfile)\n    if file:\n        return file\n    else:\n        prompt(printDirRecursive(nodedir + name))\n\n"
  },
  {
    "name": "versionControl",
    "text": "def versionControl(f, revert=0):\n    f = normDirPath(f)\n    if not isfile(f):\n        return\n\n    original = f\n    got = 0\n\n    def increment(f, n=1):\n        nonlocal got\n        v = f + \".version\" + str(n)\n        if isfile(v):\n            if revert:\n                got = v\n                return\n            return increment(f, n + 1)\n        else:\n            return v\n\n    newFile = increment(npath(budir, original))\n    if got:\n        prompt(f\"revert {got} to {original} original?\")\n        backup(original)\n        shutil.copy(got, original)\n        print(\"successful reversion!\")\n    else:\n        prompt(f\"copy original to {newFile}?\")\n        shutil.copy(original, newFile)\n        print(\"successful control to budir!\")\n\n"
  },
  {
    "name": "pickFiles",
    "text": "def pickFiles(dir=\"dldir\"):\n    a = prompt(f\"choose files. directory = {dir}\")\n    dir = dirdict.get(dir, None)\n    assert dir\n    return mapdir(xsplit(a), dir)\n"
  },
  {
    "name": "STOP",
    "text": "def STOP():\n    raise Exception(\"STOP!!!\")\n"
  },
  {
    "name": "findCssFile",
    "text": "def findCssFile():\n    files = ff(dldir, css=1, text=\"mult\")\n\n"
  },
  {
    "name": "splitOnWord",
    "text": "def splitOnWord(s, word):\n    if test(\"\\\\b\" + word + \"\\\\b\", s):\n        s = getLast(re.split(word + \".*\", s))\n    return s\n\n"
  },
  {
    "name": "tabular",
    "text": "def tabular(data):\n    store = []\n    n = 25\n    s = (f\"{{: >{n}}}\" * len(data[0])).strip()\n    for row in data:\n        store.append(s.format(*row).strip())\n    return join(store)\n\n"
  },
  {
    "name": "foo",
    "text": "def foo():\n    store = {}\n    for a, b, c in partition(re.findall(\"\\S+\", clip()), 3):\n        store[a] = [b, c]\n    clip(oneLine(s))\n"
  },
  {
    "name": "oneLine",
    "text": "def oneLine(s):\n    s = json.dumps(s, indent=4)\n    s = re.sub(r'\": \\[\\s+', '\": [', s)\n    s = re.sub(r'\",\\s+', '\", ', s)\n    s = re.sub(r'\"\\s+\\]', '\"]', s)\n    return s\n\n"
  },
  {
    "name": "finfo",
    "text": "def finfo(file):\n    text = read(file)\n    return {\n        \"file\": tail(file),\n        \"lines\": lineCount(text),\n        \"size\": len(text),\n    }\n"
  },
  {
    "name": "trackProgress",
    "text": "def trackProgress():\n    # let text = search(r, lastQuarter(read(file)))\n    # let data = getBindingNames(text)\n    # let stamp = datestamp(date1) + ' - ' + datestamp(date2)\n    # let s = join(stamp, data)\n    # console.log(s)\n    normAppend(\"daily-code-progress.log\", s)\n"
  },
  {
    "name": "moveFilesToDriveTodoDir",
    "text": "def moveFilesToDriveTodoDir(dir):\n    s = mostRecentFileGroups(dldir, minutes=5)[0][1]\n    prompt(s, \"move these files?\")\n    dir = prompt(\"todo sub directory name?\").upper()\n    dir = tododir + dir\n    mkdir(dir)\n    map(s, mfile, dir)\n"
  },
  {
    "name": "imageToText",
    "text": "def imageToText(img):\n    # sudo apt install tesseract-ocr\n    # sudo apt install libtesseract-dev\n    # sudo apt install libleptonica-dev pkg-config\n    from PIL import Image\n    import pytesseract\n\n    return pytesseract.image_to_string(Image.open(img))\n\n    # OR\n\n    # sudo apt install tesseract-ocr\n    # sudo apt install libtesseract-dev\n    # sudo apt install tesseract-ocr-ita\n\n    # pip install pytesseract\n    # pip install opencv\n\n    import cv2\n    import argparse\n    import os\n    import pytesseract\n    from PIL import Image\n\n    def extract_text(image):\n        im = cv2.imread(image)\n        imgray = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)\n        ret, thresh1 = cv2.threshold(\n            imgray, 180, 255, cv2.THRESH_BINARY\n        )\n        filename = \"{}.png\".format(os.getpid())\n        cv2.imwrite(filename, thresh1)\n        img = Image.open(filename)\n        text = pytesseract.image_to_string(img)\n        return text\n"
  },
  {
    "name": "cleanup",
    "text": "def cleanup(dir, r):\n    with CD(dir):\n        for f in os.listdir(dir):\n            if test(r, f, flags=re.I):\n                rfile(f)\n\n"
  },
  {
    "name": "getWords",
    "text": "def getWords(s):\n    return re.findall(\"[a-zA-Z]{3,}\", s)\n"
  },
  {
    "name": "getLastWord",
    "text": "def getLastWord(s):\n    return getWords(s)[-1]\n"
  },
  {
    "name": "strType",
    "text": "def strType(x):\n    return getLastWord(str(type(x)))\n\n"
  },
  {
    "name": "download",
    "text": "def download(url, name=0):\n    if not name:\n        name = addExtension(\n            prompt(url, \"outpath name\"), \"pdf\"\n        )\n    write(dldir + name, request(url))\n"
  },
  {
    "name": "stringInfo",
    "text": "def stringInfo(*args):\n    items = partition(args)\n    s = \"\"\n    for a, b in items:\n        s += a + \": \" + str(b) + \"\\n\"\n    return s.strip()\n"
  },
  {
    "name": "backup1206",
    "text": "def backup1206(*files):\n    date = datestamp()\n    name = \"CURRENT\"\n    dir = budir + name\n    files = list(files)\n    files.append(\"/home/kdog3682/VIM/functions.vim\")\n    files.append(\"/home/kdog3682/VIM/variables.vim\")\n    files.append(\"/home/kdog3682/.vimrc\")\n    files = unique(files)\n    cfiles(files, dir)\n\n    info = stringInfo(\n        \"date\",\n        date,\n        \"directory\",\n        dir,\n        \"numFiles\",\n        len(files),\n    )\n    payload = join(info, files, linebreak)\n    normAppend(\"files.log\", payload)\n"
  },
  {
    "name": "scrapeHTML",
    "text": "def scrapeHTML(url):\n    s = join(\n        map(\n            re.findall(\n                env.scrapeRef.get(\"pre\"), request(url)\n            ),\n            liParser,\n        )\n    )\n    normWrite(\"scrape.html\", s)\n"
  },
  {
    "name": "scrape",
    "text": "def scrape(url, key=0):\n    prompt(url, key)\n    TextAnalysis(url, key)\n"
  },
  {
    "name": "prePostParser",
    "text": "def prePostParser(items):\n    s = filter(items, \"^\\s*<\")\n    if len(s):\n        return normWrite(\n            \"scrape.html\", chooseIndex(s), open=1\n        )\n    else:\n        print(s)\n        print(\"not done yet\")\n"
  },
  {
    "name": "chooseIndex",
    "text": "def chooseIndex(items):\n    i = len(items)\n    if i == 1:\n        return items[0]\n    a = prompt(\n        f\"There are {i} items. Choose 1-based indexes.\"\n    )\n    return smallify([items[int(i) - 1] for i in a])\n"
  },
  {
    "name": "dirName",
    "text": "def dirName(s):\n    return os.path.split(re.sub(\"/*$\", \"\", s))[1]\n"
  },
  {
    "name": "zipToDir",
    "text": "def zipToDir(dir):\n    # clip(getfiles(dir, recursive=1))\n    # return\n\n    name = dirName(dir)\n    r = re.sub(\"\\W\", \".*?\", name)\n    file = glf()\n\n    assert itest(r, file)\n    assert getExtension(file) == \"zip\"\n\n    mkdir(dir)\n    unzip(file, dir)\n\n    childDir = absdir(dir)[0]\n    files = absdir(childDir)\n    for file in files:\n        mfile(file, dir)\n    rmdir(childDir)\n    pprint(os.listdir(dir))\n\n"
  },
  {
    "name": "rpw",
    "text": "def rpw(file, f):\n    normWrite(file, f(normRead(file)))\n\n"
  },
  {
    "name": "foo",
    "text": "def foo():\n    dir = swiftdir\n    for item in filter(absdir(dir), isdir):\n        files = absdir(item)\n        for file in files:\n            mfile(file, swiftdir)\n\n"
  },
  {
    "name": "craig",
    "text": "def craig():\n    from craigslist import CraigslistJobs\n\n    # from craigslist import CraigslistServices\n    # print(dir(CraigslistServices))\n    # return\n\n    x = CraigslistJobs.show_categories()\n    print(x)\n    return\n\n    kwargs = {\n        \"site\": \"newyork\",\n    }\n\n    jobs = CraigslistJobs(**kwargs)\n    for result in jobs.get_results():\n        print(result)\n"
  },
  {
    "name": "rfiles",
    "text": "def rfiles(files):\n    map(files, rfile)\n\n"
  },
  {
    "name": "undo",
    "text": "def undo(dir=trashdir):\n    mfiles(ff(dir, minutes=10)[-8:], teachdir)\n"
  },
  {
    "name": "mover",
    "text": "def mover(extensions, dir):\n    inpath = pydir\n    c = checkpointf(\n        extensions=xsplit(extensions), deleteIt=1\n    )\n    files = filter(absdir(inpath), c)\n    dir = rootdir + dir.upper()\n    mkdir(dir)\n    mfiles(files, dir)\n"
  },
  {
    "name": "removeCache",
    "text": "def removeCache():\n    rmdir(pydir + \"__pycache__\", force=1)\n\n"
  },
  {
    "name": "odir",
    "text": "def odir(dir):\n    ofile(absdir(dir))\n"
  },
  {
    "name": "backupDirectories",
    "text": "def backupDirectories(directories):\n    import shutil\n\n    mkdir(budir + datestamp())\n    for dir in toArray(directories):\n        outpath = os.path.join(\n            budir, datestamp(), dirName(dir)\n        )\n        print(\"making zip directory\", dir)\n        shutil.make_archive(outpath, \"zip\", dir)\n"
  },
  {
    "name": "zipCheck",
    "text": "def zipCheck(outpath=0, file=0):\n    # outpath = budir / datestamp / SERVER.zip / myFile.js\n    # pprint(zipCheck(s, file='token.json'))\n\n    import zipfile\n    import io\n\n    with zipfile.ZipFile(outpath, \"r\") as z:\n        if file:\n            file = z.open(file)\n            with io.TextIOWrapper(\n                file, encoding=\"utf-8\"\n            ) as f:\n                return parseJSON(f.read())\n        else:\n            return map(z.filelist, lambda x: x.filename)\n\n"
  },
  {
    "name": "testsuite",
    "text": "def testsuite(items):\n    return map(items, lambda x: [x, eval(x)])\n\n"
  },
  {
    "name": "choosepdf",
    "text": "def choosepdf():\n    ofile(choose(mostRecent(dldir, 10, reverse=1)))\n"
  },
  {
    "name": "seeRecent",
    "text": "def seeRecent():\n    e = prompt(\"extension?\")\n    kwargs = dict({\"dir\": dirdict.get(e), e: True})\n    ff(**kwargs)\n\n"
  },
  {
    "name": "n2char",
    "text": "def n2char(n):\n    return chr(n + 97)\n\n"
  },
  {
    "name": "create_pdfdict_from_pdf_files",
    "text": "def create_pdfdict_from_pdf_files():\n    files = ff(pdfdir, name=\"^G\\d|math\")\n    d = {\n        n2char(i) + n2char(i): f\n        for i, f in enumerate(files)\n    }\n    appendVariable(d, outpath=\"pdf.py\", name=\"pdfdict\")\n\n"
  },
  {
    "name": "normFileToDir",
    "text": "def normFileToDir(file, name=0):\n    if not name:\n        name = prompt(file, \"name?\")\n    e = getExtension(file)\n    return dirdict.get(e) + addExtension(name, e)\n"
  },
  {
    "name": "move_last_file_and_name_it",
    "text": "def move_last_file_and_name_it():\n    file = glf()\n    out = normFileToDir(file)\n    prompt(\"is this the correct outpath?\", out)\n    mfile(file, out)\n"
  },
  {
    "name": "promptSplit",
    "text": "def promptSplit(*args):\n    r = \"\\||\\.\\.|\\\\\\\\|  +\"\n    a = prompt(*args)\n    return re.split(r, a.strip())\n\n"
  },
  {
    "name": "saveToDrive",
    "text": "def saveToDrive(file):\n    cfile(file, tempbudir)\n\n"
  },
  {
    "name": "keepOrDelete",
    "text": "def keepOrDelete(file):\n    a = prompt(file)\n    if a == \"d\":\n        rfile(file)\n    elif a == \"k\":\n        e = getExtension(file)\n        if e == \"zip\":\n            unzip(file, to=unzipdir)\n\n"
  },
  {
    "name": "cleanupRawText",
    "text": "def cleanupRawText(s):\n    def f(x):\n        n = x.group(0)\n        if n == \"”\":\n            return '\"'\n        if n == \"“\":\n            return '\"'\n        if n == \"’\":\n            return \"'\"\n        raise Exception(x)\n\n    s = re.sub(\"\\t| {2,}\", \" \", s)\n    s = re.sub(\"[”’“]\", f, s)\n    return s.strip()\n"
  },
  {
    "name": "normMove",
    "text": "def normMove(src, to):\n    outpath = dirFromFile(to) + tail(to)\n    mfile(src, outpath)\n\n"
  },
  {
    "name": "backupMostPopular",
    "text": "def backupMostPopular():\n    files = [\n        \"/home/kdog3682/CWF/public/class.js\",\n        \"/home/kdog3682/PYTHON/pdf.py\",\n        \"/home/kdog3682/VIM/functions.vim\",\n        \"/home/kdog3682/VIM/variables.vim\",\n        \"/home/kdog3682/CWF/public/print.js\",\n    ]\n    cfiles(files, bucurdir)\n"
  },
  {
    "name": "fixWrongPaths",
    "text": "def fixWrongPaths():\n    baseFiles = map(files, lambda x: normpath(drivedir, x))\n    for i, baseFile in enumerate(baseFiles):\n        file = files[i]\n        outpath = normpath(bucurdir, baseFile)\n        cfile(baseFile, outpath)\n        mfile(baseFile, file)\n\n"
  },
  {
    "name": "writeGitIgnore",
    "text": "def writeGitIgnore(dir2023):\n    s = \"\"\"\n        *.zip\n        *.7z\n        *.rar\n        *.tar.gz\n        *.pdf\n        .DS_Store\n        node_modules\n        __pycache__\n\n    \"\"\"\n    write(dir + \".gitignore\", smartDedent(s), open=1)\n\n"
  },
  {
    "name": "gitRemote",
    "text": "def gitRemote(repo, username=\"kdog3682\", message=0):\n    chdir(rootdir + repo)\n    if not isdir(\".git\"):\n        response = SystemCommand(\"git init\")\n\n    # for changing from master to main\n    s = \"git branch -m master main\"\n    s = \"git push -u origin main\"\n    s = \"git push origin --delete master\"\n    #############################\n\n    # s = 'git diff --name-only --cached'\n    # s = 'git status'\n    # s = 'git diff --names-only'\n    # s = 'git diff --staged'\n    # s = 'git add .'\n    # response = SystemCommand(s)\n    # return\n    # s = 'git log'\n    # s = 'git push -u origin main'\n    # s = 'git remote -v'\n    # s = 'ssh -vvv git@github.com'\n    # it creates a prompt which may ask something\n\n    mainCommand = f\"git add .\\ngit commit -a -m \\\"{message or 'pythonTest'}\\\"\\ngit push\"\n    response = SystemCommand(mainCommand)\n\n    if response.error == \"sdfgsdfg\":\n\n        url = f\"git@github.com:{username}/{repo}.git\"\n        s = f\"git remote add origin {url}\"\n        response = SystemCommand(s)\n\n        if response.error == \"remote origin already exists\":\n            s = f\"git remote set-url origin {url}\"\n            response = SystemCommand(s)\n\n    elif response.error == \"sdfgsdfg\":\n        prompt(\"Creating ssh key gen, press Y for Yes\")\n        s = 'ssh-keygen -t rsa -C \"kdog3682@gmail.com\"'\n        response = SystemCommand(s)\n        ofile(sshfile)\n        prompt(\"copy the opened file to github\")\n        response = SystemCommand(mainCommand)\n\n    return\n"
  },
  {
    "name": "changelog",
    "text": "def changelog(s=0, mode=\"add\"):\n    changelogfile = \"/home/kdog3682/2023/changelog.md\"\n    if not s:\n        s = hms()\n    payload = \"+ \" + s\n    append(changelogfile, payload)\n"
  },
  {
    "name": "writeNpmInit",
    "text": "def writeNpmInit(name):\n\n    data = {\n        \"name\": name,\n        \"version\": \"1.0.0\",\n        \"type\": \"module\",\n        \"description\": \"\",\n        \"main\": \"index.js\",\n        \"scripts\": {\n            \"test\": 'echo \"Error: no test specified\" && exit 1'\n        },\n        \"repository\": {\n            \"type\": \"git\",\n            \"url\": f\"git+https://github.com/kdog3682/{name}.git\",\n        },\n        \"author\": \"Kevin Lee\",\n        \"license\": \"ISC\",\n        \"homepage\": \"https://github.com/kdog3682/2023#changelog\",\n    }\n    write(outpath, data)\n"
  },
  {
    "name": "gitUrl",
    "text": "def gitUrl(file, repo, user=\"kdog3682\"):\n    url = \"https://raw.githubusercontent.com/$1/$2/main/$3\"\n    url = templater(url, [user, repo, file])\n    print(url)\n    return url\n\n"
  },
  {
    "name": "npmInstall",
    "text": "def npmInstall(s):\n    dev = test(\"cors|nodemon|jest|grunt|uglify\", s, flags=re.I)\n    SystemCommand(\n        \"npm i \" + s + (\" --save-dev\" if dev else \"\")\n    )\n\n"
  },
  {
    "name": "text",
    "text": "def text():\n    return normRead(\"scrape.txt\")\n"
  },
  {
    "name": "foo",
    "text": "def foo():\n    a = linegetter(text(), fn=\"(^[a-z]\\w+)\\(\", u=1)\n    b = linegetter(text(), fn=\"^[A-Z][a-zA-Z]+$\", u=1)\n    data = {\n        \"builtInFunctions\": a,\n        \"builtInClasses\": b,\n    }\n"
  },
  {
    "name": "normClear",
    "text": "def normClear(file):\n    file = normDirPath(file)\n    print(file)\n    clear(file)\n\n"
  },
  {
    "name": "publishScratchpad",
    "text": "def publishScratchpad():\n    with CD(dir2023):\n        outpath = addExtension(\n            prompt(\n                \"publishing scratchpad. choose outpath file name: \"\n            ),\n            \"js\",\n        )\n        mfile(\"scratchpad.js\", outpath)\n"
  },
  {
    "name": "getLinks",
    "text": "def getLinks(folders, q):\n    store = []\n    for path in toArray(folders):\n        matches = ff(path, name=q)\n        if matches:\n            store.extend(matches)\n\n    files = choose(store)\n    map(files, revert, dir=jsdir, increment=1, vim=1)\n"
  },
  {
    "name": "incrementName",
    "text": "def incrementName(file):\n    count = 1\n    a, b = mget(\"(?:\\.\\w+)+$\", file, mode=str)\n    while isfile(file):\n        count += 1\n        file = a + str(count) + b\n    return file\n"
  },
  {
    "name": "appendVim",
    "text": "def appendVim(type, arg):\n    b = arg\n    s = removeExtension(tail(b))\n    a = abrev(s)\n    s = f'let g:{type}[\"{a}\"] = \"{b}\"'\n    append(\"/home/kdog3682/.vimrc\", s)\n\n"
  },
  {
    "name": "removeFileParens",
    "text": "def removeFileParens(s):\n    return re.sub(\" *\\(.*?\\) *\", \"\", s)\n"
  },
  {
    "name": "overrideFile",
    "text": "def overrideFile():\n    f = glf()\n    mfile(f, removeFileParens(f))\n\n"
  },
  {
    "name": "isEmptyDir",
    "text": "def isEmptyDir(dir):\n    return isdir(dir) and not os.listdir(dir)\n"
  },
  {
    "name": "renameFiles",
    "text": "def renameFiles():\n    for file in ff(dldir, reverse=1):\n        if isEmptyDir(file):\n            rfile(file)\n            continue\n\n        a = prompt(file)\n        if a == \"d\":\n            rfile(file)\n        elif a == \"c\":\n            continue\n        elif a:\n            out = npath(dldir, addExtension(a, \"pdf\"))\n            mfile(file, out)\n        else:\n            break\n\n"
  },
  {
    "name": "fixUrls",
    "text": "def fixUrls(source, links):\n    url = fixUrl(source)\n    base = url\n    first = links[0]\n    if not isWebsite(os.path.join(url, first)):\n        url = head(url)\n        if not isWebsite(os.path.join(url, first)):\n            print(\"ERROR\")\n        else:\n            base = url\n\n    return map(links, lambda x: os.path.join(base, x))\n"
  },
  {
    "name": "downloadPDF",
    "text": "def downloadPDF(url, name=0):\n    if not name:\n        name = addExtension(\n            prompt(url, \"outpath name\"), \"pdf\"\n        )\n    outpath = npath(dldir, name)\n\n    from requests import get\n\n    r = get(url, stream=True)\n    chunkSize = 10000\n    with open(outpath, \"wb\") as fd:\n        for chunk in r.iter_content(chunkSize):\n            fd.write(chunk)\n\n    ofile(outpath)\n    return outpath\n"
  },
  {
    "name": "scrapeLinks",
    "text": "def scrapeLinks(source=0):\n    #write('request.temp.txt', request('https://www.nysedregents.org/ei/ei-math.html'))\n    #return\n    source = \"https://www.nysedregents.org/ei/\"\n    #srequest(source)\n    items = filter(\n        re.findall(\n            env.scrapeRef.get(\"href\"),\n            read(\"/home/kdog3682/2023/request.temp.txt\"),\n        ),\n        \"released-items\",\n    )\n    items = choose(items)\n    items = fixUrls(source, items)\n\n    def downloader(url):\n        #m = search(\"g\\d\", url)\n        #name = f\"{m}cw.pdf\"\n        name = tail(url)\n        return downloadPDF(url, name)\n\n    return map(items, downloader)\n"
  },
  {
    "name": "reverse",
    "text": "def reverse(x):\n    if isObject(x):\n        return {b:a for a,b in x.items()}\n    return list(reversed(x))\n\n"
  },
  {
    "name": "to2023",
    "text": "def to2023(*files):\n    def runner(file):\n        a = jsdir + file\n        b = dir2023 + file\n        if not isfile(a):\n            a = dldir + file\n        assert isfile(a)\n        cfile(a, b)\n\n    map(files, runner)\n\n"
  },
  {
    "name": "tagdir",
    "text": "def tagdir(dir, history={}):\n    items = {}\n    store = {\"dir\": dir, \"items\": items}\n    files = absdir(dir)\n    aliases = {\n        \".\": \"private\",\n        \"l\": \"library\",\n        \"d\": \"delete\",\n        \"m\": \"main\",\n        \"i\": \"ignore\",\n    }\n    for file in files:\n        name = tail(file)\n        value = history.get(name)\n        if value == None:\n            a = prompt(fileInfo(file))\n            value = history.get(a, a)\n\n        items[name] = value\n    appendVariable(store)\n"
  },
  {
    "name": "npmResetNode",
    "text": "def npmResetNode():\n\n    s = \"\"\"\n        npm install -g npm stable\n        npm install -g node or npm install -g n\n        node --version or node -v\n    \"\"\"\n\n    SystemCommand(\n        \"\"\"\n        npm cache clean -f\n        npm install -g n\n        n stable\n        npm version\n    \"\"\"\n    )\n"
  },
  {
    "name": "readjs",
    "text": "def readjs(*args):\n    dir = jsdir\n\n    def runner(s):\n        file = dir + addExtension(s, \"js\")\n        if isfile(file):\n            return file\n\n    return filter(map(args, runner))\n\n"
  },
  {
    "name": "cleandir",
    "text": "def cleandir(dir):\n    print('cleaning the dir', dir)\n    files = filter(absdir(dir), alwaysDelete)\n    prompt(files, message='deleting these files')\n    map(files, rfile)\n"
  },
  {
    "name": "renameLastFile",
    "text": "def renameLastFile(file = 'Extra Worksheet'):\n    mfile(glf(), npath(dldir, addExtension(file, 'pdf')))\n"
  },
  {
    "name": "resumeIt",
    "text": "def resumeIt():\n    renameLastFile('Kevin Lee Resume')\n    \n"
  },
  {
    "name": "uploadDirectoryToExcel",
    "text": "def uploadDirectoryToExcel(dir='dldir'):\n    files = absdir(dirdict[dir])\n    data = map(files, finfo)\n\n    googleAction({\n        'clear': 1,\n        'type': 'gse',\n        'data': data,\n        'alignLeft': 1,\n        'headers': 'name date size comments',\n        'open': 1,\n        'key': dir,\n    })\n"
  },
  {
    "name": "finfo",
    "text": "def finfo(f):\n    if isfile(f):\n        name = tail(f)\n        date = datestamp(f)\n        size = fsize(f)\n        return [name, date, size]\n    else:\n        return [name]\n"
  },
  {
    "name": "downloadDirectoryFromExcel",
    "text": "def downloadDirectoryFromExcel(dir):\n    data = googleAction({\n        'type': 'gse',\n        'get': 1,\n        'key': dir,\n    })\n"
  },
  {
    "name": "isGunk",
    "text": "def isGunk(file):\n    return getExtension(file) in gunkExtensions\n"
  },
  {
    "name": "makeRootDir",
    "text": "def makeRootDir(s):\n    mkdir(rootdir + s.upper())\n"
  },
  {
    "name": "antichoose",
    "text": "def antichoose(items):\n    a = prompt2(items)\n    indexes = [int(n) - 1 for n in a.strip().split(\" \")]\n\n    store = []\n    for i, item in enumerate(items):\n        if i not in indexes:\n            store.append(item)\n\n    return store\n"
  },
  {
    "name": "seeVersions",
    "text": "def seeVersions():\n    SystemCommand(\"\"\"\n        npm -v\n        node -v\n    \"\"\")\n"
  },
  {
    "name": "renameLastFile",
    "text": "def renameLastFile():\n    f = glf()\n    mfile(f, changeFileName(f, prompt(f)))\n"
  },
  {
    "name": "pickFileFromDir",
    "text": "def pickFileFromDir(dir=dldir):\n    ofile(choose(absdir(dir)))\n"
  },
  {
    "name": "sub",
    "text": "def sub(s, r, f, **kwargs):\n    def g(x):\n        if isString(f):\n            return f\n        if x.groups():\n            return f(*x.groups())\n        else:\n            return f(x.group())\n    return re.sub(r, g, s, **kwargs)\n"
  },
  {
    "name": "memoize",
    "text": "def memoize(fn):\n  store = {}\n  def wrapper(*args):\n    if args in store:\n      return store[args]\n    else:\n      value = fn(*args)\n      store[args] = value\n      return value\n  return wrapper\n"
  },
  {
    "name": "dollarPrompt",
    "text": "def dollarPrompt(x):\n    if isArray(x):\n\n        os.system(\"clear\")\n        number(x)\n        s = input('choose 1-based indexed\\n')\n        a, b = splitonce(s, ' ')\n        item = x[int(a) - 1]\n    elif isObject(x):\n        item = choose(list(x.values()), mode=1)\n    else:\n        item = x\n\n    @memoize\n    def f(x):\n        return prompt(item=item, fallback=x) or x\n\n    @memoize\n    def g(x):\n        return prompt(item, 'input:')\n\n    r1 = '\\$([a-zA-Z]\\w*)'\n    r2 = '\\$(\\d+)'\n    n = 0\n    r0 = '\\$1'\n    if b and test(r0, item):\n        item = sub(item, r0, b)\n        n += 1\n\n    while True:\n        if test(r1, item):\n            item = sub(item, r1, f, count=1)\n        else:\n            break\n        \n    while True:\n        n += 1\n        r = '\\$' + str(n)\n        if test(r, item):\n            item = sub(item, r, g)\n        else:\n            break\n\n    return item\n\n"
  },
  {
    "name": "getNameArgsKwargs",
    "text": "def getNameArgsKwargs(s):\n    if test('^\\w+$', s):\n        return [s, [], {}]\n    name, s = search('(\\w+)\\((.*?)\\)', s)\n    s, kwargs = mget('(\\w+) *= *([^\\s,]+)', s)\n    args = split(s, ', *| +')\n    return name, args, kwargs\n"
  },
  {
    "name": "stringCall",
    "text": "def stringCall(fn, *args):\n    #prompt(args)\n    items = map(args, dumpJson)\n    #prompt(items)\n    argString = ', '.join(items)\n    return f\"{fn}({argString})\"\n"
  },
  {
    "name": "dprint",
    "text": "def dprint(*variables, **kwargs):\n    import inspect\n    store = ['DPRINT:']\n\n    for v in variables:\n        vars = inspect.currentframe().f_back.f_locals.items()\n        name = [v_name for v_name, v_val in vars if v_val is v][0]\n        store.append([name, v])\n\n    for a,b in kwargs.items():\n        store.append([a, b])\n\n    pprint(store)\n\n\n"
  },
  {
    "name": "newdir",
    "text": "def newdir():\n    dir = dir2023 + input('new dir name:')\n    assert not isdir(dir)\n    mkdir(dir)\n\n\n\n"
  },
  {
    "name": "arrToDict",
    "text": "def arrToDict(a):\n    return {i + 1: v for i, v in enumerate(a)}\n"
  },
  {
    "name": "getNumbers",
    "text": "def getNumbers(s):\n    return map(re.findall('\\d+', s), int)\n"
  },
  {
    "name": "getUntil",
    "text": "def getUntil(items, checkpoint):\n    store = []\n    for item in items:\n        if checkpoint(item):\n            store.append(item)\n        else:\n            break\n    return store\n"
  },
  {
    "name": "watchMovie",
    "text": "def watchMovie(s):\n    s = s.replace(' ', '+')\n    f = f\"https://ww1.123moviesfree.net/search-query2/?q={s}\"\n    ofile(f)\n\n"
  },
  {
    "name": "renameLocalClipFile",
    "text": "def renameLocalClipFile(a=0):\n    name = a or prompt('new name for clip file?')\n    mfile('clip.js', addExtension(name, 'js'))"
  },
  {
    "name": "check",
    "text": "def check(x):\n    prompt(x)\n    return x\n"
  },
  {
    "name": "revertFromTrash",
    "text": "def revertFromTrash():\n    file = glf(trashdir)\n    ofile(file)\n    print(file)\n    mfile(file, dldir)"
  },
  {
    "name": "makeGitIgnore",
    "text": "def makeGitIgnore():\n    s = \"\"\"\n        */*\n        .*\n        env.js\n        env.py\n        env*\n    \"\"\"\n    write(\".gitignore\", smartDedent(s))\n\n"
  },
  {
    "name": "grabGitFiles",
    "text": "def grabGitFiles():\n    files = ['codemirror.js', 'codemirror.css', 'cm.js', 'cm.css']\n    base = 'https://github.com/kdog3682/codemirror/blob/main/'\n    files = map(files, lambda x: npath(base, x))\n    map(files, getGithubFile)\n"
  },
  {
    "name": "getGithubFile",
    "text": "def getGithubFile(a):\n    def githubUrlToUserContent(s):\n        return s.replace(\"blob/\", \"\").replace(\n            \"github.com\", \"raw.githubusercontent.com\"\n        )\n\n    a = githubUrlToUserContent(a)\n    name = tail(a)\n    s = request(a)\n    if not s:\n        dprint(name)\n    write(name, s, open=1)\n"
  },
  {
    "name": "gitInit",
    "text": "def gitInit(dir=0, user=env.user):\n    if not dir:\n        #dir = prompt('make a dir inside of dir2023')\n        dir = 'code-editor'\n        if not isdir(dir):\n            dir = npath(dir2023, dir)\n            #mkdir(dir)\n            #makeGitIgnore()\n\n        #chdir(dir)\n        #grabGitFiles()\n\n    assert isdir(dir)\n    repo = tail(dir)\n    chdir(dir)\n    from githubscript import Github\n    Github(key=user, repo=repo)\n\n    command = f\"\"\"\n        git init\n        git add .\n        git commit -m \"push everything\"\n        git remote add origin git@github.com:{user}/{repo}\n        git push -u origin master \n    \"\"\"\n\n    res = SystemCommand(command, dir=dir)\n    if res.success:\n        ofile(f\"https://github.com/{user}/{repo}\")\n"
  },
  {
    "name": "removeLastFile",
    "text": "def removeLastFile(dir=dldir):\n    file = glf(dirgetter(dir))\n    prompt('is this file correct?', file)\n    rfile(file)\n    \n"
  },
  {
    "name": "removeDateString",
    "text": "def removeDateString(s):\n    return re.sub(' *\\d+[-/]\\d+[-/]\\d+ *$', '', s)\n"
  },
  {
    "name": "dsearch",
    "text": "def dsearch(s, dict, template=''):\n    r = reWrap(dict, template)\n    m = search(r, s)\n    return dict[m] if m else None\n"
  },
  {
    "name": "resetGit",
    "text": "def resetGit():\n    cmd = \"\"\"\n        git rm -r --cached .;\n        git add .;\n        git commit -m \"Untracked files issue resolved to fix .gitignore\";\n        git push;\n        # holy shit this was scary.\n        # I thought it deleted everything, but it didnt.\n        # Thank goodness. It merely clears everything out.\n    \"\"\"\n    SystemCommand(md)\n"
  },
  {
    "name": "readLastReversion",
    "text": "def readLastReversion():\n    f = glf(budir)\n    print(fileInfo(f))\n"
  },
  {
    "name": "double",
    "text": "def double(items, f):\n    return [(item, f(item)) for item in items]\n"
  },
  {
    "name": "isf",
    "text": "def isf(f):\n    extensions = ['json', 'pdf']\n    for e in extensions:\n        name = addExtension(f, e)\n        dirs = [dldir, dirFromFile(name)]\n        for dir in dirs:\n            path = npath(dir, name)\n            if isfile(path):\n                ofile(path)\n                return path\n"
  },
  {
    "name": "normMove",
    "text": "def normMove(file):\n    mfile(normDirPath(file), currentdir)\n    "
  },
  {
    "name": "mclean",
    "text": "def mclean(file):\n    r = f\"^{jspy(file, '//')} *(.*)\\n*\"\n\n    def runner(s):\n       s, items = mget(r, s, flags=re.M, mode=list)\n       prompt(s)\n       if not items:\n           return \n\n       logger(items=items, file=file)\n       return s\n\n    rpw(file, runner)\n\n"
  },
  {
    "name": "gitUrl",
    "text": "def gitUrl(dir):\n    repo = tail(dir)\n    return f\"https://github.com/{env.githubUser}/{repo}\"\n"
  },
  {
    "name": "pipInstall",
    "text": "def pipInstall(s):\n    cmd = 'abc ' + s\n    print(cmd)\n"
  },
  {
    "name": "removeComments",
    "text": "def removeComments(s):\n    return re.sub('^[#/].+\\n*', '', s, flags=re.M)\n"
  },
  {
    "name": "createdir",
    "text": "def createdir(dir, files, mode='copy'):\n   name = dir\n   if isdir(dir):\n       name = os.path.join(dir, datestamp())\n   mkdir(name) \n   if mode == 'move':\n        map(files, mfile, name)\n   elif mode == 'move':\n        map(files, cfile, name)\n   printdir(name)\n"
  },
  {
    "name": "renameColoringFilesInDir",
    "text": "def renameColoringFilesInDir():\n    #data = map(absdir(colordir + datestamp()), lambda x: mfile(x, re.sub(' colo.+?(?=\\.pdf)', '', x, flags=re.I)))\n    printdir(colordir + datestamp())\n"
  },
  {
    "name": "renameFile",
    "text": "def renameFile(input, output):\n    outpath = changeFileName(input, output)\n    mfile(input, outpath)\n    ofile(outpath)\n"
  },
  {
    "name": "numbered",
    "text": "def numbered(items, title=''):\n    if title: title = '  ' + title + '\\n'\n    s = '\\n' + title + '\\n'\n    for i, item in enumerate(items):\n        spaces = '  ' if i < 9 else ' '\n        s += '  ' + str(i + 1) + '.' + spaces + stringify(item) + '\\n'\n    return s\n"
  },
  {
    "name": "snapshotOfDirectory",
    "text": "def snapshotOfDirectory(dir=dldir, amount=10):\n   os.chdir(dir)\n   items = sorted(os.listdir(dir), key=mdate, reverse=True)[0:amount]\n   return numbered(items, title='FILES IN: ' + dir)\n"
  },
  {
    "name": "dlf",
    "text": "def dlf():\n    rfile(glf())\n"
  },
  {
    "name": "splitInHalf",
    "text": "def splitInHalf(items):\n    import math\n    halfPoint = math.floor(len(items) / 2)\n    return items[0:halfPoint], items[halfPoint:]\n"
  },
  {
    "name": "deprecateFile",
    "text": "def deprecateFile(file):\n    newFile = changeExtension(file, 'deprecated.' + getExtension(file))\n    prompt(file, newFile)\n    mfile(file, newFile)\n"
  },
  {
    "name": "ffApp",
    "text": "def ffApp(s):\n    ff(**createKwargs(s))\n"
  },
  {
    "name": "configString",
    "text": "def configString(kwargs):\n    s = ''\n    for k, v in kwargs.items():\n        s += k + ' = ' + v + ' '\n    return s.strip()\n"
  },
  {
    "name": "JavascriptAppCommand",
    "text": "def JavascriptAppCommand(key, arg='', **kwargs):\n    result = SystemCommand('node', 'App.js', key, arg, **kwargs, python=True)\n    if not result:\n        return \n    if not result.success:\n        pprint('error')\n        return \n\n    delimiter = '::CLEARING::'\n    s = re.split(delimiter, result.success, maxsplit=1)[1]\n    data = parseJSON(s)\n    return data\n"
  },
  {
    "name": "choose2",
    "text": "def choose2(items, display=0, anti=0):\n    if isObject(items[0]) and not display:\n        if items[0].get('title'): display = lambda x: x.get('title')\n        elif items[0].get('foo'): display = lambda x: x.get('foo')\n        elif items[0].get('subject'): display = lambda x: x.get('subject')\n\n    if anti:\n        pprint('choosing which items to keep. The rest will be deleted')\n    presentation = map(items, display) if display else items\n    print(numbered(presentation))\n    indexes = rangeFromString(input())\n    if anti:\n        store = [el for i, el in enumerate(items) if i not in indexes]\n    else:\n        store = [el for i, el in enumerate(items) if i in indexes]\n    prompt(store)\n    return store\n        "
  },
  {
    "name": "deleteKey",
    "text": "def deleteKey(item, key):\n    if isObject(item):\n        item.pop(key)\n    return item\n"
  },
  {
    "name": "getYearNumber",
    "text": "def getYearNumber():\n    return datetime.now().year"
  },
  {
    "name": "getLoggerData",
    "text": "def getLoggerData(key, childKeys=0, fallback=None):\n    data = read(glogfile)\n    f = lambda x: x.get('key') == key or x.get('action') == key\n    data = filter(data, f)\n\n    if not childKeys:\n        return data\n    return data\n    #for childKey in childKeys:\n    #for item in data:\n        #f\n    #if isArray(fallback):\n        #storeType = list\n    #for i\n\n\n    return data\n"
  },
  {
    "name": "hasKey",
    "text": "def hasKey(x, key):\n    return isObject(x) and x.get(key)\n"
  },
  {
    "name": "readRaw",
    "text": "def readRaw(file):\n    with open(file, 'r') as f:\n        return f.read()\n"
  },
  {
    "name": "seeClipKeys",
    "text": "def seeClipKeys():\n    s = readRaw('clip.js')\n    keys = ['staticClass', 'component']\n    r = reWrap(keys, '(?:$1)\": \"(.*?)\"')\n    data = unique(re.findall(r, s))\n    pprint(data)\n    return data"
  },
  {
    "name": "partitionMove",
    "text": "def partitionMove(dir, to=0, action='move'):\n    files = StepwisePartition().run(absdir(dir))\n    prompt(files, action=action, message='please confirm')\n    if action == 'move':\n        mfiles(files, to)\n    elif action == 'delete':\n        map(files, rfile)\n\n"
  },
  {
    "name": "textlog",
    "text": "def textlog(**kwargs):\n    store = []\n    store.append(('date', datestamp()))\n    store.append(('getCaller', getCaller()))\n    for k,v in kwargs.items():\n        store.append((k, v))\n    \n    s = ''\n    for a,b in store:\n        if not b:\n            continue\n        s += a + ': '\n        if isArray(b):\n            s += '\\n' + indent(b) + '\\n'\n        else:\n            s += b \n\n        s += '\\n'\n\n    value = s + linebreak + '\\n'\n    if s.strip():\n        append('log.txt', value)\n"
  },
  {
    "name": "WorkSummary",
    "text": "def WorkSummary(file):\n    if getExtension(file) != 'js':\n        pprint('only js for worksummary')\n        return \n\n    textlog(\n        file=file,\n        work=getBindingNames(read(file))\n    )\n"
  },
  {
    "name": "indent",
    "text": "def indent(items):\n    return join(map(items, lambda x: '    ' + x))\n\n"
  },
  {
    "name": "getBindingNames",
    "text": "def getBindingNames(s):\n    r = '^(?:class|const|var|(?:async )?function) (\\w+)'\n    return re.findall(r, s, flags=re.M)\n"
  },
  {
    "name": "isChinese",
    "text": "def isChinese(s):\n    return test('[\\u4e00-\\u9fa5]', s)\n"
  },
  {
    "name": "isEnglish",
    "text": "def isEnglish(s):\n    return test('[a-zA-Z]', s)\n"
  },
  {
    "name": "saveMathFileByFolder",
    "text": "def saveMathFileByFolder(file, gradeLevel=4):\n    date = upcomingDate('saturday', strife='-')\n    dir = mathdir + date\n    f = lambda x: f\"G{gradeLevel} {capitalize(x)}\"\n    originalPath = addExtension(file, 'txt')\n    path = npath(dir, changeFileName(originalPath, f))\n\n    def getPath(path):\n        if isfile(path):\n            if gradeLevel == 4:\n                path = path.replace('G4', 'G5')\n            else:\n                path = path.replace('G5', 'G4')\n\n            if isfile(path):\n                return \n            else:\n                return path\n        else:\n            return path\n\n    path = getPath(path)\n    assert path\n    message = \"Do you want to move this file to the mathdir? It will delete the original file\"\n    prompt(read(originalPath), message=message, outpath=path)\n\n\n    if not isdir(dir):\n        os.makedirs(dir)\n\n    mfile(originalPath, path)\n"
  },
  {
    "name": "promptRenameFile",
    "text": "def promptRenameFile(file):\n    t = tail(file)\n    a, b = re.split(' *\\| *', prompt(t), maxsplit=1)\n    newFile = file.replace(t, t.replace(a, b))\n    mfile(file, newFile)\n"
  },
  {
    "name": "getMathDir",
    "text": "def getMathDir(next=0):\n    dir = mathdir + upcomingDate('saturday', strife='-', next=next)\n    assert isdir(dir)\n    return dir\n"
  },
  {
    "name": "copydir",
    "text": "def copydir(src, to):\n    newDir = npath(to, src)\n    assert not isdir(newDir) and isdir(to)\n    prompt(f\"copying {src} to {newDir}\")\n    shutil.copytree(src, newDir)\n    print(f\"copying directory: {newDir}\")"
  },
  {
    "name": "get_usb_dir",
    "text": "def get_usb_dir():\n    if isdir(usbdrivedir):\n        return usbdrivedir\n    elif isdir(sandir):\n        return sandir\n    else:\n        raise Exception('no usb dir')\n"
  },
  {
    "name": "usb",
    "text": "def usb(x=0):\n\n    dir = get_usb_dir()\n\n    f = glf(dir=dir2023)\n    if tail(f) == 'clip.html' and isRecent(f, minutes=5):\n        cfile(f, dir)\n        return \n\n    dir = os.path.join(dir, str(getYearNumber()))\n    mkdir(dir)\n\n    files = x or ff(dir2023, hours=10, js=1)\n    map(files, cfile, dir)\n\n"
  },
  {
    "name": "saveToSandisk",
    "text": "def saveToSandisk(x=2):\n    if not isdir(sandir):\n        raise Exception('')\n    outdir = os.path.join(sandir, datestamp())\n    if isdir(outdir):\n        raise Exception('outdir already exists')\n    mkdir(outdir)\n\n    if isdir(x):\n        copydir(dir, outdir)\n    else:\n        if isNumber(x):\n            x = ff(dir2023, days=2) + ff(pydir, days=2)\n\n        prompt(x, 'save to outdir?', outdir=outdir)\n        map(x, cfile, outdir)\n"
  },
  {
    "name": "saturdate",
    "text": "def saturdate():\n    return upcomingDate('saturday', strife='-')\n"
  },
  {
    "name": "getSaturdayDir",
    "text": "def getSaturdayDir(dir):\n    return os.path.join(dir, saturdate())\n"
  },
  {
    "name": "swapFiles",
    "text": "def swapFiles(a, b):\n    a = addExtension(a, 'js')\n    b = addExtension(b, 'js')\n    s = read(a)\n    cfile(b, a)\n    write(b, s)\n"
  },
  {
    "name": "sayhi",
    "text": "def sayhi(s):\n    return 'Hello from ' + s + '!'\n"
  },
  {
    "name": "writeFiles",
    "text": "def writeFiles(*args):\n    def runner(arg):\n        write(addExtension(arg, 'js'), sayhi(arg))\n    map(args, runner)\n"
  },
  {
    "name": "nameAndDate",
    "text": "def nameAndDate(file):\n    name = tail(file)\n    date = datestamp(file)\n    return [date, name]\n"
  },
  {
    "name": "mkfile",
    "text": "def mkfile(file, *items):\n    write(file, join(items))\n"
  },
  {
    "name": "fa",
    "text": "def fa(s, r, flags=0, **kwargs):\n    ref = {\n        'numbers': '-?\\d+',\n        'integers': '-?\\d+',\n    }\n    r = ref.get(r, r)\n    s = s if isArray(s) else textgetter(s)\n    #print(len(s))\n    #print(currentFile())\n    #raise Exception()\n    m = re.findall(r, s, flags=flags)\n    #pprint(m)\n    if kwargs.get('filter'):\n        m = filter(m, kwargs.get('filter'))\n    m = unique(m)\n\n    if kwargs.get('fn'):\n        m = map(m, kwargs.get('fn'))\n\n    if kwargs.get('choose'):\n        pass\n\n    if kwargs.get('append'):\n        if kwargs.get('append') == 'self':\n            appendVariable(dumpJson(m))\n\n    return m\n"
  },
  {
    "name": "file_table_cleanup",
    "text": "def file_table_cleanup():\n\n    def filetablefn(file, notes):\n        r = 'dep|del'\n        if not isfile(file):\n            print(\"'not a file'\", file)\n            return \n        try:\n            if test(r, notes) or fsize(file) < 50:\n                print('removing', tail(file))\n                rfile(file)\n        except Exception as e:\n            print(e, file)\n        \n\n    fa('file-table.txt', '2023 +(\\S+)(.*)', fn=filetablefn)\n\n"
  },
  {
    "name": "publish",
    "text": "def publish(name):\n    dir = publishdir\n    inpath = addExtension(name, 'txt')\n    outpath = npath(dir, inpath + '.' + saturdate())\n    shutil.copy(inpath, outpath)\n    clear(inpath)\n    printdir(dir)"
  },
  {
    "name": "openFirstFile",
    "text": "def openFirstFile(dir):\n    ofile(absdir(dir)[0])\n"
  },
  {
    "name": "addfiles",
    "text": "def addfiles():\n    ignoreRE = '''\n        component\n        scratch\n        directive\n        state\n        config\n        ask\n        clip\n        wrappers\n        server\n        chalk\n        main\n        puppeteer\n        pretty\n\n        serve\n        type\n        interactive\n        ox3\n        hammy\n        app\n\n    '''\n    ignoreRE = '|'.join(linegetter(ignoreRE))\n    return ff(js=1, days=5, sort='date', ignoreRE=ignoreRE, size=2000)\n"
  },
  {
    "name": "addTitles",
    "text": "def addTitles():\n    def f(item):\n        if test('^\\w+(?: \\w+){1,5} *\\n', item):\n            title = search('^\\w.+', item)\n            dprint(title)\n            return item\n        #if test('^\\w+\\n\\n', item):\n            #dprint(title)\n            #return item\n\n        else:\n            a = prompt(item, 'write a title if you would like:  ')\n            if a:\n                return a + '\\n\\n' + item\n            return item\n\n    s = read('quiz.txt')\n    items = map(split(s, '^---+', flags=re.M), f)\n    clip('\\n\\n---------------------'.join(items))\n    #clip(items)\n    #s = join(items, '\\n\\n-------------------')\n    #clip(s)\n"
  },
  {
    "name": "downloadImage",
    "text": "def downloadImage(url, name, openIt=0):\n    from requests import get\n    r = get(url)\n    if r.status_code == 200:\n        with open(name,'wb') as f:\n            f.write(r.content)\n            if openIt:\n                ofile(name)\n            print('Image sucessfully Downloaded: ',name)\n            return name\n    else:\n        print('Image Couldn\\'t be retreived', name) \n"
  },
  {
    "name": "coerceArray",
    "text": "def coerceArray(x):\n    if isArray(x):\n        return x\n    if x == None:\n        return []\n    return [x]\n"
  },
  {
    "name": "save",
    "text": "def save(**kwargs):\n    for k,v in kwargs.items():\n        appendVariable(v, name=k)\n        break\n"
  },
  {
    "name": "archive",
    "text": "def archive(inpath=0, outpath=0):\n    if not inpath: inpath = 'clip.js'\n    if not outpath: \n        outpath = prompt(outpath='need an outpath', inpath=inpath)\n    assert outpath\n\n    cfile(inpath, npath(drivedir, outpath))\n"
  },
  {
    "name": "checkpoint_factory",
    "text": "def checkpoint_factory(schema):\n\n    def c2(**kwargs):\n        #print(kwargs)\n        def transform(a, b):\n            #print(a, b)\n            if b == str:\n                return lambda x: test(a, x, flags=re.I)\n\n            if b == bool:\n                print(a, b)\n                return lambda x: x == a\n\n            if b == int:\n                return lambda x: x > a\n\n        store = []\n        for k,v in schema.items():\n            arg = kwargs.get(k)\n            if arg != None:\n                store.append([k, transform(arg, v)])\n\n        def checkpoint(item):\n            for k,v in store:\n                arg = item.get(k)\n                if arg and not v(arg):\n                    return False\n\n            return True\n        return checkpoint\n\n    return  c2\n        \n"
  },
  {
    "name": "obj_filter",
    "text": "def obj_filter(items, **kwargs):\n    schema = {\n        'title': str,\n        'owner': str,\n        0: int,\n        'delete': bool,\n    }\n\n    getter = getterf(kwargs.get('get'))\n    c1 = checkpoint_factory(schema)\n    f = c1(**kwargs)\n    \n    values = [getter(item) for item in items if f(item)]\n    return values"
  },
  {
    "name": "small",
    "text": "def small(x):\n    return x[0: 3]\n"
  },
  {
    "name": "getterf",
    "text": "def getterf(*args):\n    args = flat(map(args, lambda x: split(x, '[, ]+') if x else []))\n    if not args:\n        return identity \n    def fn(item):\n        store = {}\n        for arg in args:\n            if arg in item:\n                store[arg] = item[arg]\n        return store\n    return fn\n"
  },
  {
    "name": "googleDocsJson",
    "text": "def googleDocsJson(debug=0):\n    if debug:\n        return tempGoogleDocJson\n    return read(drivedir + 'allGoogleDocs.json')"
  },
  {
    "name": "makeNodePDF",
    "text": "def makeNodePDF(data = temp, vob_key='resume_toc'):\n    fnKey = 'makePDF'\n    payload = {'key': vob_key, 'value': data}\n    SystemCommand('node', 'App.js', fnKey, payload)\n"
  },
  {
    "name": "comment",
    "text": "def comment(s):\n    return '# ' + s\n"
  },
  {
    "name": "writejs",
    "text": "def writejs(s):\n    name = prompt('choose a file name')\n    name = addExtension(name, 'js')\n    if exists(s):\n        write(name, s)\n        append(self(), comment(abspath(name)))\n"
  },
  {
    "name": "dprompt",
    "text": "def dprompt(*variables, **kwargs):\n    \n    import inspect\n\n    strings = []\n    caller = getCaller()\n    from collections import OrderedDict\n    store = OrderedDict()\n    store['caller'] = caller\n\n    for v in variables:\n        try:\n            vars = inspect.currentframe().f_back.f_locals.items()\n            name = [v_name for v_name, v_val in vars if v_val is v][0]\n            store[name] = v\n        except Exception as e:\n            strings.append(v)\n        \n\n    for a,b in kwargs.items():\n        store[a] = b\n\n    if strings: \n        store['strings'] = strings\n\n    pprint(store)\n    return input('')\n\n\n"
  },
  {
    "name": "file_name",
    "text": "def file_name(s):\n    return removeExtension(tail(s))\n"
  },
  {
    "name": "is_json",
    "text": "def is_json(f):\n    return getExtension(f) == 'json'\n"
  },
  {
    "name": "rename_file",
    "text": "def rename_file():\n    f = glf(dir2023)\n    mfile(f, changeExtension(f, 'js'))\n"
  },
  {
    "name": "printDiff",
    "text": "def printDiff(target=''):\n    s = SystemCommand(f\"git diff --word-diff {target}\")\n    if target:\n        print(s.success)\n    else:\n        #return print(s.success)\n        write('diff.txt', s.success, open=1)\n\n"
  },
  {
    "name": "getNewGitFiles",
    "text": "def getNewGitFiles():\n    s = SystemCommand('git status --short').success\n    r = '^ *\\?\\? *(.+)'\n    return re.findall(r, s, flags=re.M)\n\n"
  },
  {
    "name": "mwrite",
    "text": "def mwrite(inpath, outpath, regex, flags=0):\n    text = read(inpath)\n    assert text\n\n    if test('^\\^', regex) and not flags:\n        flags = re.M\n\n    a, payload = mget(regex, text, flags=flags, mode=list)\n    if not payload:\n        return print('no payload early return')\n\n    prompt(payload)\n    write(smart_path('temp.py'), text)\n    return \n    clip(text)\n    raise Exception()\n    outpath = addExtension(outpath, getExtension(inpath))\n    append(smart_path(outpath), payload)\n"
  },
  {
    "name": "mwrite_base",
    "text": "def mwrite_base(outpath, regex):\n    mwrite(smart_path('base.py'), outpath, regex)\n\n"
  },
  {
    "name": "smart_path",
    "text": "def smart_path(file):\n    return npath(dirFromFile(file), file)\n\n"
  },
  {
    "name": "rlf",
    "text": "def rlf():\n    rfile(glf())\n\n\n\n"
  },
  {
    "name": "clf",
    "text": "def clf(name):\n    f = glf()\n    file = dldir + addExtension(name, getExtension(f))\n    cfile(f, file)\n\n"
  },
  {
    "name": "man",
    "text": "def man(files=0):\n    return \n    a = resourcedir2023\n    b = dir2023\n    #files = ff(a, js=1, css=1, html=1, anti=1, json=1)\n    #files = ff(a, css=1, html=1)\n    prompt(files)\n    mfiles(files, b)\n\n\n    \n\n"
  },
  {
    "name": "mkgitdir",
    "text": "def mkgitdir(name, user='kdog3682'):\n    #assert(' ' not in name, 'no spaces')\n    dir = npath(rootdir, name)\n    dprompt('making directory', dir)\n    chdir(mkdir(dir))\n    if isdir('.git'):\n        print('git already exists')\n        print('early return')\n        return \n    write('README.md', datestamp())\n    url = f\"https://github.com/{user}/{name}\"\n    remote = f\"{url}.git\"\n    sys = SystemCommand(f\"\"\"\n        cd {dir}\n        git init\n        echo 'successful init'\n        git add README.md\n        echo 'readme added'\n        git commit -m \"Initial commit\"\n        echo 'successful commit'\n        git remote add origin {remote}\n        echo 'successful remote added'\n        git push -u origin main\n        echo 'done'\n    \"\"\")\n    print(sys.success)\n"
  },
  {
    "name": "rename",
    "text": "def rename(a, b):\n    dir = dirFromFile(a)\n    a = npath(dir, a)\n    b = npath(dir, addExtension(b, getExtension(a)))\n    dprompt(a, b)\n    mfile(a, b)\n\n    #rename('app-main.js', 'appscript')\n\n"
  },
  {
    "name": "save",
    "text": "def save(x, mode=0, current=0):\n    payload = x\n    if mode == 'python':\n        if isString(x):\n            payload = f\"file = '{x}'\"\n        elif isArray(x):\n            if len(x) == 1:\n                payload = f\"file = '{x[0]}'\"\n            else:\n                payload = f\"files = {dumpJson(x)}\"\n        else:\n            payload  =dumpJson(x)\n    else:\n        payload    =dumpJson(x)\n    outpath = self() if current  else vimsavefile\n    append(outpath, payload)\n"
  },
  {
    "name": "drivePicturesToHammyArtContestFolder",
    "text": "def drivePicturesToHammyArtContestFolder(contestNumber):\n    from heif import heicToJpg\n    assert contestNumber\n    dir = mkdir(dir2023 + 'hammy-math-class/art-contest-' + str(contestNumber))\n    files = mostRecentFileGroups(drivedir)\n    f = lambda x: npath(dir, changeExtension(x, 'jpg'))\n    items = double(files, f)\n    for a,b in items:\n        heicToJpg(a, b)\n\n"
  },
  {
    "name": "email",
    "text": "def email(body='', to=0, subject=\"\", files=0):\n    ids = None\n    if files:\n        files = toArray(files)\n        drive = GoogleDrive()\n        ids = map(files, drive.uploadFile)\n\n    emailBody = {\n        \"attachments\": ids,\n        \"from\": env.EmailContacts.get(\"self\"),\n        \"to\": env.EmailContacts.get(to or \"self\"),\n        \"body\": body,\n        \"subject\": subject,\n    }\n    prompt(emailBody)\n\n    appscript('email', emailBody)\n"
  },
  {
    "name": "to_callable",
    "text": "def to_callable(s, *args):\n    arg_str = ', '.join(map(args, to_argument))\n    output = f\"{s}({arg_str})\"\n    return output"
  },
  {
    "name": "to_argument",
    "text": "def to_argument(s):\n    return json.dumps(s)\n"
  },
  {
    "name": "appscript",
    "text": "def appscript(s, *args):\n    s = to_callable(s, *args)\n    s = f\"Finish({s})\"\n    #print(s)\n    #return\n    googleAppScript(s)\n"
  },
  {
    "name": "appscript2",
    "text": "def appscript2():\n    s = read(env.GOOGLE_APPSCRIPT_FILE).strip()\n    r = \"^(?:(?:// *|import).+)(?:\\n+(?:// *|import).+)*\"\n    s, imports = mget(r, s, flags=re.M, mode=str)\n\n    store = []\n    if imports:\n        imports = re.findall(\n            \"^import (\\S+)\", imports, flags=re.M\n        )\n        for i in imports:\n            if i == \"clip\":\n                print(\"adding clip import\")\n                store.append(\n                    createVariable(\"clip\", clip(), \"js\")\n                )\n            elif i == \"clip2\":\n                store.append(\n                    createVariable(\"clip2\", clip(2), \"js\")\n                )\n            elif getExtension(i) == \"js\":\n                store.append(normRead(i))\n            else:\n                file = normRead(i + \".temp.json\")\n                data = createVariable(\n                    camelCase(i), file, \"js\"\n                )\n                store.append(data)\n\n        s = join(store) + \"\\n\\n\" + s\n\n    s += \"\\n\\nFinish2()\"\n\n    ref = {\n        \"print\": googlePrint,\n        \"open\": googleOpen,\n        \"write\": googleWrite,\n        \"clip\": googlePrint,\n        \"clip\": googlePrint,\n        \"value\": googleValue,\n        \"vim\": googleVim,\n        \"logs\": googleLogs,\n        \"error\": lambda x: print(x),\n        \"createVariable\": googleCreateVariable,\n        \"appendVariable\": googleCreateVariable,\n    }\n\n    data = google_request(s)\n    try:\n\n        print({'data': data})\n        print(\"starting google appscript function series\")\n        for k, v in data.items():\n            if v and ref[k]:\n                print('::' + k + '::\\n')\n                ref[k](v)\n    \n        print(linebreak)\n        print('done with google appscript')\n    except Exception as e:\n        print(data)\n    \n\n"
  },
  {
    "name": "emailLastFile",
    "text": "def emailLastFile():\n    email(subject=\"last file\", files=glf())\n"
  },
  {
    "name": "yuma",
    "text": "def yuma(a, b, c):\n    dprint(a, b, c)\n\n\n"
  },
  {
    "name": "pythonWithState",
    "text": "def pythonWithState(s, state):\n\n    args, kwargs = getArgsKwargs(s)\n    fn = 0\n    file = 0\n    text = 0\n\n    if kwargs.get('write'):\n        fn = write\n        file = kwargs.get('write')\n    elif kwargs.get('append'):\n        fn = append\n        file = kwargs.get('append')\n    else:\n        fn = identity \n    \n    if 'block' in args:\n        text = state.get('blockText')\n    else:\n        text = read(state.get('file'))\n\n    if isString(text) and fn and file:\n        fn(file, text)\n        webbrowser.open(file)\n    else:\n        print(\"'not done yet'\")\n\n\n\n    #if mode == 'append':\n        #lang = state.get('lang')\n        #name = re.sub('^(?:add|get|remove|find)', '', fnKey.lower())\n        #append(state.get('file'), createVariable(name, value, lang))\n    #else:\n        #print(value)\n"
  },
  {
    "name": "PythonController",
    "text": "def PythonController(argv = sys.argv[1:]):\n    if not argv:\n        return print(\"requires shell\")\n\n    argv = map(list(argv), shellunescape)\n    arg = None\n    ref = None\n\n    red(argv)\n    if isObject(argv[0]):\n        ref = argv[0]\n        key = ref.get('fnKey')\n        arg = ref.get('arg')\n    else:\n        key, *args = argv\n\n    ex = env.executables.get(key)\n    if ex:\n        if arg:\n            ex = re.sub('\\$1', arg, ex)\n        ex = smartDedent(ex)\n        print(ex)\n        return exec(ex)\n\n    key = env.basepyref.get(key, key)\n    if not key:\n        return \n    fn = globals().get(key)\n\n    if not fn:\n        return red('The fn key is not registered in globals', key)\n\n    if ref:\n        argList, kwargList = getParameters2(fn)\n        fnArgs = filter(map2(argList, lambda x: ref.get(x)))\n        fnKwargs = reduce(kwargList, lambda x: [x, ref.get(x)])\n        if arg:\n            fnArgs.insert(0, arg)\n\n        blue('args', fnArgs)\n        blue('kwargs', fnKwargs)\n        fn(*fnArgs, **fnKwargs)\n    else:\n        fn(*args)\n"
  },
  {
    "name": "sortCwtFiles",
    "text": "def sortCwtFiles(s):\n    s = tail(s).lower()\n    m = dsearch(s, cwtFileDict)\n    assert m\n    return (m, s)\n"
  },
  {
    "name": "changers",
    "text": "def changers():\n    \n    changers = {\n        \"g5r.pdf\": \"Grade 5 Final Exam Review.pdf\",\n        \"g4r.pdf\": \"Grade 4 Final Exam Review.pdf\",\n        \"g5hw.pdf\": \"Grade 5 Homework.pdf\",\n        \"g4hw.pdf\": \"Grade 4 Homework.pdf\",\n        \"g5cw.pdf\": \"Grade 5 Classwork.pdf\",\n        \"g4cw.pdf\": \"Grade 4 Classwork.pdf\",\n        \"g5q.pdf\": \"Grade 5 Quiz.pdf\",\n        \"g4q.pdf\": \"Grade 4 Quiz.pdf\",\n        \"WG5Q1.pdf\": \"Grade 5 Quiz.pdf\",\n        \"WG4Q1.pdf\": \"Grade 4 Quiz.pdf\",\n        \"g4exam.pdf\": \"Grade 4 Exam.pdf\",\n        \"g5exam.pdf\": \"Grade 5 Exam.pdf\",\n    }\n\n    for file, destination in changers.items():\n        if isfile(file) and not isRecent(\n            destination, days=3\n        ):\n            if prompt('change it?', file, destination):\n                mfile(file, destination)\n"
  },
  {
    "name": "buildFiles",
    "text": "def buildFiles():\n    chdir(dldir)\n    changers()\n    regex = reWrap(cwtFileDict)\n    #files = ff(dldir, hours=40, pdf=1, regex=regex, flags=re.I, antiregex='test.pdf')\n\n    files = [\n        \"G5 Classwork.pdf\",\n        \"Grade 4 Announcements.pdf\",\n        \"G4 Homework.pdf\",\n        \"G4 Classwork.pdf\",\n        \"Grade 5 Announcements.pdf\",\n        \"G5 Homework.pdf\",\n        \"Student Letters.pdf\"\n    ]\n\n    storage = Storage()\n    misc = []\n\n    for file in files:\n        k = search('g(?:rade)? *(\\d+)', file, flags=re.I)\n        if k and not test('announcement|report', file, flags=re.I):\n            storage.add(k, file)\n        else:\n            misc.append(file)\n\n    data = []\n    for k,v in storage.toJSON().items():\n        data.append({\n            'key': k,\n            'files': sort(v, sortCwtFiles),\n        })\n    prompt({\n        'all-files': files,\n        'data': data,\n        'misc': misc,\n        'caller': 'buildFiles',\n    })\n    return [data, misc, files]\n"
  },
  {
    "name": "uploadFiles",
    "text": "def uploadFiles(files):\n    from ga import GoogleDrive\n    def fixName(s):\n        return removeExtension(tail(s))\n    drive = GoogleDrive()\n    return [{'id': drive.uploadFile(f), 'name': fixName(f)} for f in files]\n\n\n"
  },
  {
    "name": "uploadMaterials",
    "text": "def uploadMaterials(skipClassroom=0, skipEmail=0, official=1, fileData=0, doGrades=1):\n    from ga import GoogleClassroom, GoogleDrive\n\n    data, misc, all = fileData or buildFiles()\n    assert data\n    store = []\n    rooms = []\n\n    for item in data:\n        key = item.get(\"key\") if official else \"emc\"\n        files = item.get(\"files\")\n        room = GoogleClassroom(key)\n        rooms.append(room)\n        room.skipClassroom = skipClassroom \n        assert files\n        results = map(files, room.uploadAssignment)\n        assert results\n        room.openLink()\n        store.extend(results)\n\n    # ------------------------------------------------\n    def getSubject(subject=\"G4/G5\", topic=\"Math\"):\n        date = upcomingDate(\"saturday\")\n        return f\"{subject} {topic} Materials {date}\"\n    # ------------------------------------------------\n\n    if misc:\n        store.extend(uploadFiles(misc))\n\n    payload = {\n        \"subject\": getSubject(),\n        \"files\": map(store, lambda x: x.get(\"name\")),\n        \"attachments\": map(store, lambda x: x.get(\"id\")),\n        \"to\": env.workEmail if official else env.EmailContacts.get('self')\n    }\n\n    # ------------------------------------------------\n    if skipEmail:\n        print('Done. Skipping email.')\n        return \n\n    prompt('We always prompt the payload before going to google emails', payload)\n\n    googleAppScript(\"Action\", \"courseWork\", payload)\n    gmailsenturl = \"https://mail.google.com/mail/u/0/#sent\"\n    ofile(gmailsenturl)\n    #clear(departurejsonfile)\n    deleteFinishedPDFS()\n    if doGrades:\n        print(\"Starting the gradeClassroom auto process.\")\n        for room in rooms:\n            gradeClassroom(room)\n"
  },
  {
    "name": "cwtBuildNecessaryFiles",
    "text": "def cwtBuildNecessaryFiles(grades=[4, 5]):\n    print(\"'this is kind of deprecated ... as the systems get better and better\")\n    raise Exception('use buildFiles instead')\n\n    extraFiles = [\n        # \"G4 & G5 Math Report Cards.pdf\",\n        # \"G4 & G5 Online Report Cards.pdf\",\n        # \"Announcements\",\n        # \"Progress Reports\",\n        # \"Midterm 1 Scores\",\n        # \"Final Exam Scores\",\n        # \"Report Cards\",\n        \"Grade Reports\",\n    ]\n    baseFiles = [\n        \"Exam\",\n        \"Final Exam\",\n        \"Practice Exam\",\n        \"Extra Homework\",\n        \"Homework\",\n        \"Classwork\",\n        \"Quiz\",\n        # \"Final Exam Review\",\n        # \"Warmup\",\n        # \"Handout Packet 1\",\n        # \"Handout Packet 2\",\n        # \"Handout Packet 3\",\n        # \"Midterm Exam Review\",\n        # \"Midterm Exam\",\n        # \"Handout\",\n        # \"Extra Worksheets\",\n        # \"Quarter 1 Exam\",\n        # \"Announcement\",\n    ]\n\n    changers = {\n        \"g5r.pdf\": \"Grade 5 Final Exam Review.pdf\",\n        \"g4r.pdf\": \"Grade 4 Final Exam Review.pdf\",\n        \"g5hw.pdf\": \"Grade 5 Homework.pdf\",\n        \"g4hw.pdf\": \"Grade 4 Homework.pdf\",\n        \"g5cw.pdf\": \"Grade 5 Classwork.pdf\",\n        \"g4cw.pdf\": \"Grade 4 Classwork.pdf\",\n        \"g5q.pdf\": \"Grade 5 Quiz.pdf\",\n        \"g4q.pdf\": \"Grade 4 Quiz.pdf\",\n        \"WG5Q1.pdf\": \"Grade 5 Quiz.pdf\",\n        \"WG4Q1.pdf\": \"Grade 4 Quiz.pdf\",\n        \"g4exam.pdf\": \"Grade 4 Exam.pdf\",\n        \"g5exam.pdf\": \"Grade 5 Exam.pdf\",\n    }\n\n    for file, destination in changers.items():\n        if isfile(file) and not isRecent(\n            destination, days=3\n        ):\n            mfile(file, destination)\n\n    storage = Storage()\n\n    p1 = \"Grade \"\n    p2 = \"G\"\n    for file in baseFiles:\n        file = toPdf(file)\n        for grade in grades:\n            a = str(grade) + \" \" + file\n            if isRecent(p1 + a, days=3):\n                storage.add(grade, p1 + a)\n            elif isRecent(p2 + a, days=3):\n                storage.add(grade, p2 + a)\n\n    items = storage.toJSON().items()\n    classFiles = [\n        {\"key\": str(k), \"files\": v} for k, v in items\n    ]\n    extraFiles = filter(map(extraFiles, toPdf), isfile)\n    data = {\n        \"classFiles\": classFiles,\n        \"extraFiles\": extraFiles,\n    }\n    return data\n\n"
  },
  {
    "name": "replyReddit",
    "text": "def replyReddit():\n    from redditscript import Reddit\n\n    reddit = Reddit()\n    reddit.reply_all_comments()\n    print(\"done replying to comments\")\n\n"
  },
  {
    "name": "redditFromJS",
    "text": "def redditFromJS(items):\n    from redditscript import Reddit\n\n    reddit = Reddit()\n\n    submissions = []\n    for i, o in enumerate(items):\n        try:\n            submission = reddit.ask(**o)\n            submissions.append(submission)\n            openBrowser(submission.shortlink)\n        except:\n            print(o, \"error\")\n            pass\n\n    print(\"done\")\n    return\n    a = choose(map(items, \"title\"), auto=0)\n    if not a:\n        return\n    for s in submissions:\n        if s.title in a:\n            s.delete()\n            print(\"deleting\", s.title)\n\n"
  },
  {
    "name": "runFunction",
    "text": "def runFunction(fn, *args):\n    count = countArgs(fn)\n    args = list(args)[0:count]\n    print(args)\n"
  },
  {
    "name": "countArgs",
    "text": "def countArgs(f, *args, **kwargs):\n    data = inspect.signature(f)\n    params = data.parameters\n    s = str(data)\n    if \"*\" in s:\n        return 255\n    return len(params)\n\n"
  },
  {
    "name": "gitDelete",
    "text": "def gitDelete(file):\n    cmd = f\"\"\"\n        git rm {file}\n        git commit -m \"REMOVE {file}\"\n        git push\n    \"\"\"\n\n    SystemCommand(cmd)\n\n\n"
  },
  {
    "name": "pushAll",
    "text": "def pushAll():\n    dirs = [dir2023, pydir, resourcedir]\n    for dir in dirs:\n        cleandir(dir)\n\n        if dir == dir2023:\n            #diff = parseDiff(dir=dir)\n            #appendjson('git.json', diff)\n            time.sleep(1)\n\n\n        mainCommand = f\"\"\"\n            cd {dir}\n            git add .\n            git commit -m \"'autopush'\"\n            git push\n        \"\"\"\n        response = SystemCommand(mainCommand, dir=dir)\n\n        gitData = {\n            'success': response.success,\n            'error': response.error,\n        }\n        pprint(gitData)\n"
  },
  {
    "name": "gitManager",
    "text": "def gitManager(\n    file=0,\n    files=0,\n    move=0,\n    remove=0,\n    push=1,\n    message=0,\n    dir=dir2023,\n    firstTime=0,"
  },
  {
    "name": "gitPushAll",
    "text": "def gitPushAll():\n    raise Exception()\n    gitPushPython()\n    gitPush()\n"
  },
  {
    "name": "detect_content_type",
    "text": "def detect_content_type(text):\n    # Check for HTML tags\n    if '<html' in text or '<body' in text or '<div' in text:\n        return 'HTML'\n\n    code_keywords = ['const', 'function', 'def']\n    #code_keywords = ['def', 'class', 'import', 'return', 'for', 'while', 'if', 'else', 'func]\n    for keyword in code_keywords:\n        if keyword in text:\n            return 'Code'\n\n    return 'Prose'\n\n"
  },
  {
    "name": "parseMathcha",
    "text": "def parseMathcha(state):\n    #unzip(state.file, mathchadir)\n    file = mathchadir + 'index.html'\n    ofile(file)\n"
  },
  {
    "name": "filter2023",
    "text": "def filter2023(items, fn=0, **kwargs):\n    checkpoint = fn if fn else checkpointf(**kwargs)\n    return [item for item in items if checkpoint(item)]\n\n"
  },
  {
    "name": "parseOpenai",
    "text": "def parseOpenai(state):\n        raw = map(state.data, parseJSON)\n        data = filter2023(raw, lambda x: not isPrimitive(x))\n        return clip(flat(data))\n        pprint(data)\n        raise Exception()\n        if every(data, lambda x: len(x.keys()) == 1):\n            key = list(data[0].keys())[0]\n            if every(data, lambda x: key in x):\n                pprint('hi')\n                payload = flat(map(data, lambda x: x.get(key)))\n                return clip(payload)\n            else:\n                raise Exception()\n\n        return pprint(data)\n        item = reverseIter(data, runner)\n        if item:\n            return write('chatgpt-generated-html.html', item, 1)\n        #return ofile(file)\n"
  },
  {
    "name": "smartManager",
    "text": "def smartManager():\n    file = glf()\n\n    state = FileState(file)\n\n    def runner(item, key):\n        q = item.get(key)\n        if q and test('^' + q, getattr(state, key)):\n            return True\n\n    keys = ['name', 'extension', 'tail', 'file']\n    for item in smartItems:\n        for key in keys:\n            if runner(item, key):\n                return item['fn'](state)\n\n"
  },
  {
    "name": "addPythonImports",
    "text": "def addPythonImports(s):\n    \n    importRef = {\n        'Github': 'githubscript',\n        'MyFireStore': 'fire',\n        'Reddit': 'redditscript',\n        'Google': 'ga',\n        'aiprompt': 'chatgpt',\n    }\n    extra = dsearch(s, importRef, '^(?:$1)')\n    return f\"from {extra} import *\\n{s}\" if extra else s\n"
  },
  {
    "name": "pythonAppController",
    "text": "def pythonAppController():\n    pacFile='/home/kdog3682/PYTHON/pac.txt'\n    items = split(removeComments(read(pacFile)), '\\n\\n+')\n    cmd = dollarPrompt(items)\n    cmd = addPythonImports(cmd)\n    try:\n        exec(cmd)\n    except Exception as e:\n        pprint(cmd)\n        pprint(e) \n    \n"
  },
  {
    "name": "googleAppController",
    "text": "def googleAppController():\n    items = split(removeComments(read('gac.txt')), '\\n+')\n    s = dollarPrompt(items)\n    return googleAppScript(f\"Finish({s})\")\n\n"
  },
  {
    "name": "execPython",
    "text": "def execPython(s=''):\n    dict = {\n        'av': 'appendVariable',\n    }\n    s = dreplace(s, dict, template='b')\n    exec(s)\n\n"
  },
  {
    "name": "reverseIter",
    "text": "def reverseIter(items, f):\n    for i in range(len(items) -1, -1, -1):\n        item = items[i]\n        result = f(item)\n\n        if result == True:\n            return item\n        elif result == False:\n            return \n"
  },
  {
    "name": "opener",
    "text": "def opener(s):\n    s = removeComments(s).strip()\n    return write('ofile.js', s, 1)\n\n\n"
  },
  {
    "name": "getChatGptPrompt",
    "text": "def getChatGptPrompt():\n    def runner(x):\n        s = x.group(0)\n        return stringify(eval(s))\n    s = read('/home/kdog3682/2023/chatgpt.txt')\n    s = removeComments(smartDedent(s))\n    s = re.sub('(?<== ).+', runner, s)\n    s += '\\n'\n    s += '\\n'\n    s += 'Output the results in json list form.'\n    return s\n"
  },
  {
    "name": "runChatgpt",
    "text": "def runChatgpt(cmd=0):\n    debug = 1\n    if not cmd: \n        cmd = getChatGptPrompt()\n        debug = 0\n\n    from chatgpt import ask\n    response = ask(cmd).strip()\n    payload = {\n        'prompt': cmd,\n        'response': response,\n    }\n\n    if debug:\n        print(response)\n    else:\n        appendjson(chatgptjsonfile, payload, mode=list)\n\n"
  },
  {
    "name": "previewMaterials",
    "text": "def previewMaterials():\n    try:\n        fileData = read(departurejsonfile)\n        if exists(fileData):\n            return uploadMaterials(fileData=fileData)\n    except Exception as e: \n        pass\n\n    data, misc, files = buildFiles()\n    ofile(files)\n    if prompt(files, 'ready for departure?'):\n        write(departurejsonfile, [data, misc, files])\n\n"
  },
  {
    "name": "masterFileInfo",
    "text": "def masterFileInfo(dir=dir2023):\n    files = sorted(absdir(dir))\n    def runner(f):\n        name = tail(f)\n        date = datestamp(f)\n        size = fsize(f)\n        return {\n            \"name\": tail(f),\n            \"size\": fsize(f),\n            \"date\": date,\n            \"extension\": getExtension(f)\n        }\n    payload = map(files, runner)\n    outpath = tail(dir) + '.directory.json'\n    write(outpath, payload, True)\n\n"
  },
  {
    "name": "copyToBrowser",
    "text": "def copyToBrowser(s):\n    return write(dldir + 'ofile.js', removeComments(s).strip(), 1)\n"
  },
  {
    "name": "temporaryBackup",
    "text": "def temporaryBackup(state):\n    announce()\n    pprint(state)\n    files = ff(state.get('buffers'), js=1, biggerThan=100)\n    cfiles(files, tempbudir, ask=1)\n\n"
  },
  {
    "name": "revert",
    "text": "def revert(file=0, vim=0, increment=0, dir=0, ask=0):\n    if not file:\n        file = mostRecent(budir)\n        if not dir:\n            dir = dirFromFile(file)\n        name = dir + file\n    elif increment:\n        if not dir:\n            dir = dirFromFile(file)\n        name = incrementName(npath(dir, file))\n    elif ask:\n        name = prompt(file, \"name for the file ?\")\n        name = dir + name\n\n    if not dir:\n        dir = dirFromFile(file)\n        dir = budir\n\n    outpath = name or dir\n    dprint(outpath, file)\n    if vim:\n        appendVim(\"filedict\", outpath)\n    cfile(file, outpath)\n"
  },
  {
    "name": "revertjs",
    "text": "def revertjs(file):\n    print('reverting js', file)\n    assert(file) \n    src = trashdir + file\n    if not isfile(src):\n        src = budir + file\n\n    assert isfile(src)\n    outpath = dirFromFile(file)\n    input(dprint(src, outpath))\n    mfile(src, outpath)\n"
  },
  {
    "name": "deleteFinishedPDFS",
    "text": "def deleteFinishedPDFS():\n    ff(dldir, pdf=1, mode='delete', weeks=2)\n\n\n    #return write(dldir + 'ofile.js', removeComments(s).strip(), 1)\n\n"
  },
  {
    "name": "shonitProject",
    "text": "def shonitProject():\n\n    import redditscript\n    from tesseract import tesseractExtractText\n\n    kwargs = dict(\n        user = 'shonitB',\n        type = 'image',\n        minScore = 5,\n        minNumComments = 5,\n        subreddit = None,\n        fromDate = 0,\n        toDate = 'today',\n    )\n    shonitImageLinks = redditscript.Reddit().getPosts(**kwargs)\n    store = []\n    for url in shonitImageLinks:\n        localPath = downloadImage(url, name = 'temp')\n        text = tesseractExtractText(localPath)\n        text = postProcess(text)\n        if text:\n            store.append(text)\n\n    return store\n\n"
  },
  {
    "name": "downloadImage",
    "text": "def downloadImage(url, name, openIt=0):\n    import requests\n    r = requests.get(url)\n    if r.status_code == 200:\n        with open(name, \"wb\") as f:\n            f.write(r.content)\n            print(\"Image sucessfully Downloaded: \", name)\n            if openIt:\n                ofile(name)\n            return name\n    else:\n        print(\"Image Couldn't be retreived\", name)\n\n\n\n"
  },
  {
    "name": "surmonChinese",
    "text": "def surmonChinese(links):\n    raise Exception('do later')\n    import bs4\n    import html\n\n    def getLinks(n):\n        base = f\"https://surmon.me/article\"\n        soup = bs4.BeautifulSoup(request(base), \"html.parser\")\n        soup.find_all('links')\n\n    def runner(url):\n        text = request(url, delay=5)\n        if not text:\n            return \n\n        store = []\n        body = bs4.BeautifulSoup(text, \"html.parser\").body\n        for item in body.find_all(recursive=True):\n            name = item.name\n            if name in ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6']:\n                text = item.get_text()\n                if isChinese(text) or isEnglish(text):\n                    store.append((name, text))\n\n        return store\n\n    store = filter(map(links, runner))\n    return store\n\n\n"
  },
  {
    "name": "subprocessRun",
    "text": "def subprocessRun(s):\n    import subprocess\n    lines = linegetter(s)\n    dprint(lines)\n    kwargs = dict(stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)\n    for line in lines:\n        result = subprocess.run(line, **kwargs)\n        success = result.stdout.decode()\n        error = result.stderr.decode()\n        if result.returncode == 0:\n            dprint(success)\n        else:\n            dprint(line)\n            dprint(error)\n            return \n\n"
  },
  {
    "name": "compile_latex",
    "text": "def compile_latex(texFile):\n    initCommand = \"\"\"\n\n         sudo apt-get update\n         sudo apt-get install texlive-latex-base\n\n    \"\"\"\n    subprocessRun(initCommand)\n\n\n    if find_latex_packages_dir():\n        subprocessRun(\"sudo apt-get install texlive-latex-extra\")\n\n    pdfFile = changeExtension(texFile, 'pdf')\n    createCommand = f\"pdflatex {texFile}\"\n    subProcessRun(createCommand)\n\n    if isfile(pdfFile):\n        print('success')\n        ofile(pdfFile)\n\n"
  },
  {
    "name": "create_tex",
    "text": "def create_tex(file = 'document.tex'):\n    write(file, env.sampleTexText.strip())\n    return file\n"
  },
  {
    "name": "find_latex_packages_dir",
    "text": "def find_latex_packages_dir():\n    import subprocess\n    try:\n        output = subprocess.check_output([\"kpsewhich\", \"-var-value\", \"TEXMFMAIN\"])\n        return output.decode(\"utf-8\").strip()\n    except (subprocess.CalledProcessError, OSError):\n        print(\"Error: Could not find LaTeX packages directory.\")\n        return None\n\n"
  },
  {
    "name": "doLatex",
    "text": "def doLatex():\n    raise Exception('lock package is running... need to check it later')\n    print(\"cannot run at the moment or something may break\")\n    chdir(latexdir)\n    compile_latex(create_tex())\n"
  },
  {
    "name": "is_package_manager_locked",
    "text": "def is_package_manager_locked():\n    lock_file_path = '/var/lib/dpkg/lock'\n    if isfile(lock_file_path):\n        try:\n            open(lock_file_path, 'w')\n            return False\n        except IOError as e:\n            print(\"error\")\n            print(e)\n            return True\n    else:\n        return False\n"
  },
  {
    "name": "isAFile",
    "text": "def isAFile(name):\n    file = addExtension(name, 'js')\n    print(npath(file), isfile(file) or isfile(capitalize(file)))\n"
  },
  {
    "name": "blackify",
    "text": "def blackify(s):\n    import black\n\n    return black.format_str(\n        s,\n        mode=black.Mode(\n            target_versions={black.TargetVersion.PY36}\n        ),\n    )\n\n"
  },
  {
    "name": "block_to_browser",
    "text": "def block_to_browser(s, mode='text'):\n    # mode is implicit from visualBTB.dict\n    s = re.sub('\\\\\\\\n', '\\n', s)\n    if not s:\n        print(\"'no text early rert\")\n        return \n    if mode == 'text' or mode == 'clip':\n        write('temp.txt.js', s, open=1)\n    elif mode == 'email':\n        email(body=s)\n\n    elif mode == 'gdoc':\n        name = prompt('what is the name for this gdoc file?')\n        appscript('gdoc', name, s)\n\n\n"
  },
  {
    "name": "fixViteHtmlContent",
    "text": "def fixViteHtmlContent(s):\n    vuesrc = '<script src=\"vue.min.js\"></script>'\n    vuescriptsrc = '<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.6.14/vue.min.js\" integrity=\"sha512-XdUZ5nrNkVySQBnnM5vzDqHai823Spoq1W3pJoQwomQja+o4Nw0Ew1ppxo5bhF2vMug6sfibhKWcNJsG8Vj9tg==\" crossorigin=\"anonymous\" referrerpolicy=\"no-referrer\"></script>'\n    s = sub(s, vuesrc, vuescriptsrc)\n    def runner(s):\n        if s == 'js':\n            return './assets/main.js'\n        if s == 'css':\n            return './assets/style.css'\n        raise Exception(s)\n\n    s = sub(s, \"/assets.*?\\.(\\w+)(?=\\\")\", runner)\n    p = f\"<!-- Last Updated On {strftime()} --------------->\\n</html>\"\n    s = sub(s, '</html>', p)\n    return s\n"
  },
  {
    "name": "sayhi2023",
    "text": "def sayhi2023(x):\n    print(\"'hii'\")"
  },
  {
    "name": "download_google_fonts",
    "text": "def download_google_fonts():\n\n    def get_media(x):\n        \n        if isUrl(x):\n            r = requests.get(url, allow_redirects=True)\n            if r.status_code != 200:\n                raise Exception('not valid download')\n            return r.content\n        e = getExtension(x)\n        if e:\n            if isfile(x):\n                return read(x)\n\n    def write_media(outpath, data):\n        with open(outpath, 'wb') as f:\n            f.write(data)\n            print('successfully wrote to dldir:', outpath)\n    \n    fontdir2023 = dir2023 + 'fonts/'\n    fontfile = 'font.zip'\n\n    for font in fonts:\n        font_name = font.replace(' ', '+')\n        url = f'https://fonts.google.com/download?family={font_name}'\n    \n        dirname = dash_case(font)\n        outdir = fontdir2023 + dirname\n        dprompt(dirname, outdir)\n        data = get_media(url)\n        write_media(fontfile, data)\n        unzip(fontfile, mkdir(outdir))\n"
  },
  {
    "name": "unzipLatest",
    "text": "def unzipLatest():\n    f = glf()\n    readzip(\n        f,\n        flatten=True,\n        outpath=normpath(dldir, removeExtension(tail(f))),\n    )\n\n    return flatdir(mostRecent(dldir))\n\n"
  },
  {
    "name": "to_array",
    "text": "def to_array(x):\n    if isArray(x):\n        return x\n    return [x]\n\n"
  },
  {
    "name": "is_empty",
    "text": "def is_empty(x):\n    if x == 0:\n        return False\n\n    if not x:\n        return True\n\n    if isinstance(x, (list, tuple, set, frozenset, dict)):\n        return not bool(x)\n\n    return len(x) == 0\n\n"
  },
  {
    "name": "early_return",
    "text": "def early_return(fn):\n    def wrapper(*args, **kwargs):\n        if is_empty(args[0]):\n            print(\"early return @ empty result\")\n            return\n        result = fn(*args, **kwargs)\n        return result\n\n    return wrapper\n\n"
  },
  {
    "name": "clipsave",
    "text": "def clipsave(s):\n    appendjson(\"clip.json\", [s])\n\n"
  },
  {
    "name": "smart_manager",
    "text": "def smart_manager():\n\n    file = glf()\n    ifiz\n    return\n\n    def runner(item, key):\n        q = item.get(key)\n        if q and test(\"^\" + q, getattr(state, key)):\n            return True\n\n    keys = [\"name\", \"extension\", \"tail\", \"file\"]\n    for item in smartItems:\n        for key in keys:\n            if runner(item, key):\n                return item[\"fn\"](state)\n\n"
  },
  {
    "name": "appendVim",
    "text": "def appendVim(value, name=\"temp\"):\n    value = dumpJson(value)\n    s = f\"let g:{name} = {value}\"\n    append(\"/home/kdog3682/.vimrc\", s)\n\n"
  },
  {
    "name": "prompt3",
    "text": "def prompt3(message = 'prompt3', items = 0, fallback = ''):\n    if items:\n        assert items\n    os.system(\"clear\")\n    if items:\n        number(items)\n    message += ':'\n    message += '\\n\\n'\n    blue(message)\n    return input('') or fallback\n"
  },
  {
    "name": "antichoose",
    "text": "def antichoose(items):\n\n    message = 'anti choose 1 based indexes'\n    a = prompt3(message = message, items = items)\n\n    if not a:\n        return items\n    indexes = [int(n) - 1 for n in a.strip().split(\" \")]\n\n    store = []\n    for i, item in enumerate(items):\n        if i not in indexes:\n            store.append(item)\n    return store\n\n"
  },
  {
    "name": "pyargs",
    "text": "def pyargs(file=\"base.py\"):\n    name = getExtension(file) + \"args\"\n    items = antichoose(\n        fa(file, \"\\(([a-z]\\w*)\\)\", filter=\"<9\")\n    )\n    appendVim(items, name=name)\n\n"
  },
  {
    "name": "toString",
    "text": "def toString(s):\n    import inspect\n    if isFunction(s):\n        return inspect.getsource(s)\n    return str(s)\n\n"
  },
  {
    "name": "fa",
    "text": "def fa(s, r, flags=0, **kwargs):\n\n    s = textgetter(s)\n    m = re.findall(r, s, flags=flags)\n    if kwargs.get(\"filter\"):\n        m = filter(m, kwargs.get(\"filter\"))\n    m = unique(m)\n\n    if kwargs.get(\"choose\"):\n        m = antichoose(m)\n\n    if kwargs.get(\"fn\"):\n        m = map(m, kwargs.get(\"fn\"))\n\n    if kwargs.get(\"map\"):\n        m = map(m, kwargs.get(\"map\"))\n\n    if kwargs.get(\"filter\"):\n        m = filter(m, kwargs.get(\"filter\"))\n\n    if kwargs.get(\"append\"):\n        if kwargs.get(\"append\") == \"self\":\n            appendVariable(dumpJson(m))\n\n    if kwargs.get(\"clip\"):\n        clip(m)\n\n    if kwargs.get(\"save\"):\n        prompt(m)\n        append(currentFile(), join(m))\n    pprint(m)\n    return m\n\n"
  },
  {
    "name": "map",
    "text": "def map(items, x):\n    f = x\n    if isString(x):\n        x = x.strip()\n        f = lambda arg: templater(x, [arg])\n\n    return [f(el) for el in items]\n\n"
  },
  {
    "name": "filter2",
    "text": "def filter2(items, x=exists):\n    f = x\n    if isString(x):\n        if test(\"^[<>=]\", x):\n            f = eval(f\"lambda x: len(x) {x}\")\n        else:\n            f = eval(f\"lambda x: {x}\")\n\n    return [el for el in items if f(el)]\n\n"
  },
  {
    "name": "is_",
    "text": "def is_$1(s):\n    return getExtension(s) == \"$1\""
  },
  {
    "name": "is_javascript",
    "text": "def is_javascript(s):\n    return getExtension(s) == \"js\"\n\n"
  },
  {
    "name": "is_zip",
    "text": "def is_zip(s):\n    return getExtension(s) == \"zip\"\n\n"
  },
  {
    "name": "is_css",
    "text": "def is_css(s):\n    return getExtension(s) == \"css\"\n\n"
  },
  {
    "name": "is_python",
    "text": "def is_python(s):\n    return getExtension(s) == \"py\"\n\n"
  },
  {
    "name": "is_html",
    "text": "def is_html(s):\n    return getExtension(s) == \"html\"\n\n"
  },
  {
    "name": "dictf",
    "text": "def dictf(ref):\n    def f(k):\n        fn = getattr(ref, k, getattr(ref, \"default\", None))\n        params = count_params(fn)\n        return fn, params\n\n    cache = Cache(f)\n\n    def runner(k, v):\n        try:\n            fn, params = cache.get(k)\n            return fn(k) if params == 1 else fn(v, k)\n        except Exception as e:\n            prompt(error=str(e))\n            print(\"---------------\")\n            print(str(e))\n            print(\"error\")\n            dprint(k, v)\n            input(\"throw please\")\n            input(\"throw please\")\n            input(\"throw please\")\n            print(\"---------------\")\n\n    return runner\n"
  },
  {
    "name": "hasValue",
    "text": "def hasValue(x = None):\n    if x == None or x == False:\n        return False\n    return True\n"
  },
  {
    "name": "fparse",
    "text": "def fparse(fn, *args):\n    if not fn:\n        return args[0]\n    elif isFunction(fn):\n        value = fn(*args)\n        if hasValue(value):\n            return value\n        return args[0]\n    else:\n        return fn[0]\n        \n"
  },
  {
    "name": "dictf",
    "text": "def dictf(ref, fallback = None):\n    def runner(item):\n        return ref.get(item, fparse(fallback, item)) or item\n    return runner\n            "
  },
  {
    "name": "lines",
    "text": "def lines(s, ref=0):\n    s = s.strip()\n    lines = map(s.split(\"\\n\"), trim)\n    if test(\"^ *\\w+:\", s, flags=re.M):\n        lines = map(lines, lambda x: splitonce(x, \" *: *\"))\n\n    if ref:\n        f = dictf(ref)\n        lines = [f(*el) for el in lines]\n\n    return lines\n\n"
  },
  {
    "name": "fn",
    "text": "def fn(key, value):\n    unit = 'pt'\n        case 'margin':\n        case 'padding':\n            const numbers = getNumbers(b)\n            return DIRECTIONS.forEach((d, i) => {\n                dirLetter = d[0]\n                nameLetter = key[0]\n                name = nameLetter + dirLetter\n                store.push(name, d + '-')\n            })\n        case 'colors':\n        case 'rel':\n        case 'abs':\n        case 'grid':\n        case 'directions':"
  },
  {
    "name": "count_params",
    "text": "def count_params(f):\n    data = inspect.signature(f)\n    return len(data.parameters)\n\n"
  },
  {
    "name": "hashbang",
    "text": "def hashbang(filename):\n    assert isfile(filename)\n    # Add a hashbang line to the file if it doesn't already have one\n    with open(filename, \"r\") as f:\n        first_line = f.readline().strip()\n\n    if not first_line.startswith(\"#!\"):\n        print(\"adding hasbang line\")\n        with open(filename, \"r+\") as f:\n            content = f.read()\n            f.seek(0, 0)\n            f.write(\"#!/usr/bin/env python3\\n\" + content)\n\n    # Set the execute permission for the file\n    os.chmod(filename, 0o755)\n\n"
  },
  {
    "name": "git_push_dir",
    "text": "def git_push_dir(dir):\n\n    names = gitNames(dir)\n    mainCommand = f\"\"\"\n        cd {dir}\n        git add .\n        git commit -m \"'message'\"\n        git push\n    \"\"\"\n\n    response = SystemCommand(mainCommand, dir=dir)\n    gitData = {\n        \"success\": response.success,\n        \"error\": response.error,\n    }\n\n    pprint(gitData)\n    pprint(names)\n\n"
  },
  {
    "name": "dprompt",
    "text": "def dprompt(*variables, **kwargs):\n\n    strings = []\n    caller = getCaller()\n    store = OrderedDict()\n    store[\"caller\"] = caller\n\n    for v in variables:\n        try:\n            vars = (\n                inspect.currentframe().f_back.f_locals.items()\n            )\n            name = [\n                v_name\n                for v_name, v_val in vars\n                if v_val is v\n            ][0]\n            store[name] = v\n        except Exception as e:\n            strings.append(v)\n\n    for a, b in kwargs.items():\n        store[a] = b\n\n    if strings:\n        store[\"strings\"] = strings\n\n    pprint(store)\n    return input(\"\")\n\n"
  },
  {
    "name": "gitNames",
    "text": "def gitNames(dir):\n    s = SystemCommand(\"git status --short\", dir=dir).success\n    pairs = unique(re.findall(\"(\\S+) (\\w+(?:\\.\\w+)+)\", s))\n    store = [[], []]\n    for a, b in pairs:\n        if a == \"M\":\n            store[0].append(b)\n        else:\n            store[1].append(b)\n    a, b = store\n    return {\n        \"modified\": a,\n        \"created\": b,\n    }\n\n"
  },
  {
    "name": "mwrite",
    "text": "def mwrite(inpath, outpath, regex, flags=0):\n    inpath = smart_path(inpath)\n    outpath = smart_path(outpath, inpath)\n    text = read(inpath)\n    assert text\n\n    a, payload = mget(regex, text, flags=flags, mode=list)\n    assert payload\n\n    append(outpath, payload)\n    cfile(inpath, \"temp.py\")\n    write(inpath, a)\n\n"
  },
  {
    "name": "smart_path",
    "text": "def smart_path(file, refpath=0):\n    if file == 'vimrc':\n        return \"/home/kdog3682/.vimrc\" \n    if refpath:\n        dir = dirFromFile(refpath)\n        file = addExtension(file, getExtension(refpath))\n        alert(dir, file)\n    else:\n        dir = dirFromFile(file)\n    return npath(dir, file)\n\n"
  },
  {
    "name": "tesseractExtractText",
    "text": "def tesseractExtractText(imageFile):\n    from PIL import Image\n    import pytesseract\n\n    return pytesseract.image_to_string(\n        Image.open(imageFile)\n    )\n\n"
  },
  {
    "name": "foo1682173868",
    "text": "def foo1682173868():\n    \"\"\"\n    google -> clip -> delete based on comments = delete\n    googleclip\n    \"\"\"\n\n    files = clip()\n    chdir(pydir)\n    for file in files:\n        if file.get(\"comments\").startswith(\"dele\"):\n            rfile(file.get(\"name\"))\n\n"
  },
  {
    "name": "get_media",
    "text": "def get_media(x):\n\n    if isUrl(x):\n        r = requests.get(url, allow_redirects=True)\n        if r.status_code != 200:\n            raise Exception(\"not valid download\")\n        return r.content\n    e = getExtension(x)\n    if e:\n        if isfile(x):\n            return read(x)\n\n"
  },
  {
    "name": "write_media",
    "text": "def write_media(outpath, data):\n    with open(outpath, \"wb\") as f:\n        f.write(data)\n        print(\"successfully wrote to dldir:\", outpath)\n\n"
  },
  {
    "name": "download_google_fonts",
    "text": "def download_google_fonts():\n\n    fontdir2023 = dir2023 + \"fonts/\"\n    fontfile = \"font.zip\"\n\n    for font in fonts:\n        font_name = font.replace(\" \", \"+\")\n        url = f\"https://fonts.google.com/download?family={font_name}\"\n\n        dirname = dash_case(font)\n        outdir = fontdir2023 + dirname\n        dprompt(dirname, outdir)\n        data = get_media(url)\n        write_media(fontfile, data)\n        unzip(fontfile, mkdir(outdir))\n\n"
  },
  {
    "name": "dash_case",
    "text": "def dash_case(s):\n    items = re.split(\"\\W|(?=[A-Z]+[a-z])\", s)\n    return join(filter(items), delimiter=\"-\").lower()\n\n"
  },
  {
    "name": "foo1682177487",
    "text": "def foo1682177487(r, type=str):\n    \"\"\"\n    collectGlobalVariables\n    \"\"\"\n\n    store = {}\n    dir_vars = [var for var in globals() if test(r, var)]\n    for var in dir_vars:\n        value = globals().get(var)\n        if isinstance(value, type):\n            store[var] = value\n\n    if store:\n        appendVariable(dumpJson(store))\n\n"
  },
  {
    "name": "strftime",
    "text": "def strftime(strife=0):\n    strife = \"%A %B %d %Y, %-I:%M:%S%p\"\n    return datetime.now().strftime(strife)\n\n"
  },
  {
    "name": "coerceToObject",
    "text": "def coerceToObject(x):\n    return x if isObject(x) else {\"value\": x}\n\n"
  },
  {
    "name": "ensure_object",
    "text": "def ensure_object(func):\n    def decorator(self, obj, *args, **kwargs):\n        return func(\n            self, coerceToObject(obj), *args, **kwargs\n        )\n\n    return decorator\n\n"
  },
  {
    "name": "empty",
    "text": "def empty(x, key=0):\n    if not key:\n        return x == None or len(x) == 0\n    try:\n        return not hasattr(x, key)\n    except Exception as e:\n        return x == None or len(x) == 0\n\n"
  },
  {
    "name": "info",
    "text": "def info(var):\n    var_info = {}\n    var_info[\"class_instance\"] = type(var)\n    var_info[\"type\"] = type(var).__name__\n    var_info[\"type_str\"] = str(type(var))\n    var_info[\"name\"] = var.__class__.__name__\n    var_info[\"constructor\"] = var.__init__.__func__\n    return var_info\n\n"
  },
  {
    "name": "t2s",
    "text": "def t2s(x):\n    return type(x).__name__\n    return x.__class__.__name__\n\n"
  },
  {
    "name": "isObjectArray",
    "text": "def isObjectArray(x):\n    return isArray(x) and isObject(x[0])\n\n"
  },
  {
    "name": "makeRE",
    "text": "def makeRE(s):\n    r = s.strip()\n    r += \"([\\w\\W]+?)\"\n    r += \"^#? *(?:\\d{6,}|\\d\\d\\D\\d\\d\\D\\d\\d\\d\\d)\"\n    return r\n\n"
  },
  {
    "name": "fn",
    "text": "def fn(file):\n    fileName = filePrompt(\n        dir=resourcedir, e=\"txt\", fallback=\"temp\", ref=file\n    )\n    s = \"^04-13-2023 Code for Kids\"\n    r = makeRE(s)\n    s = search(makeRE(s), read(file), flags=re.M).strip()\n    write(fileName, s)\n\n"
  },
  {
    "name": "filePrompt",
    "text": "def filePrompt(dir=\"\", e=\"\", fallback=\"temp\", ref=0):\n    if not dir and ref:\n        dir = head(ref)\n\n    if not e and ref:\n        e = getExtension(ref)\n    name = (\n        prompt(dir=dir, message=\"name for file?\")\n        or fallback\n    )\n    name = addExtension(name, e)\n    name = os.path.join(dir, name)\n    logfile(name)\n    return name\n\n"
  },
  {
    "name": "logfile",
    "text": "def logfile(x):\n    if isArray(x):\n        s = join(map(x, lambda x: datestamp() + \" \" + x))\n        append(\"files.txt\", s)\n        print(\"append to log file\", s)\n    else:\n        print(\"logging file\", x, \"to\", \"files.txt\")\n        append(\"files.txt\", datestamp() + \" \" + x)\n\n"
  },
  {
    "name": "copy_dir_to_dir",
    "text": "def copy_dir_to_dir(f):\n    cfile(cmdir + f, dir2023)\n\n"
  },
  {
    "name": "map",
    "text": "def map(items, fn, *args, filter=1, **kwargs):\n    _promptOnce = kwargs.pop('promptOnce', None)\n    if not items:\n        return []\n\n    if isString(fn):\n        _key = fn\n\n        arg = toArray(items)[0]\n        if isClassObject(arg):\n            prompt('aa')\n            fn = lambda x: getattr(x, _key)\n        elif isObject(arg):\n            fn = lambda x: x.get(_key)\n        elif \"$\" in _key:\n            fn = lambda x: templater(_key.strip(), [x])\n        else:\n            fn = lambda x: search(_key, x)\n\n    if isNestedArray(items):\n        return [fn(a, b) for a, b in items]\n\n    if isObject(items):\n        store = {}\n        for k, v in items.items():\n            value = fn(k, v)\n            if value:\n                store[k] = value\n            elif filter:\n                continue\n            else:\n                store[k] = v\n        return store\n\n    store = []\n    for i, item in enumerate(toArray(items)):\n        try:\n            value = fn(item, *args, **kwargs)\n            if not (filter and not value):\n                if i == 0 and _promptOnce:\n                    promptOnce(value, _promptOnce)\n                store.append(value)\n        except Exception as e:\n            prompt(item, error=\"ERROR AT MAP\", message=e)\n            continue\n    return store\n\n\n"
  },
  {
    "name": "isClassObject",
    "text": "def isClassObject(x):\n    return type(x) not in env.builtins\n"
  },
  {
    "name": "first",
    "text": "def first(x):\n    return x.values()[0] if isObject(x) else x[0]\n\n"
  },
  {
    "name": "node_dir_search",
    "text": "def node_dir_search(*args, root=\"@codemirror\"):\n    path = os.path.join(npmdir, root, *args)\n    files = os.listdir(path)\n    if \"dist\" in files:\n        files = os.listdir(os.path.join(path, \"dist\"))\n    if \"index.js\" in files:\n        path = os.path.join(path, \"dist\", \"index.js\")\n        return ofile(path)\n        cfile(path, os.path.join(dir2023, \"commands.js\"))\n\n"
  },
  {
    "name": "getdir",
    "text": "def getdir(*args):\n    ff(os.path.join(*args), isdir=1)\n\n"
  },
  {
    "name": "github_content_url",
    "text": "def github_content_url(user, repo, file, master=\"master\"):\n    base = \"https://raw.githubusercontent.com\"\n    return f\"{base}/{user}/{repo}/{master}/{file}\"\n\n"
  },
  {
    "name": "textgetter",
    "text": "def textgetter(x):\n    if isArray(x):\n        return x\n    if x == \"self\":\n        return read(currentFile())\n    if len(x) > 100:\n        return x\n    if isGithubUrl(x):\n        user, repo, file = x.split(\"/\")[-3:]\n        dprompt(user, repo, file)\n        url = github_content_url(user, repo, file, \"master\")\n        s = request(url)\n        if s == None:\n            url = github_content_url(\n                user, repo, file, \"main\"\n            )\n            s = request(url)\n            if s == None:\n                raise Exception(\n                    \"tried master & main -> both none\"\n                )\n        return s\n    if isUrl(x):\n        return request(x)\n    if isfile(normDirPath(x)):\n        return normRead(x)\n    return x\n\n"
  },
  {
    "name": "request",
    "text": "def request(url):\n    import requests\n    r = requests.get(\n        fixUrl(url), {\"user-agent\": env.BROWSER_AGENT}\n    )\n    if r.status_code == 200:\n        return parseJSON(r.text)\n    else:\n        return None\n\n"
  },
  {
    "name": "removeComments",
    "text": "def removeComments(s):\n    r = \"^ *(?:<!--|#|//).+\\n*\"\n    return re.sub(r, \"\", s, flags=re.M)\n\n"
  },
  {
    "name": "npm",
    "text": "def npm(s, dir=cm2dir):\n    dir = dir2023\n    items = (\n        split(removeComments(s), \"\\s+\")\n        if isString(s)\n        else s\n    )\n    cmd = join(items, delimiter=\" \")\n    cmd = \"npm i \" + cmd\n    prompt(npmcmd=cmd, dir=dir)\n    SystemCommand(cmd, dir=dir)\n    printdir(npmdir)\n\n"
  },
  {
    "name": "isGithubUrl",
    "text": "def isGithubUrl(x):\n    return \"https://github\" in x\n\n"
  },
  {
    "name": "ffstring",
    "text": "def ffstring(s):\n    ref = {\n        \"j\": \"json\",\n        \"c\": [\"mode\", \"partition\"],\n        \"res\": [\"mode\", \"transfer-to-resources\"],\n    }\n\n    def f(k):\n        val = ref.get(k, k)\n        if isArray(val):\n            return val\n        return val\n\n    kwargs = reduce(split(s, \" \"), f)\n    kwargs[\"partition\"] = True\n\n    ff(dir2023, **kwargs)\n\n"
  },
  {
    "name": "review",
    "text": "def review(files=0, move=0, mode=0, **kwargs):\n    if not files:\n        files = absdir(dir2023)\n    if not kwargs:\n        kwargs = {\n            'js': 1,\n            'days': 10,\n        }\n    files = ff(files, **kwargs)\n    if not files:\n        print('no files ... early return')\n        return \n\n    removed = []\n    moved = []\n    saved = []\n    os.system(\"clear\")\n\n    for file in files:\n        if alwaysDelete(file):\n            removed.append(files)\n            continue\n\n        a = prompt(fileInfo(file))\n        if a == \"d\":\n            removed.append(files)\n        elif a:\n            saved.append(files)\n            \n    dprompt(removed, saved)\n    clip(saved)\n    map(removed, rfile)\n"
  },
  {
    "name": "old",
    "text": "def old(s):\n    ofile(budir + s)\n"
  },
  {
    "name": "getObservableInitialDataFromLink",
    "text": "def getObservableInitialDataFromLink(url):\n    s = request(url)\n    r = '<script id=\"__NEXT_DATA__\" type=\"application/json\">([\\w\\W]+?)</script>'\n    m = search(r, s)\n    data = parseJSON(m)\n    return data\n    #s = srequest('https://observablehq.com/@d3/zoomable-circle-packing')\n"
  },
  {
    "name": "parseObservableData",
    "text": "def parseObservableData(data):\n    \n    data = data.get('props').get('pageProps').get('initialNotebook')\n    files = data.get('files')\n    nodes = data.get('nodes')\n    values = []\n    nodes = filter(nodes, lambda x: not test('^md', x.get('value')))\n    def sorter(x):\n        value = x.get('value')\n        return len(value)\n        score = 0\n        pinned = x.get('pinned')\n        id = x.get('id')\n        if pinned:\n            score += 100\n\n        score += int(id)\n        return score\n    \n    nodes.sort(key=sorter)\n    def mapper(node):\n        value = node.get('value')\n        #if test('a', b):\n        return value\n    nodes = map(nodes, mapper)\n    prompt(nodes)\n    prompt(files)\n\n    #files = map(files, 'url')\n    #pprint(nodes)\n    #pprint(files)\n\n"
  },
  {
    "name": "fo1",
    "text": "def fo1(a, b):\n\n    ref = {\n        '1': 'standard',\n        'del': 'delete',\n        'd': 'delete',\n        'clear': 'clear',\n    }\n    m = search('^(?:1|del|d|clear)$', b)\n    if m:\n        return ['mode', ref[m]]\n\n    m = search('rn (\\S+)', b)\n    if m:\n        if '$' in m:\n            m = m.replace('$', a)\n        return ['rename', m]\n\n    return ['comment', m]\n"
  },
  {
    "name": "mergejson",
    "text": "def mergejson(file, data):\n    if not data: \n        return \n    prev = read(file) or {}\n    for k,v in data.items():\n        if k in prev:\n            if isArray(v):\n                prev[k].extend(v)\n            else:\n                prev[k].update(v)\n        else:\n            prev[k] = v\n    write(file, prev)\n"
  },
  {
    "name": "file_table_action",
    "text": "def file_table_action():\n\n    def fo2(a, b):\n        c, d = fo1(a, b)\n        return {'file': a, c: d}\n\n    data=clip()\n    r = '^\\S+ *(\\S+)(?: +(.+))?'\n    #data = fa('file-table.txt', r, flags=re.M, fn=fo2)\n    prompt(data=data)\n    standard = []\n    current = []\n    for item in data:\n        mode = item.get('mode')\n        file = item.get('file')\n        if mode == 'delete':\n            rfile(file)\n\n        elif mode == 'standard':\n            standard.append(file)\n\n        elif item.get('rename'):\n            mfile(file, item.get('rename'))\n        else:\n            current.append(file)\n\n    current.sort()\n    standard.sort()\n    payload = {\n        'standard': standard,\n        'items': [\n            {'date': datestamp(), 'current': current}\n        ]\n    }\n    mergejson('files.json', payload)\n"
  },
  {
    "name": "prosemirrorFileTable",
    "text": "def prosemirrorFileTable():\n    \n    def g(dir):\n        files = ff(dir, recursive=1, js=1)\n        if tail(files[0]) == 'index.es.js':\n            return [files[0]]\n        return files\n\n    dirs = ff(npmdir, name='^prose')\n    dirs = map(dirs, g)\n    files = flat(dirs)\n    write('pm-file-table.txt', join(files))\n"
  },
  {
    "name": "github_usercontent_url",
    "text": "def github_usercontent_url(user, repo, *args, master='master'):\n    base = 'https://raw.githubusercontent.com'\n    file = '/'.join(args)\n    return f\"{base}/{user}/{repo}/{master}/{file}\"\n"
  },
  {
    "name": "manim",
    "text": "def manim():\n    arg = choose(env.manimToc)\n    ofile(github_usercontent_url('3b1b', 'manim', arg[0]))\n\n\n"
  },
  {
    "name": "longstamp",
    "text": "def longstamp():\n    strife = \"%A %B %d %Y, %-I:%M:%S%p\"\n    return datestamp(strife=strife)\n"
  },
  {
    "name": "mdir",
    "text": "def mdir(source_dir, dest_dir):\n    if not os.path.exists(dest_dir):\n        os.makedirs(dest_dir)\n\n    for item in os.listdir(source_dir):\n        source = os.path.join(source_dir, item)\n        destination = os.path.join(dest_dir, item)\n        print('moving', item)\n\n        if os.path.isfile(destination):\n            a = input(f\"Do you want to overwrite {destination}? (y/n): \")\n            if a.lower() == 'n':\n                continue\n\n        shutil.move(source, destination)\n\n    shutil.rmtree(source_dir)\n    print('done')\n"
  },
  {
    "name": "generate_markdown_toc",
    "text": "def generate_markdown_toc():\n    file = 'markdown-toc.json'\n    def runner(file):\n        print('file', file)\n\n    with Save(file, []) as prev:\n        prevFiles = map(prev, 'name')\n        g = lambda x: tail(x) not in prevFiles\n        files = filter(absdir(markdowndir), g)\n        data = map(files, runner)\n        prev.extend(data)\n        prompt(prev=prev)\n"
  },
  {
    "name": "moveChangeLogFile",
    "text": "def moveChangeLogFile():\n    changelogfile = '/home/kdog3682/2023/changelog.md'\n    url = f\"{markdowndir}me.{datestamp()}.md\"\n    mfile(changelogfile, url)\n\n"
  },
  {
    "name": "push",
    "text": "def push(store, x):\n    if x != None:\n        store.append(x)\n\n"
  },
  {
    "name": "ignoreFile",
    "text": "def ignoreFile(name):\n    r = '^(?:\\W)|license|readme|rc|ignore'\n    return test(r, name, flags=re.I)\n\n"
  },
  {
    "name": "createLogger",
    "text": "def createLogger():\n\n    import logging\n\n    logging.basicConfig(filename='logging.txt', level=logging.INFO,\n        format='%(message)s')\n\n    logger = logging.getLogger()\n\n    def log(*args):\n        s = ' '.join(map(list(args), str))\n        return logger.info(s)\n    return log\n"
  },
  {
    "name": "renameClipToDriveFile",
    "text": "def renameClipToDriveFile():\n    newName = prompt('name for drive clip file?')\n    cfile(clipfile, drivedir + newName)\n"
  },
  {
    "name": "ask_reddit",
    "text": "def ask_reddit(s):\n    import redditscript\n    r = redditscript.Reddit()\n    try:\n        print(r.askString(s))\n    except Exception as e:\n        print(str(e))\n    "
  },
  {
    "name": "toArray",
    "text": "def toArray(x):\n    if not x:\n        return []\n    if isArray(x):\n        return x\n    if isString(x):\n        return split(x, \"\\n\")\n    return [x]\n\n"
  },
  {
    "name": "removeStartingComments",
    "text": "def removeStartingComments(s):\n    return re.sub('^#.*\\n*', '', s, flags = re.M)\n"
  },
  {
    "name": "removeSmallFiles",
    "text": "def removeSmallFiles(files):\n    for file in files:\n        if isfile(file) and fsize(file) < 50:\n            rfile(file)\n"
  },
  {
    "name": "parseDiff",
    "text": "def parseDiff(dir):\n    result = SystemCommand('git status --short', dir=dir)\n    r = '^ *(\\?\\?|M) (.+)'\n    m = re.findall(r, result.success, flags=re.M)\n    if not m:\n        return \n\n    modified = []\n    created = []\n    for a,b in m:\n        if a == '??':\n            created.append(b)\n        else:\n            modified.append(b)\n\n    date = datestamp()\n    payload = {'date': datestamp()}\n    if modified: payload['modified'] = modified\n    if created: payload['created'] = created\n    payload['directory'] = dir\n    appendjson('/home/kdog3682/2023/git-data3.json', payload, mode=list)\n"
  },
  {
    "name": "gitPush",
    "text": "def gitPush(dir):\n    mainCommand = f\"\"\"\n        cd {dir}\n        git add .\n        git commit -m \"'autopush'\"\n        git push\n    \"\"\"\n\n    if dir == dir2023:\n        parseDiff(dir=dir)\n\n    # git push -f origin master\n    # use this when there is an error about different work\n\n    SystemCommand(mainCommand, dir=dir, printIt=1)\n"
  },
  {
    "name": "removable",
    "text": "def removable(f):\n    ignore = [\n        \"gitignore\",\n    ]\n\n    if isfile(f) and fsize(f) < 50:\n        if tail(f) not in ignore:\n            rfile(f)\n\n    return True\n"
  },
  {
    "name": "FixGitCache",
    "text": "def FixGitCache():\n    SystemCommand('''\n        #git rm --cached -r\n        #git add .\n        #git commit -m \"Fixed .gitignore not ignoring files\"\n        #git push\n    ''')\n    print('Git Cache has been fixed. The next push will see these changes in action.')\n\n\n\n\n\n"
  },
  {
    "name": "moveRecentlyDownloadedFileToDrive",
    "text": "def moveRecentlyDownloadedFileToDrive(name):\n\n    def drivepath(file, ext):\n        return f\"{drivedir}{name}.{timestamp()}.{getExtension(ext)}\"\n\n    file = glf(dldir)\n    outpath = drivepath(name, ext=file)\n    dprompt(outpath)\n    mfile(file, outpath)\n"
  },
  {
    "name": "cleanupDldir",
    "text": "def cleanupDldir():\n    chdir(dldir)\n    files = os.listdir()\n    \n    print(files)\n    #cleanupDldir()\n\n    #Do it via javascript and server ... yes.\n"
  },
  {
    "name": "foo",
    "text": "def foo():\n    print('hi')\n\n"
  },
  {
    "name": "sysArg",
    "text": "def sysArg():\n    try:\n        return toArgument(sys.argv[1])\n    except Exception as e:\n        return \n    \n"
  },
  {
    "name": "sysArgs",
    "text": "def sysArgs():\n    base = sys.argv[1:]\n    length = len(base)\n    if length == 0:\n        return ['', []]\n    if length == 1:\n        return [base[0], []]\n    return [base[0], base[1:]]\n"
  },
  {
    "name": "runModule",
    "text": "def runModule(module=0):\n    \n    data = None\n    with Silence(True):\n        arg, args = sysArgs()\n\n        if not arg:\n            return\n\n        fn = None\n        if module:\n            if hasattr(module, arg):\n                fn = getattr(module, arg)\n        else:\n            fn = globals().get(arg, None)\n\n        if fn:\n            try:\n                data = {'success': fn(*args)}\n            except Exception as e:\n                error = {\n                    \"type\": type(e).__name__,\n                    \"message\": str(e),\n                    \"stack\": traceback.format_exc()\n                }\n                data = {'error':  error}\n\n    return json.dumps(data)\n\n"
  },
  {
    "name": "backupFolder",
    "text": "def backupFolder(dir):\n    dir = dirgetter(dir)\n    for file in absdir(dir):\n        cfile(file, budir)\n"
  },
  {
    "name": "seeBackup",
    "text": "def seeBackup(file):\n    file = f\"{budir}{file}.backup\"\n    print(read(file))\n"
  },
  {
    "name": "driveWrite",
    "text": "def driveWrite(file, s):\n     write(drivedir + addExtension(file, 'py'), s)\n"
  },
  {
    "name": "npath",
    "text": "def npath(dir=0, file=0):\n    if isArray(file):\n        return map2(file, lambda x: npath(dir, x))\n    if not dir:\n        return file\n    elif not file:\n        return npath(dirFromFile(dir), dir)\n    if isfile(dir):\n        if not getExtension(file):\n            file = addExtension(file, getExtension(dir))\n        dir = head(dir)\n    return os.path.join(dirGetter(dir), tail(file))\n"
  },
  {
    "name": "gitCloneAndMove",
    "text": "def gitCloneAndMove(repoUrl, move=1):\n    repoUrl = search('.*?github.com/[\\w-]+/[\\w-]+', repoUrl)\n    name = repoUrl.split('/')[-1]\n    #dprompt(repoUrl, name)\n    SystemCommand(f'''\n        cd {dldir}\n        git clone {repoUrl}\n    ''')\n\n\n    dir = npath(dldir, name)\n    save(dir)\n\n    if not move:\n        return \n    if not isdir(dir):\n        return \n\n    src = os.path.join(dir, 'src')\n    if not isdir(src):\n        src = dir\n    files = getFiles(src)\n    newdir = f'Git Repo - {name}'\n    newdir = npath(dldir, newdir)\n    shutil.move(src, newdir)\n    rmdir(dir, force=1)\n"
  },
  {
    "name": "createKwargs",
    "text": "def createKwargs(s, ref, aliases):\n    if not s:\n        return {}\n\n    r = \"(\\S+?) *= *(\\S+?)(?= |$)\"\n    s, items = mreplace(r, s)\n    s = dreplace(s, ref, template=\"(?<![\\w=])(?:$1)\\\\b\")\n    s, moreItems = mreplace(r, s)\n\n    aliaser = aliaserf(aliases)\n\n    A = {aliaser(k) : toArgument(v) for k, v in items}\n    B = {aliaser(k): True for k in split(s, \" \")}\n    C = {aliaser(k) : toArgument(v) for k, v in moreItems}\n    return mergeToObject(A, B, C)\n"
  },
  {
    "name": "mergeToObject",
    "text": "def mergeToObject(*args):\n    store = {}\n    for arg in args:\n        if isArray(arg):\n            prompt(arg)\n            store[arg[0]] = arg[1]\n        elif isObject(arg):\n            store.update(arg)\n        else:\n            warn('arg can only be array or object', arg)\n    return store\n\n\n"
  },
  {
    "name": "toArgument",
    "text": "def toArgument(x):\n    if isNumber(x):\n        return int(x)\n    if test('^(?:\"\"|\\'\\')$', x.strip()):\n        return ''\n    return x\n"
  },
  {
    "name": "aliaserf",
    "text": "def aliaserf(dict):\n    def runner(k):\n        return dict.get(k, k)\n    return runner\n"
  },
  {
    "name": "getFilesWrapper",
    "text": "def getFilesWrapper(s):\n\n    aliases = {\n        'small': 'smallerThan',\n        'big': 'biggerThan',\n    }\n\n    ref = {\n        \"backup\": \"dir=pub after=8pm js=1 copy=bu\",\n        \"i\": \"ignore\",\n        \"budir\": \"dir=bu\",\n        \"old\": \"old=1\",\n        \"budir\": \"dir=bu\",\n        \"pdfjson\": \"json=1\",\n        \"root\": \"dir=root\",\n        \"pdf\": \"pdf=1\",\n        \"5pm\": \"after=5pm\",\n        \"6pm\": \"after=6pm\",\n        \"7pm\": \"after=7pm\",\n        \"8pm\": \"after=8pm\",\n        \"9pm\": \"after=9pm\",\n        \"10pm\": \"after=10pm\",\n        \"11pm\": \"after=11pm\",\n        \"midnight\": \"after=12am\",\n        \"noon\": \"after=12pm\",\n        \"1pm\": \"after=1pm\",\n        \"2pm\": \"after=2pm\",\n        \"3pm\": \"after=3pm\",\n        \"4pm\": \"after=4pm\",\n        \"pub\": \"dir=pub\",\n        \"cwf\": \"dir=cwf\",\n        \"dl\": \"dir=dl\",\n        \"c\": \"copy\",\n        \"cp\": \"copy\",\n        \"debug\": \"mode=debug\",\n        \"open\": \"mode=open\",\n        \"o\": \"mode=open\",\n        \"d\": \"mode=debug\",\n        \"n\": \"name\",\n        \"r\": \"mode=review\",\n        \"today\": \"date=today\",\n        \"t\": \"text\",\n        \"ye\": \"date=yesterday\",\n        \"sm\": \"small=2000\",\n        \"small\": \"small=2000\",\n        \"this\": \"date=today\",\n        \"tf\": \"testfunction\",\n        \"mv\": \"move\",\n        \"of\": \"onlyFiles=1\",\n        \"h\": \"html\",\n        \"i\": \"mode=info\",\n        \"s\": \"mode=save\",\n        \"big\": \"big=100000\",\n    }\n\n    kwargs = createKwargs(s, ref, aliases)\n    files = getFiles(dir2023, **kwargs)\n    return pprint(files)\n    return write('clip.js', files)\n"
  },
  {
    "name": "getFiles",
    "text": "def getFiles(dir=dir2023, **kwargs):\n    if isArray(dir):\n        return dir\n    recursive = kwargs.pop('recursive', False)\n    sortIt = kwargs.get('sort', False)\n    promptIt = kwargs.get('prompt', False)\n    parser = kwargs.get('parser', False)\n    folders = kwargs.get('folders')\n    n = kwargs.get('n')\n    dir = dirGetter(dir)\n\n    if n:\n        files = sortByDate(absdir(dir))\n        return getN(files, n)\n\n    def runner(dir):\n        for file in absdir(dir):\n            try:\n                if folders and isdir(file):\n                    if checkpoint(file):\n                        store.append(file)\n                elif isfile(file) and checkpoint(file):\n                    store.append(file)\n                elif recursive and isdir(file):\n                    runner(file)\n            except Exception as error:\n                errorPrompt(file, error)\n            \n\n    store = []\n    checkpoint = checkpointf(**kwargs)\n    runner(dir)\n    if sortIt:\n        store = sortByDate(store)\n    if kwargs.get('reverse'):\n        store.reverse()\n    if promptIt:\n        prompt(store)\n    if parser:\n        return map2(store, parser)\n    return store\n"
  },
  {
    "name": "isIgnoredFile2",
    "text": "def isIgnoredFile2(file):\n    name = tail(file)\n    ignore = [\n        \"vosk-api\",\n        \"__pycache__\",\n        \"node_modules\",\n        \".git\",\n        \".gitignore\",\n    ]\n    ignoreRE = \"^(?:\\W)\"\n\n    if name in ignore:\n        return True\n    if test(ignoreRE, name):\n        return True\n"
  },
  {
    "name": "c2",
    "text": "def c2(s):\n    write('clip.js', s)\n"
  },
  {
    "name": "incrementalName",
    "text": "def incrementalName(s=0, dir = 'drive'):\n    if not s:\n        s = prompt('choose a name because s is None')\n    override = 0\n    if s.endswith('!'):\n        s = s[:-1]\n        override = 1\n    front = removeExtension(s)\n    e = getExtension(s)\n    d = dirGetter(dir)\n    count = 1\n    while count < 50:\n        name = os.path.join(d, f'{front} {count}.{e}')\n        if override:\n            return name\n        if not isfile(name): return name\n        count += 1\n"
  },
  {
    "name": "dirGetter",
    "text": "def dirGetter(dir=None):\n    if not dir:\n        return os.getcwd()\n    dir = dir.replace('~', '/home/kdog3682')\n    value = env.dirdict.get(dir, dir)\n    assert isdir(value)\n    return value\n\n"
  },
  {
    "name": "foo1689558041",
    "text": "def foo1689558041(f):\n    mfile(f, incrementalName(f))\n"
  },
  {
    "name": "moveToActiveDir",
    "text": "def moveToActiveDir(s):\n    files = map(xsplit(s), lambda x: npath(dirGetter('dl'), x))\n    for file in files:\n        mfile(file, dir2023)\n"
  },
  {
    "name": "rpw",
    "text": "def rpw(file, f, check=0):\n    payload = f(read(file))\n    if check:\n        prompt(payload)\n    write(file, payload)\n"
  },
  {
    "name": "relpath",
    "text": "def relpath(s):\n    prefix = ''\n    return s.replace('/home/kdog3682/2023/', prefix)\n"
  },
  {
    "name": "getStringArg",
    "text": "def getStringArg(key, s):\n    r = f\"{key}\\([\\'\\\"]?(.*?)[\\'\\\"]\\)\"\n    return search(r, s, flags=re.M)\n"
  },
  {
    "name": "getStringAttr",
    "text": "def getStringAttr(key, s):\n    r = f\"^ *[\\'\\\"]?{key}[\\'\\\"]? *: *[\\'\\\"]?(.*?)[\\'\\\"]?[,;]? *$\"\n    return search(r, s, flags=re.M)\n"
  },
  {
    "name": "foo1689563342",
    "text": "def foo1689563342(s):\n\n    chunks = re.split('\\n+(?=[^\\s\\]\\}])', s)\n    d = {}\n    for c in chunks:\n        if test('^@font-face', c):\n            name = getStringAttr('font-family', c)\n            src = getStringArg('url', c)\n            d[src] = name \n\n    def parser(x):\n        f = x.group(0)\n        if test('^\\.?/?fonts/', f):\n            return f\n\n        name = addExtension(d[f], getExtension(f))\n        outpath = npath('fonts', name)\n        assert isfile(f)\n        cssPath = relpath(outpath)\n        mfile(f, outpath)\n        return cssPath\n\n    s = re.sub('[\\w_/-]+\\.(?:woff2?|ttf|otf)', parser, s)\n    return s\n\n\n"
  },
  {
    "name": "headAndTail",
    "text": "def headAndTail(s):\n    a, b = os.path.split(s)\n    if a == '':\n        a = '/home/kdog3682/2023'\n    return a, b\n"
  },
  {
    "name": "unzipfilestodir",
    "text": "def unzipfilestodir(outdir):\n    files = getFiles('dl', zip=1, hours=1, recursive=0)\n    prompt(files)\n    for file in files:\n        f = FileState(file)\n        f.unzip(outdir)\n        f.remove()\n"
  },
  {
    "name": "extractAZipFile",
    "text": "def extractAZipFile(file):\n    f = FileState(glf())\n    f.unzip(trashdir)\n    g = trashdir + file\n    mfile(g, dir2023)\n    return file\n"
  },
  {
    "name": "fo",
    "text": "def fo():\n    def f(a):\n        message = a.get('message')\n        if not message:\n            return \n\n        role = message.get('author').get('role')\n        if role == 'assistant':\n            parts = message.get('content').get('parts')\n            s = join(parts)\n            r = '```(\\w+)\\s+([\\w\\W]+?)```'\n            m = re.findall(r, s)\n            store.extend(m)\n\n    store = []\n    data = list(clip().get('mapping').values())\n    map(data, f)\n    #pprint(store)\n\n    chromeExtensionName = 'myFirstExtension'\n    dir = mkdir(dldir + chromeExtensionName)\n    chdir(dir)\n    for extension, contents in store:\n        if extension == 'js':\n            write('background.js', contents)\n\n        if extension == 'json':\n            write('manifest.json', parseJSON(contents))\n        #'/mnt/chromeos/MyFiles/Downloads/myFirstExtension/manifest.json'\n        #'/mnt/chromeos/MyFiles/Downloads/myFirstExtension/background.js'\n"
  },
  {
    "name": "linKeSong",
    "text": "def linKeSong():\n    def getUrl(n):\n        return \"jjwxc.net/onebook.php?novelid=2337210&chapterid={n}\"\n\n    def parser(n):\n        url = fixUrl(getUrl(n))\n        s = request(url)\n        c2(s)\n\n    parser(1)\n"
  },
  {
    "name": "oc",
    "text": "def oc():\n    ofile('clip.js')\n"
  },
  {
    "name": "isChinese",
    "text": "def isChinese(s):\n    return test(chineseRE, s)\n    \n"
  },
  {
    "name": "foo",
    "text": "def foo(self):\n    return 'export default ' + dumpJson(out)"
  },
  {
    "name": "copyClipFileToDrive",
    "text": "def copyClipFileToDrive(name):\n    name = npath('drive', name)\n    cfile('clip.js', name)\n    save(name)\n"
  },
  {
    "name": "doStoryOfYangxiPalace",
    "text": "def doStoryOfYangxiPalace():\n\n    outpath = npath('jsondrive', 'storyOfYangxiPalace.jieba.json')\n    touched = 0\n\n    def parser(file):\n        nonlocal touched\n        episode = search('S01E(\\d+)', file)\n        if episode:\n            episode = int(episode)\n        else:\n            return \n\n        print('doing file', file)\n        lines = linegetter(file, fn=jieba.cut)\n\n        if not touched:\n            touched = 1\n\n        return {\n            'episodeNumber': episode,\n            'lines': lines,\n        }\n\n    file = \"drive-download-20230719T171808Z-001.zip\"\n    file = FileState(npath('trash', file))\n    translations = file.getZipFiles()\n    jieba = Jieba()\n    payload = map2(translations, parser, sort='episodeNumber')\n    try:\n        write(outpath, payload)\n    except Exception as e:\n        clip(payload)\n    \n"
  },
  {
    "name": "skipPrompt",
    "text": "def skipPrompt(*args, **kwargs):\n    \n    import inspect\n    message = None\n    names = []\n\n    for i, arg in enumerate(args):\n        if i == 0 and arg != None:\n            return \n        else:\n\n            try:\n                vars = inspect.currentframe().f_back.f_locals.items()\n                els = [v_name for v_name, v_val in vars if v_val is arg]\n                name = els[0]\n                names.push(name)\n            except Exception as e:\n                message = arg\n        \n    printItems = [ f\"{names[0]} does not exist\" ]\n    if message: printItems.append(message)\n    if kwargs: printItems.append(kwargs)\n    print(*printItems)\n    return input('')\n"
  },
  {
    "name": "initializeGlobalVariable",
    "text": "def initializeGlobalVariable(key=0):\n    global promptOnceTouched\n    try:\n        if promptOnceTouched:\n            print('already touched early return')\n            return \n        promptOnceTouched = True\n        return True\n    except Exception as e:\n        if (type(e) == NameError):\n            promptOnceTouched = True\n            return True\n        else:\n            raise e\n        \n"
  },
  {
    "name": "promptOnce",
    "text": "def promptOnce(x, mode=0):\n    if initializeGlobalVariable('promptOnceTouched'):\n        prompt(x, mode)\n\n\n"
  },
  {
    "name": "makehsk",
    "text": "def makehsk():\n    \"\"\" asdfd2 \"\"\"\n    hskjsonfile = \"/mnt/chromeos/GoogleDrive/MyDrive/JSONS/hsk-master.json\"\n    path = npath(hskjsonfile, 'hsk-dict')\n    dprompt(path)\n    data = read(hskjsonfile)\n    store = {}\n    for item in data:\n        t = item.get('translations')[0]\n        store[item.get('hanzi')] = item\n\n    write(path, store)\n    save(path, mode='python')\n    return store\n    "
  },
  {
    "name": "zokarious",
    "text": "def zokarious():\n    write(npath('drive', 'foo.js'), 'aaa')\n"
  },
  {
    "name": "map2",
    "text": "def map2(items, fn, **kwargs):\n    if not fn:\n        return items\n\n    store = []\n    for index, el in enumerate(list(items)):\n        try:\n            value = fn(el)\n            if value == None:\n                continue\n            store.append(value)\n        except Exception as error:\n            errorPrompt(index, el, error)\n\n    if kwargs.get('sort'):\n        return sort(store, kwargs.get('sort'))\n\n    return store\n        \n"
  },
  {
    "name": "errorPrompt",
    "text": "def errorPrompt(*args, **kwargs):\n    \n    import inspect\n    caller = getCaller()\n    message = 'Error at: ' + caller\n    for i, arg in enumerate(args):\n        try:\n            vars = inspect.currentframe().f_back.f_locals.items()\n            e = [v_name for v_name, v_val in vars if v_val is arg]\n            name = e[0]\n            kwargs[name] = arg\n        except Exception as e:\n            message += ': ' + arg\n        \n    print(message)\n    pprint(kwargs)\n    return input('')\n"
  },
  {
    "name": "makeFileDictResource",
    "text": "def makeFileDictResource():\n    s = json.dumps(env.dirdict)\n    appendVariable(s)\n"
  },
  {
    "name": "chooseMultiple",
    "text": "def chooseMultiple(items, fn=0):\n    display = map2(items, fn)\n    message = 'choose 1 based indexes'\n    indexes = rangeFromString(prompt(number(display), message))\n    return map2(indexes, lambda x: items[x])\n"
  },
  {
    "name": "getCookUpAStormSubtitles",
    "text": "def getCookUpAStormSubtitles():\n    \n    def f(x):\n        start, end, chinese = x\n        data = jieba.cut(chinese, timestamp=[start, end])\n        data['timestamp'] = {\n            'from': start,\n            'to': end,\n        }\n        promptOnce(data)\n        return data\n\n        \n\n    file = glf()\n    print(file)\n    return \n    s = read(file)\n    return print(len(s))\n    r = r'(\\d+:\\d+:\\d+).*?(\\d+:\\d+:\\d+).*?\\n([\\u4e00-\\u9fff]+)'\n    jieba = Jieba(convert='tw2s')\n    data = map2(re.findall(r, s), f)\n    outpath = 'cookUpAStorm.jieba.json'\n    path = npath('drive', addExtension(outpath, 'json'))\n    prompt(path)\n    write(path, data)\n\n"
  },
  {
    "name": "dprompt2",
    "text": "def dprompt2(*args):\n    dprint2(*args)\n    print('----------------------------')\n    print('press anything to continue')\n    input()\n"
  },
  {
    "name": "dprint2",
    "text": "def dprint2(*args):\n    import inspect\n    store={}\n    for arg in args:\n        try:\n            vars = inspect.currentframe().f_back.f_locals.items()\n            name = [v_name for v_name, v_val in vars if v_val is arg][0]\n            store[name]=arg\n        except Exception as e:\n            store[arg] = True\n        \n    for k,v in store.items():\n        print('key:', k, '         value:', v)\n\n\n\n"
  },
  {
    "name": "stringBreaker",
    "text": "def stringBreaker(s, key):\n    r = '[\\w\\W]+?' + key + '\\s*'\n    print(r)\n    return re.sub(r, '', s)\n"
  },
  {
    "name": "chineseMovieJiebaConverter",
    "text": "def chineseMovieJiebaConverter(file, title, breaker=0):\n    assert(isfile(file))\n    name = camelCase(title)\n    outpath = npath('jsondrive', name + '.jieba.json')\n    \n    dprompt(name, outpath)\n    appleBreaker = 'face into\\.\\.\\.'\n\n    s = read(file)\n    jieba = Jieba(convert='tw2s')\n\n    if breaker:\n        s = stringBreaker(s, breaker)\n    s = linegetter(s)\n    def parser(s):\n        x = split(s, ',')\n        a = x[1]\n        b = x[2]\n        c = x[-1]\n        c = re.sub(notChineseRE, '', c)\n        return jieba.cut(c, timestamp=[a,b])\n\n    items = map2(s, parser)\n    payload = {\n        'title': title,\n        'contents': items,\n    }\n    write(outpath, payload)\n"
  },
  {
    "name": "filesFromString",
    "text": "def filesFromString(s, e=''):\n    dir, *items = linegetter(s)\n    return map2(items, lambda x: npath(dir, addExtension(x, e)))\n"
  },
  {
    "name": "doFonts",
    "text": "def doFonts(s):\n\n    examplstr1689969711 = \"\"\"\n    todo\n    ZCOOL_KuaiLe\n    Zhi_Mang_Xing\n    Liu_Jian_Mao_Cao\n    Long_Cang\n    \"\"\"\n\n    def fonter(file):\n        files = FileState(file).unzip(fontdir)\n        prompt(files)\n        return files\n    \n    assert(isdir(fontdir))\n    files = filesFromString(s, e='zip')\n    allfiles = flat(map2(files, fonter))\n    save(allfiles)\n"
  },
  {
    "name": "hskPaperTests",
    "text": "def hskPaperTests():\n    chdir(trashdir)\n    f = FileState(glf())\n    files = f.unzip()\n    names = map2(files, tail)\n    names.sort()\n    f = lambda x: toNumber(search('H\\d(\\d+)\\.docx', x))\n    transcriptIds = map2(names, f)\n    checkpoint = checkpointf(extensions=['ogg', 'mp3'])\n    audios = filter(names, checkpoint)\n\n    checkpoint = checkpointf(extensions=['docx'])\n    transcripts = filter(names, checkpoint)\n\n    checkpoint = checkpointf(extensions=['pdf'], keepRE='answer', flags=re.I)\n    exams = filter(names, checkpoint)\n\n    checkpoint = checkpointf(extensions=['pdf'], keepRE='exam', flags=re.I)\n    answers = filter(names, checkpoint)\n    def boo(id, items):\n        r = str(id)\n        return find(items, lambda x: test(r, x))\n\n    def parser(id):\n        a = boo(id, audios)\n        b = boo(id, exams)\n        c = boo(id, answers)\n        if not a:\n            return \n        if not b:\n            return \n        if not c:\n            return \n\n        d = boo(id, transcripts)\n        return [a, b, c, d]\n\n    filePacks = map2(transcriptIds, parser)\n    prompt(filePacks)\n\n    for filePack in filePacks:\n        files = npath(trashdir, filePack)\n"
  },
  {
    "name": "toNumber",
    "text": "def toNumber(x):\n    try:\n        return int(x)\n    except Exception as e:\n        return \n        \n    \n\n"
  },
  {
    "name": "sortByDate",
    "text": "def sortByDate(files, reverse=0):\n    files.sort(key=mdate, reverse=reverse)\n    return files\n\n\n"
  },
  {
    "name": "filePicker",
    "text": "def filePicker(dir=dldir, **kwargs):\n    saveIt = kwargs.pop('save', True)\n    files = getFiles(dir, **kwargs)\n    chosen = chooseMultiple(files, tail)\n    if saveIt:\n        save(chosen, mode='python', current=1)\n"
  },
  {
    "name": "parseChatgptZipFiles",
    "text": "def parseChatgptZipFiles():\n    ''' gpt chat chatgpt openai '''\n\n    def parser(file):\n        promptIt = 1\n        file = FileState(file)\n        targetFile = file.unzip(trashdir, target='conversations.json')\n        cfile(npath(trashdir, 'chat.html'), incName('Chatgpt.html', dir='drive', prompt=promptIt))\n        data = read(targetFile)\n        payload = map2(data, parseConversation)\n        prompt(payload[0], 'first item of the payload')\n        incwrite('Chatgpt', payload, prompt=promptIt)\n        file.remove()\n        prompt('success')\n        return True\n\n    r = '\\w+(?:-\\d+){6}\\.zip'\n    return getFiles(dldir, r=r, sort=1, prompt=0, parser=parser)\n"
  },
  {
    "name": "parseConversation",
    "text": "def parseConversation(x):\n    def parser(item):\n        message = item.get('message')\n        if not message:\n            return \n        author = message.get('author').get('role')\n        if author == 'system':\n            return \n\n        timestamp = message.get('create_time')\n        id = item.get('id')\n        parentId = item.get('parent')\n        contentParts = message.get('content').get('parts')\n        content = join(contentParts)\n        return {\n            'author': author,\n            'id': id,\n            'parentId': parentId,\n            'timestamp': timestamp,\n            'text': content,\n        }\n\n    title = x.get('title')\n    id = x.get('id', None)\n    timestamp = x.get('create_time', None)\n    mapping = x.get('mapping')\n    contents = map2(mapping.values(), parser)\n    return {\n        'title': title,\n        'id': id,\n        'timestamp': timestamp,\n        'contents': contents,\n    }\n"
  },
  {
    "name": "incName",
    "text": "def incName(name, dir='jsondrive', **kwargs):\n    aliases = {\n        'ffr': 'File Function Ref',\n    }\n    name = aliases.get(name, name)\n    promptIt = kwargs.get('prompt', None)\n    if promptIt:\n        dprompt2(name)\n    name = incrementalName(npath(dir, addExtension(name, 'json')))\n    return name\n\n"
  },
  {
    "name": "incwrite",
    "text": "def incwrite(name=0, payload=0, prompt=0, save=1):\n    n = incName(name, dir='jsondrive', prompt=prompt)\n    write(n, payload, save=save)\n"
  },
  {
    "name": "findFile2",
    "text": "def findFile2(files, r):\n    fn = testf(r)\n    names = map(files, tail)\n    index = find(files, fn, mode=int)\n    if index == None:\n        return \n    return files[index]\n"
  },
  {
    "name": "moveFontsToFontDir",
    "text": "def moveFontsToFontDir():\n    fonts = getFiles(fonts=1)\n    prompt(fonts)\n    pprint(mfiles(fonts, dir=fontdir))\n\n"
  },
  {
    "name": "clickThrough",
    "text": "def clickThrough(chunks):\n    for chunk in chunks:\n        prompt(chunk)\n\n"
  },
  {
    "name": "mfiles",
    "text": "def mfiles(files=0, dir=0, to=0):\n    if isArray(dir):\n        to = dir\n\n    if to:\n        assert len(files) == len(to)\n        for i, file in enumerate(files):\n            mfile(file, to[i])\n    elif dir:\n        for file in files:\n            mfile(file, dir)\n    \n\n\n"
  },
  {
    "name": "getSetStoreDecorator",
    "text": "def getSetStoreDecorator(file):\n    base = read(file) or {}\n\n    def wrapper(fn):\n        def decorator(*args, **kwargs):\n            value = fn(*args, **kwargs)\n            base.update(value)\n            write(file, base)\n            pprint(base)\n            return base\n        return decorator\n    return wrapper\n"
  },
  {
    "name": "htmlRE",
    "text": "def htmlRE(key):\n    r = f'<{key}[\\w\\W]*?>([\\w\\W]+?)</{key}>'\n    return r\n"
  },
  {
    "name": "createSvgPathLibrary",
    "text": "def createSvgPathLibrary(files):\n    def parse(s):\n        r = htmlRE('svg')\n        r2 = htmlRE('style')\n        r3 = '\\r\\n\\t'\n        value = re.sub(r3, '', re.sub(r2, '', search(r, s).strip()))\n        assert value\n        return value\n\n    store = {}\n    for file in toArray(files):\n        name = re.sub('-(?:svgrepo).*', '', tail(file))\n        s = read(file).decode()\n        store[name] = parse(s)\n        rfile(file)\n\n    return store\n"
  },
  {
    "name": "createVariable2",
    "text": "def createVariable2(name, value, prefix=None):\n    value = dumpJson(value)\n    if prefix: prefix += ' '\n    s = f\"{prefix}{name} = {value}\"\n    return s\n"
  },
  {
    "name": "jsonToJavascript",
    "text": "def jsonToJavascript(file):\n    assert(isJson(file))\n    name = camelCase(removeExtension(file))\n    #value = list(read(file).values())[2]\n    print(json.dumps(read(file)))\n    return \n    payload = 'export default ' + value\n    outpath = file + '.js'\n    write(outpath, payload)\n    save(outpath)\n\n"
  },
  {
    "name": "getN",
    "text": "def getN(items, n):\n    if n > 0:\n        return items[0:n]\n    else:\n        return items[n:]\n"
  },
  {
    "name": "appMoveLastFilesFromDownloadToMaindirAndGitIgnore",
    "text": "def appMoveLastFilesFromDownloadToMaindirAndGitIgnore(n):\n    \n    if n > 0:\n        print('maybe n should be less than 0 ... early return')\n        return \n\n    files = getFiles(dldir, n)\n    def fn(file):\n        name = tail(file)\n        e = getExtension(name)\n        a = search('[a-zA-Z]\\w+$', removeExtension(name))\n        return a + '.' + e\n    names = map(files, fn)\n    dprompt(names)\n    mfiles(files, names)\n    append(gitignorefile, join(names))\n"
  },
  {
    "name": "rnc",
    "text": "def rnc(newName=None):\n    \"\"\"\n        writes to jsondrive in an incremental manner\n        generally used for json type clips (like data aggregation)\n    \"\"\"\n    name = incName(newName, dir='jsondrive', prompt=1)\n    mfile('clip.js', name)\n"
  },
  {
    "name": "fileDate",
    "text": "def fileDate(f):\n    strife = \"%A %B %d %Y, %-I:%M:%S%p\"\n    return datestamp(mdate(f), strife)\n\n"
  },
  {
    "name": "gjf",
    "text": "def gjf(hours=0):\n    # get javascript files\n    files = getFiles(js=1, sort=1, reverse=1, hours=int(hours))\n    files = map(files, lambda x: x + ' :: ' + fileDate(x))\n    s = join(comment(datestamp()), files)\n    append('files.txt', s)\n"
  },
  {
    "name": "folders",
    "text": "def folders():\n    files = getFiles(folders=1, sort=1)\n    pprint(files)\n"
  },
  {
    "name": "read2",
    "text": "def read2(file):\n    textExtensions = [\n        \"js\",\n        \"css\",\n        \"html\",\n        \"py\",\n        \"txt\",\n        \"md\",\n    ]\n\n    e = getExtension(file)\n    mode = \"r\" if e in textExtensions else \"rb\"\n    with open(file, mode) as f:\n        return f.read()\n"
  },
  {
    "name": "allFiles",
    "text": "def allFiles(dir):\n    store = []\n    for root, _, files in os.walk(dir):\n        for file in files:\n            path = os.path.join(root, file)\n            store.append(path)\n    return store\n"
  },
  {
    "name": "viteMover",
    "text": "def viteMover():\n    dir = \"/home/kdog3682/2023/dist/\"\n    indexFile = find(absdir(dir), 'html$')\n    mfile(indexFile, dir + 'index.html')\n    dir = \"/home/kdog3682/2023/dist/assets/\"\n    files = allFiles(dir)\n    def runner(file):\n        e = getExtension(file)\n        if e == 'js':\n            path = npath(dir, 'main.js')\n            mfile(file, path)\n            return path\n        elif e == 'css':\n            path = npath(dir, 'style.css')\n            mfile(file, path)\n            return path\n        else:\n            return file\n    results = map(files, runner)\n    return results\n"
  },
  {
    "name": "findFileString",
    "text": "def findFileString(s):\n    r = '/\\S+'\n    return search(r, s)\n"
  },
  {
    "name": "askof",
    "text": "def askof():\n    r = '^#.+'\n    s = read('files.txt')\n    item = re.split(r, s, flags=re.M)[-1]\n    files = unique(linegetter(item, fn=findFileString))\n    assert(every(files, isfile))\n    def runner(item):\n        if isLibraryFile(item):\n            return \n        info = fileInfo(item)\n        identifiers = getFunctionNames(item)\n        info['identifiers'] = identifiers\n        return info\n    clip(map(files, runner))\n    #return files\n"
  },
  {
    "name": "getFiles2",
    "text": "def getFiles2(dir=dir2023, **kwargs):\n\n    checkpoint = checkpointf(**kwargs)\n    dir = dirGetter(dir)\n\n    def parse(file, depth):\n        if isIgnoredFile2(file):\n            return \n        elif isfile(file):\n            return tail(file)\n        elif checkpoint(file):\n            if depth > 3 and not prompt(file):\n                return log(file)\n            return runner(file, depth + 1)\n\n    def runner(dir, depth=0):\n        children = []\n        for file in absdir(dir):\n            try:\n                push(children, parse(file, depth))\n            except Exception as error:\n                errorPrompt(file, error)\n\n        if empty(children):\n            return \n\n        return {\n            'dir': dir,\n            'items': children,\n        }\n\n    return runner(dir)\n"
  },
  {
    "name": "log",
    "text": "def log(x=0):\n    if x == None:\n        return \n\n    append('temp.txt', str(x))\n\n"
  },
  {
    "name": "zipToDrive",
    "text": "def zipToDrive(files, out):\n    files = getFiles(files)\n    outpath = incrementalName(npath('drivezip', addExtension(out, 'zip')))\n    from zipscript import zip\n    dprompt(files, outpath)\n    zip(files, outpath)\n"
  },
  {
    "name": "getDrive",
    "text": "def getDrive(x):\n    d = drivedir + x.upper()\n    assert isdir(d)\n    return d\n\n"
  },
  {
    "name": "isPublic",
    "text": "def isPublic(x):\n    return test('^\\w', tail(x))\n"
  },
  {
    "name": "rmdirs",
    "text": "def rmdirs(dirs):\n    prompt('removing the following directories', dirs)\n    for dir in dirs:\n        rmdir(dir)\n"
  },
  {
    "name": "aaarenameClipToDriveFile",
    "text": "def aaarenameClipToDriveFile():\n    newName = prompt('name for drive clip file?')\n    cfile(clipfile, drivedir + newName)\n\n    "
  },
  {
    "name": "mget2",
    "text": "def mget2(r, s):\n    store = []\n    def parser(x):\n        m = x.groups()\n        m = m if m else x.group(0)\n        store.append(m)\n        return ''\n\n    text = re.sub(r, parser, s).strip()\n    return [text, smallify(store)]\n"
  },
  {
    "name": "doFileTable",
    "text": "def doFileTable():\n    \n    def parseFileTable(s):\n        r = '(?:(d|res|del|skip)|(rn|Dialogue|dia): *(.+)) *$'\n        name, m = mget2(r, s)\n        if not m:\n            if isRemovableFile(name) or 'temp' in name:\n                return rfile(name)\n            return \n\n        return \n        deleteIt, renameIt, newName = m\n        if deleteIt:\n            if deleteIt == 'res':\n                return mfile(name, resdir)\n            if deleteIt == 'skip':\n                return \n            return rfile(name)\n        elif renameIt:\n            if renameIt == 'rn':\n                return mfile(name, changeName(newName, name))\n            else:\n                mathdir = '/home/kdog3682/MATH/'\n                outpath = npath(mathdir, addExtension(name, 'txt'))\n                return mfile(name, outpath)\n\n    s = lastItem(vimftfile, mode='date')\n    payload = linegetter(s, fn=parseFileTable)\n"
  },
  {
    "name": "changeName",
    "text": "def changeName(newName, name):\n    head, tail = os.path.split(name)\n    base = os.path.join(head, newName)\n    return addExtension(base, getExtension(tail))\n"
  },
  {
    "name": "lastItem",
    "text": "def lastItem(x, mode=None):\n    s = textgetter(x)\n    if mode == 'date':\n        items = re.split('^\\d+-\\d+.*', s, flags=re.M)\n    else:\n        items = re.split('\\n\\n+', s)\n\n    return items[-1]\n"
  },
  {
    "name": "csvReader",
    "text": "def csvReader(file, fn=0):\n    def parse(s):\n        items = re.split(' *, *', s)\n        if fn:\n            return fn(items)\n        else:\n            return items\n    items = linegetter(file, fn=parse, skip=1)\n    return items\n"
  },
  {
    "name": "submit",
    "text": "def submit(name, value, debug=0):\n    if not value:\n        return \n    if isString(value):\n        prompt('hmm not set up yet')\n        return \n\n    if debug: return pprint(value)\n    outpath = npath(drivejsondir, addExtension(name, 'json'))\n    write(outpath, value, open=1)\n\n\n "
  },
  {
    "name": "emptyTrash",
    "text": "def emptyTrash():\n    dir = trashdir\n    assert isdir(dir)\n    rmdir(dir, force=1)\n    mkdir(dir)\n"
  },
  {
    "name": "cleanup10",
    "text": "def cleanup10(dir, size=150):\n    files = getFiles(dir, smallerThan=size)\n    rfiles(files)\n"
  },
  {
    "name": "parseCsvBabyNameFrequencies",
    "text": "def parseCsvBabyNameFrequencies():\n    \n    \"\"\"\n        date: 09-14-2023 \n        entry: /home/kdog3682/TEXTS/yob2016.txt (deleted)\n        data:\n            Name,Sex,BirthCount\n            Emma,F,19414\n            Olivia,F,19246\n\n        output: Popular Baby Names with Frequencies\n        type: json\n        schema: {\n            boys: [(sam, 4)],\n            girls: [(samantha, 4)],\n        }\n\n        notes: \n            cut off at frequencies less than 50\n    \"\"\"\n\n    def parse(items):\n        try:\n            name, sex, count = items\n            count = int(count)\n            if count < 50:\n                return \n        except Exception as e:\n            return \n\n        if sex == 'F':\n            girls.append((name, count))\n        else:\n            boys.append((name, count))\n\n    boys = []\n    girls = []\n    items = csvReader(file, fn=parse)\n    payload = {'boys': boys, 'girls': girls}\n    submit('Popular Baby Names with Frequencies', payload)\n\n\n"
  },
  {
    "name": "flattenAllDirectoriesWithinTheDirectory",
    "text": "def flattenAllDirectoriesWithinTheDirectory(dir):\n    dirs = getFiles(dir, folders=1)\n    for d in dirs:\n        mfiles(absdir(d), dir)\n        rmdir(d)\n"
  },
  {
    "name": "moveAllPicturesToDrive",
    "text": "def moveAllPicturesToDrive(dir):\n     pics = getFiles(dir, images=1)\n     if not pics:\n         printdir(dir)\n         return print('no pics')\n     print('a')\n     prompt(pics)\n     print('a')\n     mfiles(pics, drivedir + 'PICTURES 2023')\n\n"
  },
  {
    "name": "moveDriveFilesToDriveFolders",
    "text": "def moveDriveFilesToDriveFolders(key, **kwargs):\n    files = getFiles(drivedir, **kwargs)\n    dir = f\"{drivedir}{key.upper()} {getYearNumber()}\"\n    prompt(files)\n    mfiles(files, dir)\n\n"
  },
  {
    "name": "iqr",
    "text": "def iqr(data):\n    import numpy as np\n    q1 = np.percentile(data, 25)\n    q3 = np.percentile(data, 75)\n    iqr = q3 - q1\n\n    lower_bound = q1 - 1.5 * iqr\n    upper_bound = q3 + 1.5 * iqr\n\n    def checkpoint(file):\n        return lower_bound <= fsize(file) <= upper_bound\n"
  },
  {
    "name": "review",
    "text": "def review(files):\n    def runner(file):\n        a = prompt(file)\n        if a == 'm':\n            mfile(file, 'res')\n        elif a == 'd':\n            rfile(file)\n        elif a == 'o':\n            ofile(file)\n            return runner(file)\n\n    for file in files:\n        runner(file)\n\n"
  },
  {
    "name": "printdir",
    "text": "def printdir(dir=dldir, printIt=0, dated = 0):\n    dir = dirGetter(dir)\n    files = absdir(dir)\n    size = len(files)\n\n    def dateRunner(file):\n        try:\n            d = datestamp(file, 'long')\n            return (tail(file), d)\n        except Exception as e:\n            return \n\n    if dated:\n        files = map2(sortByDate(files), dateRunner)\n        for file, date in files:\n            blue(date, file)\n    elif size < 30:\n        pprint(map(files, fileInfo))\n    else:\n        files = map(sorted(files), tail)\n        pprint(files)\n\n    blue('Num Files', size)\n\n    if printIt:\n        append(vimftfile, join(datestamp(), files))\n    return files\n"
  },
  {
    "name": "mfiles",
    "text": "def mfiles(files, dir, fn=0, ask=0):\n    files = absdir(files)\n    dir = dirGetter(dir)\n\n    if ask:\n        prompt(files, f\"move the files to {dir}?\")\n\n    for f in files:\n        if fn:\n            dir = fn(dir + fn(tail(f)))\n        if isfile(npath(dir, f)):\n            if prompt('the file exists: are you sure you want to overide? type [y]es to confirm', tail(f)):\n                mfile(f, dir)\n        else:\n            mfile(f, dir)\n\n"
  },
  {
    "name": "sprawldir",
    "text": "def sprawldir(dir, folder):\n    items = getFiles(dir, name=folder, folders=1)\n    while 1:\n        if len(items) == 1 and isdir(items[0]):\n            items = absdir(items[0])\n        else:\n            return items\n"
  },
  {
    "name": "evaluate_text_invivo_for_python_article",
    "text": "def evaluate_text_invivo_for_python_article(s):\n    lines = linegetter(s)\n    for line in lines:\n        eval(line)\n        print(line, fruits)\n"
  },
  {
    "name": "buildRequirements",
    "text": "def buildRequirements():\n    \"\"\"\n        So this file does\n    \"\"\"\n    def clean(s):\n        return search('\\S+', s)\n\n    def runner(file):\n        s = read(file)        \n        r = '^(?:import|from) (\\S+)'\n        m = re.findall(r, s, flags=re.M)\n        return m\n\n    def checkpoint(file):\n        f = npath(pydir, addExtension(file, 'py'))\n        return not isfile(f)\n\n    files = getFiles(pydir, py=1)\n    imports = filter(unique(flat(map(files, runner))), checkpoint)\n    imports.sort()\n    prompt(imports)\n    s = SystemCommand('pip list', dir=pydir)\n    packages = linegetter(s.success, fn = clean)[2:]\n\n    libraries = filter(imports, lambda x: x in packages)\n\n    return {\n        'packages': packages,\n        'allImports': imports,\n        'imports': libraries,\n    }\n\n"
  },
  {
    "name": "checkpointf",
    "text": "def checkpointf(\n    kb=0,\n    keepRE=0,\n    contains=0,\n    gdoc=0,\n    deleteIt=0,\n    deleteRE=0,\n    include=\"\",\n    size=0,\n    svg=0,\n    maxLength=0,\n    image=0,\n    images=0,\n    today=0,\n    flags=re.I,\n    fonts=0,\n    files=0,\n    gif=0,\n    weeks=0,\n    month=0,\n    old=0,\n    ignore=\"\",\n    ignoreRE=\"\",\n    css=0,\n    js=0,\n    zip=0,\n    py=0,\n    txt=0,\n    html=0,\n    pdf=0,\n    date=0,\n    name=0,\n    big=0,\n    r=0,\n    antiregex=0,\n    anti=0,\n    small=0,\n    before=0,\n    after=0,\n    minLength=0,\n    minutes=0,\n    days=0,\n    hours=0,\n    regex=0,\n    public=1,\n    private=0,\n    math=0,\n    text=0,\n    lib=0,\n    log=0,\n    onlyFiles=0,\n    isf=0,\n    isp=0,\n    onlyFolders=0,\n    folders=0,\n    biggerThan=0,\n    smallerThan=0,\n    fn=0,\n    e=0,\n    json=0,\n    vimInfo=0,\n    **kwargs,"
  },
  {
    "name": "note",
    "text": "def note(*args):\n    a = map(args, str)\n    s = f\"Note: {longstamp()} :: \"\n    s += json.dumps(a)\n    append(temptextfile, s)\n    prompt(s)\n\n"
  },
  {
    "name": "chalkf",
    "text": "def chalkf(color, mode=0):\n\n    reset = \"\\033[0m\"\n    red = \"\\033[31m\"\n    green = \"\\033[32m\"\n    yellow = \"\\033[33m\"\n    blue = \"\\033[34m\"\n    purple = \"\\033[35m\"\n    cyan = \"\\033[36m\"\n    bold = \"\\033[1m\"\n\n    colors = {\n        'blue': blue,\n        'red': red,\n        'green': green,\n        'yellow': yellow,\n        'purple': purple,\n        'cyan': cyan,\n    }\n    color = colors[color]\n\n    def getDelimiter(a, b = None):\n        if isString(b):\n            if '\\n' in b:\n                return '\\n'\n            elif str(a).endswith(':'):\n                return ''\n        return ':'\n\n\n    def baseChalk(s):\n        if isCapitalized(s):\n            return bold + color + str(s) + reset\n        else:\n            return color + str(s) + reset\n\n    if mode == str:\n        return baseChalk\n    def promptChalk(a, b):\n        delimiter = getDelimiter(a, b)\n        print(bold + color + capitalize(a) + delimiter + reset, b)\n        input()\n\n    if mode == prompt:\n        return promptChalk\n\n    def chalk(*args, **kwargs):\n        delimiter = getDelimiter(*args)\n        if kwargs.get('bold') or isCapitalized(args[0]):\n            print(bold + color + str(args[0]) + delimiter + reset, *args[1:])\n        else:\n            print(color + str(args[0]) + reset, *args[1:])\n\n    return chalk\n"
  },
  {
    "name": "isCapitalized",
    "text": "def isCapitalized(s):\n    return isString(s) and test('^[A-Z]', s)\n"
  },
  {
    "name": "sleep",
    "text": "def sleep(n):\n    time.sleep(n)\n"
  },
  {
    "name": "stop",
    "text": "def stop(*args):\n    s = printf(*args)\n    raise Exception(chalkf('red', mode = str)(s))\n"
  },
  {
    "name": "warn",
    "text": "def warn(*args, **kwargs):\n    if kwargs.get('required'):\n        raise Exception(chalkf('red', mode = str)(args[0]))\n    red(*args)\n    prompt('Exit')\n\n"
  },
  {
    "name": "getChunks",
    "text": "def getChunks(s):\n    r = '\\n+(?=[\\w.#])'\n    trim = lambda x: x.strip()\n    items = re.split(r, s.strip())\n    return map(items, trim)\n"
  },
  {
    "name": "ask",
    "text": "def ask(*args):\n    s = printf(*args)\n    return input(chalkf('blue', mode = str)(s + ': '))\n"
  },
  {
    "name": "printf",
    "text": "def printf(s, *args):\n    count = -1\n    def runner(x):\n        nonlocal count\n        count += 1\n        return args[count]\n    return re.sub('%s', runner, s)\n"
  },
  {
    "name": "confirm",
    "text": "def confirm(message, *args):\n    s = printf(message, *args)\n    red('CONFIRM ' + capitalize(s), 'Give input to proceed')\n    a = input()\n    if not a:\n        warn('Confirmation was not accepted', required = True)\n        \n"
  },
  {
    "name": "getBackupFile",
    "text": "def getBackupFile(file):\n    files = os.listdir(budir)\n    f = lambda x: re.sub('\\.\\d+-\\d+-\\d+', '', x) == file\n    files = filter(files, f)\n    return npath(budir, files[-1])\n"
  },
  {
    "name": "checkBackup",
    "text": "def checkBackup(file):\n    originalFile = file\n    file = getBackupFile(file)\n    print(read(file))\n    blue('file', file)\n    blue(linebreak)\n    blue('original file', originalFile)\n    blue('text', read(originalFile))\n    blue(linebreak)\n"
  },
  {
    "name": "revert",
    "text": "def revert(file):\n    file = getBackupFile(file)\n    dprompt2(file)\n    if 'vimrc' in file:\n        return cfile(file, '/home/kdog3682/.vimrc')\n    if 'functions2' in file:\n        return cfile(file, '/home/kdog3682/.vim/ftplugin/functions2.vim')\n\n    return 123\n    dir = dir2023\n    localPath = npath(dir, re.sub('\\.\\d+-\\d+-\\d+', '', file) )\n    cfile(file, localPath)\n"
  },
  {
    "name": "assertion",
    "text": "def assertion(arg, requirement=None, message=None):\n    if isFunction(requirement):\n        if requirement(arg):\n            return \n        red('Assertion requirement was not met', requirement.__name__)\n        red('Arg', arg)\n        raise Exception(message or '')\n    else:\n        if not arg:\n            red('Assertion was not met', 'the arg is null')\n            raise Exception(message or '')\n"
  },
  {
    "name": "isHtmlFile",
    "text": "def isHtmlFile(x):\n    return getExtension(x) == 'html'\n\n"
  },
  {
    "name": "makeSampleNestedFolder",
    "text": "def makeSampleNestedFolder(dir=trashdir):\n    files = [\n        'abc/fileA.js',\n        'abc/fileB.js',\n        'abc/fileC.js',\n        'abc/def/fileD.js',\n        'abc/def/fileE.js',\n        'abc/def/fileF.js',\n    ]\n    f = lambda file: forceWrite(os.path.join(dir, file), 'hi')\n    map(files, f)\n    pprint(getFiles(dir, recursive=1))\n"
  },
  {
    "name": "forceWrite",
    "text": "def forceWrite(file, s):\n    head, tail = os.path.split(file)\n    if not isdir(head):\n        mkdir(head)\n    if not s:\n        with open(file, \"w\") as _f:\n            _f.write('')\n    else:\n        write(file, s)\n"
  },
  {
    "name": "removeHead",
    "text": "def removeHead(s):\n    known = [\n        '/home/kdog3682/2023',\n        '/home/kdog3682/2023/dist',\n    ]\n    for known in known:\n        if known in s:\n            s = s.replace(known, '')\n            break\n\n    if s.startswith('/'):\n        s = s[1:]\n\n    return s\n\n\n"
  },
  {
    "name": "shell",
    "text": "def shell(*args):\n    def fixError(s):\n        known = []\n        if s in known:\n            return ''\n        r = '^(?:hint)'\n        if test(r, s, flags=re.I):\n            return ''\n        return s\n\n    def fixArg(s):\n        if \"\\n\" in s:\n            return ';'.join(linegetter(s))\n        return s\n        \n    from subprocess import Popen, PIPE\n\n    command = ','.join(map2(flat(args), fixArg))\n    process = Popen(command, stdout=PIPE, stderr=PIPE, shell=True)\n    data = process.communicate()\n    success, error = [decode(d).strip() for d in data]\n    error = fixError(error)\n\n    blue('success', success)\n    blue('error', error)\n\n    return dict(success=success, error=error)\n"
  },
  {
    "name": "javascript",
    "text": "def javascript(file, *args):\n    return shell('node', file, args)\n"
  },
  {
    "name": "python",
    "text": "def python(file, *args):\n    return shell('node3', file, args)\n"
  },
  {
    "name": "parseRedditString",
    "text": "def parseRedditString(s):\n    r = '(\\w+) (.*?)  ([\\w\\W]+)'\n    m = search(r, s)\n    if not m:\n        return \n    a, b, c = m\n    subreddit = env.subreddits.get(a, a)\n    title = capitalizeTitle(b)\n    body = toParagraph(c)\n    return (subreddit, title, body)\n"
  },
  {
    "name": "capitalizeTitle",
    "text": "def capitalizeTitle(title):\n    if isCapitalized(title):\n        return title\n    smallWords = [\"a\", \"an\", \"the\", \"and\", \"but\", \"or\", \"for\", \"nor\", \"on\", \"at\", \"to\", \"from\", \"by\", \"with\"]\n\n    def cap(word, i):\n        if i == 0 or word.lower() not in smallWords:\n            return word.capitalize()\n        else:\n            return word\n\n    words = title.split()\n    s = [cap(w, i) for i,w in enumerate(words)]\n    return \" \".join(s)\n"
  },
  {
    "name": "shared",
    "text": "def shared(a, b):\n    return list(set(a) & set(b))\n"
  },
  {
    "name": "getArgsKwargs",
    "text": "def getArgsKwargs(fn, config, transform=None):\n    argList, kwargList = getParameters2(fn)\n\n    store = {}\n    def get(key):\n        if key == 'config':\n            return {k:toArgument(v) for k,v in config.items()}\n        try:\n            a = config.get(key)\n            t = transform.get(key) if transform else None\n            value = t(a) if t else a\n            store[key] = value\n            return value\n        except Exception as e:\n            error = str(e)\n            message = 'the error is in the transformer. Please Exit.'\n            transformer = transform.get(key)\n            prompt({\"error\": error, \"message\": message, \"transformer\": transformer, \"key\": key, \"value\": a})\n            raise e\n    \n    fnArgs = filter(map2(argList, lambda x: get(x)))\n    fnKwargs = reduce(kwargList, lambda x: [x, get(x)])\n    blue('ParamRef @getArgsKwargs', store)\n    return [fnArgs, fnKwargs]\n"
  },
  {
    "name": "prettyProse",
    "text": "def prettyProse(s):\n    return s\n"
  },
  {
    "name": "getParameters",
    "text": "def getParameters(s):\n    m = search('\\((.*?)\\)', s)\n    if m:\n        parts = re.split(', *', m)\n        args = []\n        kwargs = []\n        for part in parts:\n            if test('\\*\\w', part):\n                continue\n            elif test('\\w+ *=', part):\n                kwargs.append(re.split(' *= *', part))\n            else:\n                args.append(part)\n        return [args, kwargs]\n"
  },
  {
    "name": "getParameters2",
    "text": "def getParameters2(fn):\n    import inspect\n    signature = str(inspect.signature(fn))\n    raw = signature[1:-1].split(', ')\n    args = []\n    kwargs = []\n    for arg in raw:\n        if '*' in arg:\n            continue\n        if '=' in arg:\n            kwargs.append(arg.split('=')[0])\n        else:\n            args.append(arg)\n\n    return [args, kwargs]\n\n"
  },
  {
    "name": "compose",
    "text": "def compose(*functions):\n    def composed(*args, **kwargs):\n        result = None\n        for i, fn in enumerate(reversed(flat(functions))):\n            result = fn(*args, **kwargs) if i == 0 else fn(result)\n\n        return result\n\n    return composed\n"
  },
  {
    "name": "mapFilter",
    "text": "def mapFilter(items, fn = None):\n    store = []\n    for item in list(items):\n        if fn:\n            value = fn(item)\n            if hasValue(value):\n                if isinstance(value, bool):\n                    store.append(item)\n                else:\n                    store.append(value)\n        elif hasValue(item):\n            store.append(item)\n    return store\n"
  },
  {
    "name": "packageManager",
    "text": "def packageManager(fn):\n    args = sys.argv\n    if len(args) > 1:\n        fn(*map(args[1:], toArgument))\n\n\n"
  },
  {
    "name": "toCallableFromConfig",
    "text": "def toCallableFromConfig(name, params, config):\n    args, kwargs = params\n    store = []\n    imports = []\n    beforeRef = {\n            'g': {\n                'import': 'from githubscript2 import GithubController',\n                'value': 'g = GithubController()',\n            },\n    }\n    imports = []\n    values = []\n    for i, arg in enumerate(args):\n        if i == 0 and config.get('arg') and not config.get(arg):\n            push(store, config.get('arg'))\n            continue\n\n        v = config.get(arg)\n        if v == None:\n            ref = beforeRef.get(arg)\n            if ref:\n                imports.append(ref.get('import'))\n                values.append(ref.get('value'))\n                push(store, arg)\n        else:\n            push(values, createBinding(arg, v))\n            push(store, arg)\n    for a,b in kwargs:\n        v = config.get(a)\n        if v != None:\n            push(store, createBinding(a, v))\n\n    top = join(join(imports), join(values))\n    if top:\n        top = '\\n\\n' + top + '\\n\\n'\n    return [stringCall2(name, store), top]\n"
  },
  {
    "name": "stringCall2",
    "text": "def stringCall2(fn, *args):\n    return f\"{fn}({', '.join(map2flat(args))})\"\n"
  },
  {
    "name": "tomorrow",
    "text": "def tomorrow():\n    date = datetime.today() + timedelta(days=1)\n    return date.strftime(\"%m-%d-%Y\")\n"
  },
  {
    "name": "pick",
    "text": "def pick(items, display = identity, get = identity):\n\n    for i, item in enumerate(items):\n        blue(i + 1, display(item))\n\n    indexes = rangeFromString(input('Select 1-based indexes: '))\n\n    store = [get(el) for i,el in enumerate(items) if i in indexes]\n    return smallify(store)\n\n"
  },
  {
    "name": "getIdentifier",
    "text": "def getIdentifier(s):\n    r = '^(?:class |def )(\\w+)|^(\\w+) *= *'\n    m = search(r, s)\n    if m:\n        return m[0] or m[1]\n"
  },
  {
    "name": "codeLibrary",
    "text": "def codeLibrary(s):\n    r = '\\n+(?=class|def|\\w+ *=)'\n    items = re.split(r, s)\n    \n    def runner(s):\n        text = s.strip()\n        name = getIdentifier(text)\n        if name:\n            params = getParameters(text)\n            return { 'name': name, 'params': params, 'text': text, }\n    \n    return mapFilter(items, runner)\n"
  },
  {
    "name": "Black",
    "text": "def Black(file):\n    import black\n\n    # 75 represents my current vim setup max length\n    config = black.FileMode(line_length=75, string_normalization=True)\n    prompt(config)\n    rpw(file, lambda s: black.format_str(s, mode = config))\n"
  },
  {
    "name": "singleQuote",
    "text": "def singleQuote(s):\n    return f\"'{s}'\"\n\n"
  },
  {
    "name": "dateTheFile",
    "text": "def dateTheFile(name):\n    e = getExtension(name)\n    name = removeExtension(name)\n    return name + '.' + datestamp() + '.' + e\n"
  },
  {
    "name": "v1",
    "text": "def v1(file):\n    outpath = dateTheFile(npath(depdir, file))\n    confirm('moving %s to %s', file, outpath)\n    mfile(file, outpath)\n"
  },
  {
    "name": "announce",
    "text": "def announce(a, b = None):\n    if not b:\n        stop('The value for announce() is empty and is required.')\n\n    blue(linebreak)\n    print(chalk('key:   ', 'blue'), a)\n    if isPrimitive(b):\n        print(chalk('value: ', 'blue'), b)\n    else:\n        print(chalk('value', 'blue'))\n        pprint(b)\n\n    blue(linebreak)\n    message = 'Input <C-C> to exit the announcement '\n    input(chalk(message, 'red'))\n\n"
  },
  {
    "name": "createBinding",
    "text": "def createBinding(a, b):\n    return f\"{a} = {toStringArgument(b)}\"\n"
  },
  {
    "name": "toStringArgument",
    "text": "def toStringArgument(s):\n    if test('\\n', s):\n        escaped = re.sub('\\n', '\\\\\\\\n', s)\n        return f'\"\"\"{escaped}\"\"\"'\n    elif isNumber(s):\n        return s\n    elif isJsonParsable(s):\n        return json.dumps(s)\n    else:\n        return singleQuote(s)\n"
  },
  {
    "name": "getChalkColor",
    "text": "def getChalkColor(color):\n    reset = \"\\033[0m\"\n    red = \"\\033[31m\"\n    green = \"\\033[32m\"\n    yellow = \"\\033[33m\"\n    blue = \"\\033[34m\"\n    purple = \"\\033[35m\"\n    cyan = \"\\033[36m\"\n    bold = \"\\033[1m\"\n\n    colors = {\n        'blue': blue,\n        'red': red,\n        'green': green,\n        'yellow': yellow,\n        'purple': purple,\n        'cyan': cyan,\n        'reset': reset,\n        'bold': bold,\n        '': '',\n    }\n    return colors[color]\n"
  },
  {
    "name": "chalk",
    "text": "def chalk(s, color, bold = ''):\n    color = getChalkColor(color)\n    reset = getChalkColor('reset')\n    bold = getChalkColor('bold') if bold else ''\n    return color + bold + s + reset \n"
  },
  {
    "name": "mdate",
    "text": "def mdate(f):\n    return int(os.path.getmtime(f))"
  },
  {
    "name": "mostRecent",
    "text": "def mostRecent(dir, n=1, reverse=0, **kwargs):\n    from glob import glob\n\n    files = glob(dir + \"/*\") if isString(dir) else dir\n\n    if kwargs:\n        files = filter(files, checkpointf(**kwargs))\n\n    files.sort(key=mdate)\n\n    if not files:\n        return None\n    if n == 1:\n        return files[-1]\n    elif isNumber(n):\n        return files[-n:]\n    else:\n        if reverse:\n            return files[-n:][::-1]\n        else:\n            return files[-n:]\n"
  },
  {
    "name": "mostRecentFileGroups",
    "text": "def mostRecentFileGroups(dir=dldir, minutes=3, reverse=True, ignore = []):\n    files = getFiles(dir, sort=1, reverse=reverse)\n    store = []\n    lastDate = 0\n\n    for i, file in enumerate(files):\n        if getFileName(file) in ignore:\n            continue\n        if test('\\(\\d\\)', file):\n            continue\n        date = mdate(file)\n        name = tail(file)\n        d = delta(date, lastDate)\n        limit = toSeconds(minutes=minutes)\n        passes = d < limit or lastDate == 0\n        if passes:\n            store.append(file)\n        else:\n            return store\n\n        lastDate = date\n"
  },
  {
    "name": "moveRecentFileGroupToActiveDir",
    "text": "def moveRecentFileGroupToActiveDir(dir = dldir):\n    group = mostRecentFileGroups(dir = dir, minutes = 10)\n    for file in group:\n        newName = ask('Choose a new tail for %s', file)\n        mfile(file, npath(newName))\n"
  },
  {
    "name": "printError",
    "text": "def printError(e):\n    red(str(e))\n"
  },
  {
    "name": "smartFileGetter",
    "text": "def smartFileGetter(x):\n    if isString(x):\n        if isfile(x):\n            return x\n        elif isfile(smart_path(x)):\n            return smart_path(x)\n\n\n"
  },
  {
    "name": "dirFromFile",
    "text": "def dirFromFile(file):\n    if file.startswith(\"/\"):\n        return head(file)\n    e = getExtension(file)\n    if e == 'py': return pydir\n    if e == 'css' or e == 'js' or e == 'html': return dir2023\n    return dir2024\n"
  },
  {
    "name": "smartPath",
    "text": "def smartPath(file):\n    return env.fileDict.get(file) or npath(dir, dirFromFile(file))"
  },
  {
    "name": "smartnpath",
    "text": "def smartnpath(file):\n\treturn npath(dirFromFile(file), file)"
  },
  {
    "name": "backup",
    "text": "def backup(x):\n    file = smartFileGetter(x)\n    cfile(file, npath(budir, dateTheFile(file)))\n"
  },
  {
    "name": "removeGithubStuff",
    "text": "def removeGithubStuff():\n    cmd       =f\"\"\"\n        cd {pydir}\n        git rm --cached env.py\n        git rm -r __pycache__\n        git commit -m \"removing sensitive stuff\"\n        git push\n    \"\"\"\n    shell(cmd)\n"
  },
  {
    "name": "glf",
    "text": "def glf(dir=dldir, **kwargs):\n    if kwargs.get('q'):\n        return find_file(dir=dir, q=kwargs.get('q'))\n    file = mostRecent(dir, **kwargs)\n    return file\n\n"
  },
  {
    "name": "printer",
    "text": "def printer():\n    a = '#\\w{6}\\\\b'\n    r = input('regex:  ')\n    r = re.sub('b', '\\\\b', r)\n    s = request(input('url:  '))\n    m = unique(re.findall(r, s))\n    clip(m)\n    return\n    s = sdf\n    rrequest\n    return\n    store=[]\n    for n in range(1, 13 + 1):\n        url=f'https://archive.org/stream/aseriesofunfortunateevents10bylemonysnicket/A%20Series%20of%20Unfortunate%20Events%20{n}%20by%20Lemony%20Snicket_djvu.txt'\n        if isUrl(url):\n            s=request(url)\n            time.sleep(1)\n            store.append(s)\n            print(n)\n        else:\n            store.append('')\n    write('/home/kdog3682/2024/lemony.json', store)\n"
  },
  {
    "name": "ff",
    "text": "def ff(dir=dldir, **kwargs):\n    checkpoint = checkpointf(**kwargs)\n    return filter(absdir(dirGetter(dir)), checkpoint)\n\n"
  },
  {
    "name": "npath2",
    "text": "def npath2(dir, file):\n\treturn os.path.join(dir, tail(file))"
  },
  {
    "name": "writef",
    "text": "def writef(*args):\n\n    dir = os.path.join(*args)\n    mkdir(dir)\n\n    def runner(file, payload):\n        outpath = npath2(dir, file)\n        write(outpath, payload)\n        return outpath\n\n    return runner\n"
  },
  {
    "name": "appendself",
    "text": "def appendself(x):\n    s = createVariable2('temp', x)\n    append(self(), s)\n\n\n"
  },
  {
    "name": "getFiles3",
    "text": "def getFiles3(dir, **kwargs):\n\n    kwargs['regex'] = 'license|readme|package|ts$'\n    kwargs['flags'] = re.I\n    kwargs['anti'] = 1\n    checkpoint = checkpointf(**kwargs)\n    # return checkpoint('asd.ts')\n    dir = dirGetter(dir)\n\n    def parse(file, depth):\n        if isIgnoredFile2(file):\n            return \n        elif isdir(file):\n            return runner(file, depth + 1)\n        elif checkpoint(file):\n            return file\n\n    def runner(dir, depth=0):\n        children = []\n        for file in absdir(dir):\n            try:\n                push(children, parse(file, depth))\n            except Exception as error:\n                errorPrompt(file, error)\n\n        return children\n\n    return flat(runner(dir))\n\n"
  },
  {
    "name": "see_npm_repo_files",
    "text": "def see_npm_repo_files(key):\n    files = getFiles3(npmdir + key)\n\n\n"
  },
  {
    "name": "templater_map",
    "text": "def templater_map(items, template):\n    items = to_array(items)\n    return [templater2(template, item) for item in items]\n"
  },
  {
    "name": "log_files",
    "text": "def log_files(files):\n    s = templater_map(files, '$timestamp $1')\n    append('/home/kdog3682/2024/files.log', s)\n"
  },
  {
    "name": "templater2",
    "text": "def templater2(template, ref):\n\n    if isPrimitive(ref):\n        ref = [str(ref)]\n    regex = \"\\$(\\w+)\"\n\n    def fallback(x):\n        expr = x + '()'\n        return str(eval(expr))\n\n    def parser(x):\n        if isNumber(x) and isArray(ref):\n            return ref[int(x) - 1]\n\n        if isObject(ref):\n            return ref.get(x) or fallback(x)\n\n        return fallback(x)\n\n    def runner(x):\n        return parser(x.group(1))\n\n    return re.sub(regex, runner, template)\n\n"
  },
  {
    "name": "to_array",
    "text": "def to_array(x):\n    if isArray(x):\n        return x\n    if not x:\n        return []\n    return [x]\n\n"
  },
  {
    "name": "newline_indent",
    "text": "def newline_indent(s):\n    s += \"\\n\"\n    if is_array(s):\n        s = join(s, \",\\n\")\n    s += indent(s)\n    s += \"\\n\"\n    return s\n"
  },
  {
    "name": "hr",
    "text": "def hr(n = 30, newline = 0):\n    s = \"\\n\" if newline else \"\"\n    return \"-\" * n + s\n"
  },
  {
    "name": "chalk",
    "text": "def chalk(s, color = \"\", bold = None):\n    color = env.chalk_colors.get(color)\n    reset = env.chalk_colors.get(\"reset\")\n    bold = env.chalk_colors.get(\"bold\") if bold else \"\"\n    return color + stringify(s) + bold + reset\n"
  },
  {
    "name": "blue",
    "text": "def blue(x, bold = 0):\n    return chalk(x, color = \"blue\", bold = bold)\n"
  },
  {
    "name": "blue_colon",
    "text": "def blue_colon(a, b):\n    print(blue(a, 0), \":\", blue(b, 0))\n"
  },
  {
    "name": "map",
    "text": "def map(items, fn):\n    \"\"\"\n        items (list|dict)\n        the fn is always spread for entries and dicts\n\n        it is rather inflexible\n        for flexiblity and enumeration, use a comprehension\n    \"\"\"\n    double = is_object(items) or is_nested_array(items)\n    entries = items.items() if is_object(items) else items\n    gn = lambda x: fn(*x) if double else fn(x)\n\n    store = []\n    for item in entries:\n        try:\n            push(store, gn(item))\n        except Exception as e:\n            kwargs = get_local_kwargs(\"e, item\")\n            inform(kwargs, header = \"an error has occured\")\n    return store\n"
  },
  {
    "name": "push",
    "text": "def push(store, item):\n    if is_defined(item):\n        store.append(item) \n"
  },
  {
    "name": "is_defined",
    "text": "def is_defined(x):\n    return x != None\n"
  },
  {
    "name": "is_array",
    "text": "def is_array(x):\n    try:\n        array_types = ['list', 'tuple', 'dict_keys']\n        return type(x).__name__ in array_types\n    except Exception as e:\n        return False\n    \n"
  },
  {
    "name": "test",
    "text": "def test(s, r, flags = 0):\n    return is_string(s) and bool(match(s, r, flags))\n"
  },
  {
    "name": "is_string",
    "text": "def is_string(x):\n    return type(x) == str\n"
  },
  {
    "name": "is_integer",
    "text": "def is_integer(x):\n    return type(x) == int\n"
  },
  {
    "name": "is_number",
    "text": "def is_number(x):\n    r = \"^\\d+(?:[.,]\\d+)?$\"\n    return type(x) == int or type(x) == float or test(x, r)\n"
  },
  {
    "name": "get_match",
    "text": "def get_match(m):\n    if not m:\n        return \"\"\n    g = m.groups()\n    if g:\n        if len(g) == 1:\n            return g[0]\n        else:\n            return g\n    return m.group(0)"
  },
  {
    "name": "match",
    "text": "def match(s, r, flags = 0):\n    m = re.search(r, str(s), flags)\n    return get_match(m)\n"
  },
  {
    "name": "get_extension",
    "text": "def get_extension(x):\n    if x in env.file_extensions:\n        return x\n    return Path(x).suffix.lstrip(\".\")\n"
  },
  {
    "name": "has",
    "text": "def has(x, key):\n    try:\n        return key in x\n    except Exception as e:\n        return False\n"
  },
  {
    "name": "add_extension",
    "text": "def add_extension(x, y):\n    e = get_extension(y)\n    if e == \"\": e = y\n    return x + \".\" + e if not has_extension(x) else x\n"
  },
  {
    "name": "has_extension",
    "text": "def has_extension(x):\n    return bool(get_extension(x))\n"
  },
  {
    "name": "append",
    "text": "def append(file, content):\n    assert content\n    with open(normalize_file(file), \"a\") as f:\n        f.write(stringify(content))\n"
  },
  {
    "name": "write",
    "text": "def write(file, content, dir = None, ext = None, log = False, ask = 0, openIt = 0):\n    \"\"\"\n        the file is normalized with dir and ext if provided\n        if content is a str, write as text\n        else write as json\n    \"\"\"\n    assert content\n    filename = normalize_file(file, dir, ext)\n    if ask:\n        print(content) if is_string(content) else pprint(content)\n        if not input(\"do you wish to write this content?\"):\n            return\n\n    if is_string(content):\n        with open(filename, \"w\") as f:\n            f.write(content)\n            print(f\"wrote file: {filename}\")\n    else:\n        with open(filename, \"w\") as f:\n            json.dump(content, f, indent=2, ensure_ascii=False)\n            print(f\"wrote file: {filename} as json\")\n\n    if log:\n        log_file(filename)\n    if openIt:\n        view(filename)\n\n"
  },
  {
    "name": "npath",
    "text": "def npath(dir, file):\n    return str(Path(dir, tail(file)))\n"
  },
  {
    "name": "normalize_file",
    "text": "def normalize_file(file, dir = None, ext = None):\n    if ext:\n        file = add_extension(file, ext)\n    if dir:\n        return npath(get_dir(dir), file)\n\n    if test(file, \"^~\"):\n        file = sub(file, \"^~\", \"/home/kdog3682\")\n\n    if test(file, \"^/\"):\n        return file\n\n    def dir_from_file(file):\n        filetype = get_filetype(file)\n        return env.dirdict.get(filetype, env.dirdict.get(\"default\"))\n        \n    return npath(dir_from_file(file), file)\n"
  },
  {
    "name": "trim",
    "text": "def trim(s):\n    return str(s).strip()\n"
  },
  {
    "name": "join_lines",
    "text": "def join_lines(*args):\n    def runner(args):\n        s = \"\"\n        for item in args:\n            if is_array(item):\n                s += runner(item) + \"\\n\\n\"\n            else:\n                item = str(item)\n                delimiter = \"\\n\\n\" if test(trim(item), \"\\n\") else \"\\n\"\n                s += item + delimiter\n        return s\n        \n    return trim(runner(args))\n\n        "
  },
  {
    "name": "is_primitive",
    "text": "def is_primitive(x):\n    return is_string(x) or is_number(x)\n\n    "
  },
  {
    "name": "append_json",
    "text": "def append_json(file, data):\n    assert data\n    file = normalize_file(file)\n    store = read_json(file) or [] if is_array(data) else {}\n    store.extend(data) if is_array(data) else store.update(data)\n    announce(\"appending $1 items to $2, which now has: $3 items\", str(len(data)), file, str(len(store)))\n    write_json(file, store)\n    return file\n\n"
  },
  {
    "name": "is_array_dictionary",
    "text": "def is_array_dictionary(x):\n    return is_object(x) and is_array(x.values()[0])\n"
  },
  {
    "name": "is_object_array",
    "text": "def is_object_array(x):\n    return is_array(x) and len(x) and is_object(x[0])\n"
  },
  {
    "name": "read_json",
    "text": "def read_json(file):\n    file = abspath(file)\n    try:\n        with open(file) as f:\n            return json.load(f)\n    except FileNotFoundError as e:\n        return None\n    except Exception as e:\n        raise e\n"
  },
  {
    "name": "everyf",
    "text": "def everyf(*tests):\n    def checkpoint(x):\n        for test in flat(tests):\n            if not test(x):\n                return False\n        return True\n    return checkpoint\n\n"
  },
  {
    "name": "head",
    "text": "def head(x):\n    return Path(x).parent\n"
  },
  {
    "name": "tail",
    "text": "def tail(x):\n    return Path(x).name\n"
  },
  {
    "name": "strftime",
    "text": "def strftime(key = \"iso8601\", dt=None):\n    templates = {\n        \"iso8601\": \"%Y-%m-%d\",\n        \"simple_date\": \"%Y-%m-%d\",\n        \"simple_time\": \"%H:%M:%S\",\n        \"datetime\": \"%A %B %d %Y, %-I:%M:%S%p\",\n        # Add more templates as needed\n    }\n\n    if dt is None:\n        dt = datetime.now()\n\n    template = templates.get(key, key)\n    return dt.strftime(template)\n"
  },
  {
    "name": "timestamp",
    "text": "def timestamp(x=None):\n    t = type(x)\n\n    if t == datetime: return int(x.timestamp())\n    if t == str: \n        p = Path(x)\n        assert is_file(p)\n        return int(p.stat().st_mtime)\n\n    return int(datetime.now().timestamp())\n\n"
  },
  {
    "name": "clear",
    "text": "def clear(x):\n    x = normalize_file(x)\n    if is_file(x):\n        if not debug:\n            with open(x, \"w\") as f:\n                pass\n        print(f\"File created: {x}\")\n"
  },
  {
    "name": "path_exists",
    "text": "def path_exists(x):\n    if type(x) == PosixPath:\n        return x.exists()\n    if type(x) == str:\n        return Path(x).exists()\n\n"
  },
  {
    "name": "is_file",
    "text": "def is_file(x):\n    if type(x) == PosixPath:\n        return x.exists()\n    if type(x) == str:\n        return os.path.isfile(os.path.expanduser(x))\n"
  },
  {
    "name": "is_function",
    "text": "def is_function(x):\n    return callable(x)\n"
  },
  {
    "name": "templater",
    "text": "def templater(s, *args, **kwargs):\n    def on_error(x):\n        return f\"Error: Key {x} not found\"\n\n    def parser(x):\n        if is_array(ref):\n            return ref[int(x) - 1] if is_number(x) else ref.pop(0)\n        if is_object(ref):\n            return stringify(ref.get(x), indent = 0) or on_error(x)\n\n    def runner(x):\n        return parser(x.group(1))\n\n    if not args:\n        return s\n    ref = (list(args) if is_primitive(args[0]) else args[0])\n    r = \"\\$(\\w+)\"\n\n    return re.sub(r, runner, s, kwargs.get(\"flags\", 0))\n"
  },
  {
    "name": "prompt",
    "text": "def prompt(*args):\n    if len(args) == 1:\n        pprint(args[0])\n        return input()\n    elif is_string(args[0]):\n        blue_colon(*args)\n        return input()\n    else:\n        print(\"printing multiple prompt items\\n\")\n        for arg in args:\n            print(chalk(arg, \"blue\"))\n            print(\"-\" * 20)\n        print()\n        return input()\n\n"
  },
  {
    "name": "to_array",
    "text": "def to_array(x):\n    if x == None:\n        return []\n    if is_array(x):\n        return x\n    return [x]\n"
  },
  {
    "name": "exists",
    "text": "def exists(x):\n    return bool(x)\n"
  },
  {
    "name": "filter",
    "text": "def filter(items, x = exists, anti = False, flags = 0):\n    checkpoint = testf(x, anti = anti, flags = flags)\n    return [el for el in items if checkpoint(el)]\n"
  },
  {
    "name": "split",
    "text": "def split(s, r = \"\\s+\", flags = 0):\n    base = re.split(r, s.strip(), flags = flags)\n    items = map(base, trim)\n\n    if items[0] == \"\":\n        items.pop(0)\n    if items[-1] == \"\":\n        items.pop(-1)\n    return items\n"
  },
  {
    "name": "package_manager",
    "text": "def package_manager(fn, override = None, outpath = None, **kwargs):\n    def transform(x):\n        x = shellunescape(x)\n        if is_number(x):\n            return int(x)\n        if is_empty_quote(x):\n            return ''\n        return x\n\n    value = None\n    if override:\n        value = fn(override)\n    elif len(sys.argv) > 1:\n        args = sys.argv[1:]\n        computedArgs = [transform(arg) for arg in args]\n        [_kwargs, args]  = partition(computedArgs, is_object)\n        if len(_kwargs) == 1:\n            kwargs.update(_kwargs[0])\n            value = fn(*args, **kwargs)\n        else:\n            # print(type(kwargs[0]))\n            # return\n            # for computedArg in computedArgs:\n                # print(type(computedArg))\n            # return\n            # return pprint(computedArgs)\n            value = fn(*computedArgs)\n            \n    else:\n        print(\"package manager is not active\")\n\n    if value:\n        if outpath:\n            write(outpath, value)\n        else:\n            pprint(value)\n        print(\"success!\")\n"
  },
  {
    "name": "to_argument",
    "text": "def to_argument(x):\n    if is_number(x):\n        return int(x)\n    return x\n"
  },
  {
    "name": "testf",
    "text": "def testf(x, flags=0, anti=0, key = 0):\n    fn = x\n    if is_array(x):\n        regex = '|'.join(x)\n        fn = lambda s: test(s, regex, flags = flags)\n    elif is_string(x):\n        fn = lambda s: test(s, x, flags = flags)\n\n    if anti and key:\n        return lambda x: not fn(x[key])\n    elif anti:\n        return lambda x: not fn(x)\n    elif key:\n        return lambda x: fn(x[key])\n    else:\n        return fn\n\n"
  },
  {
    "name": "is_object",
    "text": "def is_object(x):\n    return type(x) == dict\n"
  },
  {
    "name": "is_nested_array",
    "text": "def is_nested_array(x):\n    return x and is_array(x) and is_array(x[0])\n"
  },
  {
    "name": "is_today",
    "text": "def is_today(x):\n    n = x\n    if hasattr(x, \"created_utc\"):\n        n = x.created_utc\n\n    dt = datetime.fromtimestamp(n)\n    today = datetime.today()\n    return dt.date() == today.date()\n"
  },
  {
    "name": "datestamp",
    "text": "def datestamp(x):\n    strife = \"%A %B %d %Y, %-I:%M:%S%p\"\n    return datetime.fromtimestamp(x).strftime(strife)\n"
  },
  {
    "name": "flat",
    "text": "def flat(items):\n    def runner(items):\n        for item in items:\n            if is_array(item):\n                runner(item)\n            elif is_defined(item):\n                store.append(item)\n\n    store = []\n    runner(items)\n    return store\n\n\n"
  },
  {
    "name": "is_url",
    "text": "def is_url(x):\n    return test(x, \"http\")\n"
  },
  {
    "name": "get_constructor_name",
    "text": "def get_constructor_name(x):\n    return type(x).__name__\n\n"
  },
  {
    "name": "is_dir",
    "text": "def is_dir(x):\n    return x and Path(x).is_dir()\n"
  },
  {
    "name": "get_dir",
    "text": "def get_dir(dir):\n    if is_dir(dir):\n        return dir\n    dir = env.dirdict.get(dir)\n    if is_dir(dir):\n        return dir\n    panic(\"not a valid directory: $dir\")\n"
  },
  {
    "name": "path",
    "text": "def path(dir):\n    return Path(get_dir(dir))\n\n"
  },
  {
    "name": "is_recent_file",
    "text": "def is_recent_file(file, **kwargs):\n    if not is_file(file): return True\n    seconds = to_seconds(**kwargs)\n    time = datetime.now().timestamp() \n    file_time = mdate(file)\n    # print(mdate(file))\n    # print(time)\n    # print(seconds)\n    return mdate(file) > time - seconds\n"
  },
  {
    "name": "mdate",
    "text": "def mdate(f):\n    return os.path.getmtime(f)"
  },
  {
    "name": "most_recent_file",
    "text": "def most_recent_file(dir = \"downloads\", ext = None):\n    files = absdir(get_dir(dir))\n    if ext:\n        files.sort(key = mdate, reverse = True)\n        for file in files:\n            if get_extension(file) == ext:\n                return file\n    else:\n        return max(files, key=mdate)\n\n"
  },
  {
    "name": "is_json_parsable",
    "text": "def is_json_parsable(x):\n    return is_string(x) and test(x, \"^\\s*[\\{\\[]\") and test(x, \"[\\}\\]]\\s*$\")\n"
  },
  {
    "name": "is_jsonable",
    "text": "def is_jsonable(x):\n    return is_array(x) or is_object(x)\n"
  },
  {
    "name": "append_self",
    "text": "def append_self(*args):\n    value = None\n    name = None\n    if len(args) == 1:\n        x = args[0]\n    else:\n        name, x = args\n\n    if empty(x):\n        return\n\n    value = dump_json(x) if is_jsonable(x) else str(x)\n    if name:\n        value = f\"{name} = {value}\"\n\n    append(sys.argv[0], \"\\n\" + value)\n"
  },
  {
    "name": "dump_json",
    "text": "def dump_json(x, indent = 4):\n    return json.dumps(x, indent=indent, ensure_ascii=False)\n"
  },
  {
    "name": "empty",
    "text": "def empty(x):\n    if x == 0:\n        return False\n    if x:\n        return False\n    return True\n"
  },
  {
    "name": "get_error_name",
    "text": "def get_error_name(e):\n    return e.__class__.__name__\n"
  },
  {
    "name": "choose",
    "text": "def choose(x):\n    items = list(x)\n    if len(items) == 1:\n        return items[0]\n\n    for i, item in enumerate(items):\n        print(blue(i + 1), item)\n\n    a = input(\"\\nchoose 1-based indexes\\n\")\n\n    if a == \"\":\n        return \n\n    return items[int(a) - 1]\n\n"
  },
  {
    "name": "is_private",
    "text": "def is_private(s):\n\treturn test(tail(s), '^[._]')\n"
  },
  {
    "name": "open_url",
    "text": "def open_url(x):\n    webbrowser.open(x)\n"
  },
  {
    "name": "ofile",
    "text": "def ofile(file):\n    webbrowser.open(file)\n"
  },
  {
    "name": "view",
    "text": "def view(file):\n    webbrowser.open(file)\n"
  },
  {
    "name": "openpdf",
    "text": "def openpdf(file = \"/home/kdog3682/2024/test.pdf\"):\n    view(file)\n\n"
  },
  {
    "name": "clip",
    "text": "def clip(*args, outpath = 1, openIt = 0):\n    if len(args) == 0:\n        try:\n            return read_json(\"/home/kdog3682/2023/clip.js\")\n        except Exception as e:\n            return read(\"clip.js\")\n\n    payload = args[0]\n    ref = {\n        1: \"/home/kdog3682/2023/clip.js\",\n        2: \"/home/kdog3682/2023/clip2.js\",\n        3: \"/home/kdog3682/2023/clip3.js\",\n    }\n    file = ref[outpath]\n    write(file, stringify(payload), openIt = openIt)\n"
  },
  {
    "name": "stringify",
    "text": "def stringify(x, indent = 4):\n    if empty(x):\n        return \"\"\n    if type(x) == bytes:\n        return x.decode()\n    if is_primitive(x) or is_function(x):\n        return str(x)\n    try:\n        return dump_json(x, indent = indent)\n    except Exception as e:\n        return get_constructor_name(x)\n    \n"
  },
  {
    "name": "unique",
    "text": "def unique(a, b=None):\n    if b:\n        if is_array(a):\n            return list(set(a).difference(b))\n        if is_object(a):\n            return filter(a, lambda k, v: k not in b)\n    else:\n        return list(set(a))\n"
  },
  {
    "name": "mkdir",
    "text": "def mkdir(dir):\n    path = Path(dir)\n    try:\n        path.mkdir(parents=True, exist_ok=False)\n        print(f\"Directory '{path}' was created.\")\n    except FileExistsError:\n        print(f\"Directory '{path}' already exists.\")\n\n    return str(path)\n\n"
  },
  {
    "name": "re_wrap",
    "text": "def re_wrap(iterable, template = ''):\n    ref = {\n        '': '(?:$1)',\n        'start': '^(?:$1)\\\\b',\n        'b': \"\\\\b(?:$1)\\\\b\",\n        'bc': \"\\\\b($1)\\\\b\",\n    }\n    template = ref.get(template, template)\n    keys = list(iterable.keys() if is_object(iterable) else iterable)\n    symbols = map(keys, re.escape)\n    s = join(symbols, \"|\")\n    return re.sub('\\$1', s, template)\n\n"
  },
  {
    "name": "decode",
    "text": "def decode(x):\n    return x.decode(\"utf-8\")\n\n"
  },
  {
    "name": "rmdir",
    "text": "def rmdir(dir):\n    dir = os.path.expanduser(dir)\n    if not is_dir(dir):\n        return \n    shutil.rmtree(dir)\n    print(\"removing dir\", dir)\n"
  },
  {
    "name": "sub",
    "text": "def sub(s, r, rep, flags = 0, count = 0):\n    return re.sub(r, rep, s, flags = flags, count = count)\n"
  },
  {
    "name": "join",
    "text": "def join(x, delimiter = \" \"):\n    return delimiter.join(x)\n\n"
  },
  {
    "name": "chdir",
    "text": "def chdir(x):\n    os.chdir(x)"
  },
  {
    "name": "system_command",
    "text": "def system_command(template, *args, **kwargs):\n    from subprocess import Popen, PIPE\n    command = smart_dedent(templater(template, *args))\n\n    if env.GLOBAL_DEBUG_FLAG or kwargs.get(\"confirm\"):\n        inform(\"\"\"\n            this is the system_command to be executed:\n            ------------\n            $command\n            ------------\n        \"\"\")\n    else:\n        blue_colon(\"command\", command)\n\n    process = Popen(command, stdout=PIPE, stderr=PIPE, shell=True)\n    def fix(a, b):\n        if b.startswith(\"grep:\"):\n            b = \"\"\n        return (a, b)\n\n    data = process.communicate()\n    success, error = fix(*(decode(d) for d in data))\n    return { \"success\": success, \"error\": error }\n"
  },
  {
    "name": "is_public_path",
    "text": "def is_public_path(path):\n    return test(path.name, \"^\\w\")\n"
  },
  {
    "name": "colon_dict",
    "text": "def colon_dict(s):\n    items = re.split(\"^([\\w-]+): *\", s.strip(), flags=re.M)\n    items = map(items, trim)\n    if items[0] == \"\":\n        items.pop(0)\n    config = dict(partition(items))\n    return config\n"
  },
  {
    "name": "partition",
    "text": "def partition(arr, n = 2):\n\n    def partition_by_integer(arr, n):\n        store = []\n        for i in range(0, len(arr), n):\n            store.append(arr[i : i + n])\n        return store\n    def partition_by_function(arr, f):\n        store = [[], []]\n        for item in arr:\n            if f(item):\n                store[0].append(item)\n            else:\n                store[1].append(item)\n        return store\n\n    if is_string(n):\n        n = testf(n)\n    if is_function(n):\n        return partition_by_function(arr, n)\n    else:\n        return partition_by_integer(arr, n)\n"
  },
  {
    "name": "every",
    "text": "def every(a, b):\n    if is_array(b):\n        for item in a:\n            if item not in b:\n                return \n        return 1\n    for item in a:\n        if not b(item):\n            return \n    return 1"
  },
  {
    "name": "complete_overlap",
    "text": "def complete_overlap(x, y):\n    a = list(x).sort()\n    b = list(y).sort()\n    return json.dumps(a) == json.dumps(b)\n\n"
  },
  {
    "name": "not_none",
    "text": "def not_none(x):\n    return x != None\n"
  },
  {
    "name": "is_valid",
    "text": "def is_valid(x):\n    return x == 0 or x != None\n"
  },
  {
    "name": "assertion",
    "text": "def assertion(value, key = \"exists\", message = None, anti = 1):\n    ref = {\n        \"not_none\": not_none,\n        \"is_valid\": is_valid,\n        \"exists\": exists,\n    }\n    def parse(key):\n        if is_function(key):\n            if anti:\n                return lambda x: not key(x)\n            return key\n        elif key.startswith(\">\"):\n            limit = int(match(key, \"> *(.*)\"))\n            return lambda x: x > limit\n        elif key.startswith(\"<\"):\n            limit = int(match(key, \"< *(.*)\"))\n            return lambda x: x < limit\n        else:\n            return ref.get(key)\n\n    check = parse(key)(value)\n    if check:\n        return \n    raise CustomError(message or key)\n\n"
  },
  {
    "name": "reduce",
    "text": "def reduce(items, fn = identity):\n    store = {}\n\n    if is_object(items):\n        for k, v in items.items():\n            value = fn(k, v)\n\n            if not value:\n                continue\n            elif is_array(value) and len(value) == 2:\n                if value[1] != None:\n                    store[value[0]] = value[1]\n            else:\n                store[k] = value\n    else:\n        for item in list(items):\n            value = fn(item)\n\n            if not value:\n                continue\n            elif is_array(value) and len(value) == 2:\n                store[value[0]] = value[1]\n            else:\n                store[item] = value\n\n    return store\n\n"
  },
  {
    "name": "find",
    "text": "def find(iterable, fn):\n    fn = testf(fn)\n\n    for i, item in enumerate(list(iterable)):\n        if fn(item):\n            return item\n\n"
  },
  {
    "name": "read",
    "text": "def read(file):\n    file = abspath(file)\n    byte_files = [ \"img\", \"jpg\", \"svg\", ]\n    e = get_extension(file)\n    mode = \"rb\" if e in byte_files else \"r\"\n    with open(file, mode) as f:\n        return f.read()\n\n"
  },
  {
    "name": "shared",
    "text": "def shared(a, b):\n    return list(set(a) & set(b))\n\n"
  },
  {
    "name": "noop",
    "text": "def noop(*args, **kwargs):\n    return \n"
  },
  {
    "name": "default_path_ignore",
    "text": "def default_path_ignore(path: Path) -> bool:\n    \"\"\"\n        Used in various file finders.\n        Ignores dot files and node modules\n    \"\"\"\n    if test(path.name, \"^\\W|node_modules\"):\n        return True\n    return False\n"
  },
  {
    "name": "indent",
    "text": "def indent(x, indentation = 4):\n    return sub(x, \"^\", \" \" * indentation, flags = re.M)\n\n"
  },
  {
    "name": "remove_extension",
    "text": "def remove_extension(s):\n    return re.sub(\"(?:\\.json)?\\.\\w+$\", \"\", s)\n    "
  },
  {
    "name": "remove_python_comments",
    "text": "def remove_python_comments(s):\n    return sub(s, \"^#.+\\n*\", \"\", flags = re.M)\n\n"
  },
  {
    "name": "get_kwargs",
    "text": "def get_kwargs(s):\n\n    \"\"\"\n        abc = def, ghi = 123 -> \n        abc = def ghi = 123 -> \n    \"\"\"\n\n    def runner(a, b):\n        return [a, to_argument(trim(b))]\n    items = split(s, \"(?:, *)?(\\w+) *= *\")\n    return dict(map(partition(items), runner))\n"
  },
  {
    "name": "smart_dedent",
    "text": "def smart_dedent(s):\n    s = re.sub(\"^ *\\n*|\\n *$\", \"\", s)\n    if test(s, \"^\\S\"):\n        return s\n    spaces = match(s, \"^ *(?=\\S)\", flags=re.M)\n    secondLineSpaces = match(s, \"\\n *(?=\\S)\")\n    if (\n        not spaces\n        and secondLineSpaces\n        and len(secondLineSpaces) > 4\n    ):\n        return re.sub(\n            \"^\" + secondLineSpaces[5:], \"\", s, flags=re.M\n        ).trim()\n\n    return re.sub(\"^\" + spaces, \"\", s, flags=re.M).strip()\n\n\n"
  },
  {
    "name": "log_file",
    "text": "def log_file(file):\n    \"\"\"\n        fn_degree: 2\n        creates a string that lookes like this:\n        2024-01-11 /home/kdog3682/2023/lezer-runExampleFile.js\n\n        linked to function:write via kwargs.log\n    \"\"\"\n    s = strftime(\"iso8601\") + \" \" + file + \"\\n\"\n    append(\"/home/kdog3682/2024/files.log\", s)\n\n"
  },
  {
    "name": "force_write",
    "text": "def force_write(*args, **kwargs):\n    \"\"\"\n        fn_degree: 2\n        args: [string]\n        kwargs: {content?: string}\n\n        the args join together to form the final path\n        the text value is kwargs.content or \"howdy\"\n\n        return: None\n    \"\"\"\n\n    content = kwargs.get(\"content\", \"\")\n    path = Path(*args)\n    if not path.parent.is_dir():\n        path.parent.mkdir(parents=True, exist_ok=False)\n\n    filename = path.resolve()\n    with open(path.resolve(), \"w\") as f:\n        f.write(content)\n        print(\"wrote\", filename)\n\n"
  },
  {
    "name": "file_log",
    "text": "def file_log(file):\n    content = str(timestamp()) + \" \" + file\n    append(\"/home/kdog3682/2024/files.log\", content)"
  },
  {
    "name": "is_private_filename",
    "text": "def is_private_filename(s):\n\treturn test('^[._]', tail(s))\n"
  },
  {
    "name": "read_bytes",
    "text": "def read_bytes(f):\n    with open(f, \"rb\") as f:\n        return f.read()\n\n"
  },
  {
    "name": "getErrorMessage",
    "text": "def getErrorMessage(e):\n    s = search('\"message\": \"(.*?)\"', str(e))\n    return re.sub('\\.$', '', s.strip())\n"
  },
  {
    "name": "breaker",
    "text": "def breaker(n=10):\n    env.breaker_count += 1\n    if env.breaker_count >= n:\n        raise Exception()\n\n"
  },
  {
    "name": "reverse",
    "text": "def reverse(x):\n    if is_number(x):\n        return int(str(x)[::-1])\n    if is_string(x):\n        return x[::-1]\n    if is_object(x): return {b:a for a,b in x.items()}\n    return list(reversed(x))\n\n\n"
  },
  {
    "name": "choose_dict_item",
    "text": "def choose_dict_item(ref):\n    return choose(ref.values())\n"
  },
  {
    "name": "is_git_directory",
    "text": "def is_git_directory(dir_path):\n    return is_dir(os.path.join(dir_path, \".git\"))\n"
  },
  {
    "name": "days_ago",
    "text": "def days_ago(target_datetime):\n    \"\"\"\n    Calculate how many days ago a given datetime was from the current date.\n\n    :param target_datetime: A datetime object representing the past date and time.\n    :return: Number of days as an integer.\n    \"\"\"\n    current_datetime = datetime.now()\n    # print(strftime(dt = current_datetime))\n    # print(strftime(dt = target_datetime))\n    delta = current_datetime - target_datetime\n    return delta.days + 1\n"
  },
  {
    "name": "ordinal",
    "text": "def ordinal(number):\n    \"\"\"\n    Convert a number into its ordinal representation.\n\n    :param number: An integer number.\n    :return: A string representing the ordinal form of the number.\n    \"\"\"\n    if 10 <= number % 100 <= 20:\n        suffix = 'th'\n    else:\n        suffix = {1: 'st', 2: 'nd', 3: 'rd'}.get(number % 10, 'th')\n\n    return f\"{number}{suffix}\"\n"
  },
  {
    "name": "pluralize_unit",
    "text": "def pluralize_unit(n, unit):\n    \"\"\"\n    Return a string with 'day' or 'days' correctly pluralized based on the number.\n\n    :param n: An integer number representing the number of days.\n    :return: A string with the number and 'day' or 'days'.\n    \"\"\"\n    unit = sub(unit, \"s$\", \"\")\n    if n == 1:\n        return f\"{n} {unit}\"\n    else:\n        return f\"{n} {unit}s\"\n"
  },
  {
    "name": "get_frame_locals",
    "text": "def get_frame_locals(degree = 1):\n    frame = inspect.currentframe()\n    for i in range(degree + 1):\n        frame = frame.f_back\n    return frame.f_locals\n"
  },
  {
    "name": "printf",
    "text": "def printf(s, degree = 1):\n    return templater(smart_dedent(s), get_frame_locals(degree)) if is_string(s) and \"$\" in s else s\n"
  },
  {
    "name": "panic",
    "text": "def panic(s):\n    raise Exception(printf(s, degree = 2))\n"
  },
  {
    "name": "inform",
    "text": "def inform(s, accept_on_enter = 0, header = \"inform\"):\n    message = printf(s, degree = 2)\n    with blue_sandwich():\n        print(header + \":\")\n        print(\"\")\n        print(message)\n        print(\"\")\n\n    if accept_on_enter:\n        print(\"press enter to confirm the response. (you must press the enterkey)\")\n    else:\n        print(\"press anything to continue\")\n\n    answer = input()\n    if accept_on_enter and answer == \"\":\n        return 1\n    return 0\n\n"
  },
  {
    "name": "ask",
    "text": "def ask(s):\n    print(printf(s, degree = 2))\n    return input()\n"
  },
  {
    "name": "tally",
    "text": "def tally(items):\n    counts = {}\n    for item in items:\n        counts[item] = counts.get(item, 0) + 1\n\n    return counts\n"
  },
  {
    "name": "get_last",
    "text": "def get_last(x):\n    return x[-1]"
  },
  {
    "name": "get_local_kwargs",
    "text": "def get_local_kwargs(s, degree = 1):\n    \"\"\"\n        permits string programming (usually a bad idea)\n        first used in map() to see the error\n    \"\"\"\n    keys = xsplit(s)\n    locals = get_frame_locals(degree)\n    return {key: locals.get(key) for key in keys}\n\n"
  },
  {
    "name": "xsplit",
    "text": "def xsplit(x, r=\"[,|] *| +\"):\n    \"\"\"\n        if the input is an array, return it\n        splits on commas and pipes and spaces\n        does not split on newlines\n        does not split on anything else\n    \"\"\"\n    assertion(x, has_newlines, anti = 1)\n    return split(x, r) if is_string(x) else x\n\n"
  },
  {
    "name": "get_filetype",
    "text": "def get_filetype(x):\n    return env.filetype_aliases.get(get_extension(x)) or panic(\"key: [$x] could not be found as a filetype in env.filetype_aliases\")\n"
  },
  {
    "name": "check",
    "text": "def check(*keys):\n    blue(\"checking keys\")\n    prompt(json.dumps(get_local_kwargs(keys, degree = 2)))\n"
  },
  {
    "name": "press_anything_to_continue",
    "text": "def press_anything_to_continue():\n    input(\"press anything to continue\")\n"
  },
  {
    "name": "sort",
    "text": "def sort(x, f=None, reverse=0):\n    sorter = lambda x: x.get(f) if is_string(f) else int if is_number(x[0]) else str \n    return sorted(list(x), key=f, reverse=reverse)\n\n"
  },
  {
    "name": "cp",
    "text": "def cp(x, y):\n    x = expand(x)\n    y = expand(y)\n    as_dir = is_dir(x)\n    fn = shutil.copytree if as_dir else shutil.copy\n    mode = \"dir\" if as_dir else \"file\"\n    if global_debug_flag:\n        print(\"global_debug_flag is active: no real copy\")\n    else:\n        fn(x, y)\n    print(f\"copying {mode}: {x} to {y}\")\n"
  },
  {
    "name": "cpfile",
    "text": "def cpfile(a, b):\n    return copy_file(a, npath(head(a), add_extension(b, a)))\n\n"
  },
  {
    "name": "copy_file",
    "text": "def copy_file(a, b):\n    # mkdir(head(b))\n    shutil.copy(str(a), str(b))\n    print(f\"copied {a} to {b}\")\n\n"
  },
  {
    "name": "remove_file",
    "text": "def remove_file(file):\n    path = Path(file)\n    print(f\"removing file permanently: {path}\")\n    return path.unlink()\n"
  },
  {
    "name": "rename_file",
    "text": "def rename_file(file, name = None):\n    name = name if name else ask(\"choose a new name for: $file\")\n    path = Path(file)\n    return str(path.with_name(name + path.suffix))\n"
  },
  {
    "name": "move",
    "text": "def move(file, dest):\n    shutil.move(str(file), str(dest))\n    print(f\"moved {file} to {dest}\")\n"
  },
  {
    "name": "move_file",
    "text": "def move_file(file, dest):\n    shutil.move(str(file), str(dest))\n    print(f\"moved {file} to {dest}\")\n"
  },
  {
    "name": "trash",
    "text": "def trash(file):\n\n    dir = get_season_and_year(template = \"/home/kdog3682/trash/$year-$season\")\n    if is_array(file):\n        for arg in file:\n            move_file(arg, dir)\n            \n    else:\n        move_file(file, dir)\n"
  },
  {
    "name": "anti_choose",
    "text": "def anti_choose(items):\n\n    for i, item in enumerate(items):\n        print(blue(i + 1), item)\n\n    message = 'anti_choose 1 based indexes: (space-delimited)'\n\n    answers = split(input().strip(), \"\\s+\")\n    if not answers:\n        return items\n    indexes = [int(n) - 1 for n in answers]\n\n    store = []\n    for i, item in enumerate(items):\n        if i not in indexes:\n            store.append(item)\n    return store\n"
  },
  {
    "name": "printdir",
    "text": "def printdir(dir):\n    pprint(listdir(dir))\n\n"
  },
  {
    "name": "yes",
    "text": "def yes(*args, **kwargs):\n    return True\n    "
  },
  {
    "name": "listdir",
    "text": "def listdir(dir, *checkpoints):\n    def checkpoint(f):\n        for checkpoint in checkpoints:\n            if not checkpoint(f):\n                return \n        return 1\n    return filter(list(Path(normalize_file(dir)).iterdir()), checkpoint)\n"
  },
  {
    "name": "dash_split",
    "text": "def dash_split(s):\n    return filter(map(re.split(\"^-{20,}\", s, flags = re.M), trim))\n"
  },
  {
    "name": "has_newlines",
    "text": "def has_newlines(s):\n    return test(s, \"\\n\")\n"
  },
  {
    "name": "split_once",
    "text": "def split_once(s, r = \"\\s+\"):\n    return match(s, f\"(.*?){r}([\\w\\W]+)\") or [s, \"\"]\n\n"
  },
  {
    "name": "dreplace",
    "text": "def dreplace(s, dict, flags=0, template='', transform = None):\n    regex = re_wrap(dict, template)\n    def parser(x):\n        value = (\n            dict.get(x.group(1))\n            if x.groups()\n            else dict.get(x.group(0))\n        )\n        if transform:\n            return transform(value)\n        return value  \n    return sub(s, regex, parser, flags)\n"
  },
  {
    "name": "shellunescape",
    "text": "def shellunescape(s):\n    if not is_string(s):\n        return s\n    if 'zz' not in s:\n        return s\n\n    s = dreplace(s, shellescapedict, template=\"zz($1)\")\n    return parse_json(s)\n"
  },
  {
    "name": "parse_json",
    "text": "def parse_json(x):\n    if is_string(x):\n        try:\n            return json.loads(x) if test(x, \"^[{\\[]\") else x\n        except Exception as e:\n            return x\n    return x\n"
  },
  {
    "name": "get_file_info",
    "text": "def get_file_info(file):\n    path = Path(file)\n    if not path.exists():\n        return \n    stats = path.stat()\n    size = stats.st_size\n    timestamp = stats.st_mtime\n    return {\n        \"name\": path.name,\n        \"size\": size,\n        \"date\": timestamp,\n        # \"date\": strftime(\"iso8601\", datetime.fromtimestamp(timestamp)),\n    }\n\n\n"
  },
  {
    "name": "to_timestamp",
    "text": "def to_timestamp(date):\n    return datetime.strptime(date, \"%Y-%m-%d\").timestamp()\n"
  },
  {
    "name": "line_getter",
    "text": "def line_getter(s):\n    if is_string(s):\n        s = text_getter(s)\n    return s if is_array(s) else map(s.strip().split(\"\\n\"), trim)\n"
  },
  {
    "name": "get_files",
    "text": "def get_files(dir, ext = None):\n    def checkpoint(path):\n        if ext:\n            return get_extension(path) == ext\n        else:\n            return path.is_file()\n    return map(listdir(dir, checkpoint), str)\n"
  },
  {
    "name": "findall",
    "text": "def findall(s, r, flags = 0):\n    return re.findall(r, s, flags = flags)\n\n\n"
  },
  {
    "name": "remove_chinese_accents",
    "text": "def remove_chinese_accents(input_text):\n    import unicodedata\n    nfkd_form = unicodedata.normalize('NFKD', input_text)\n    only_ascii = nfkd_form.encode('ASCII', 'ignore')\n    return only_ascii.decode('ASCII')\n"
  },
  {
    "name": "run_tests",
    "text": "def run_tests(s, *scopes):\n    def runner(item):\n        result = eval(item, *scopes)\n        pprint({\"item\": item, \"result\": result})\n    map(line_getter(remove_comments(s)), runner)\n"
  },
  {
    "name": "remove_comments",
    "text": "def remove_comments(s):\n    return sub(s, \"^#.+\\n*\", \"\", flags = re.M)\n"
  },
  {
    "name": "quote",
    "text": "def quote(s, d = \"\\\"\"):\n    return f\"{d}{s}{d}\"\n"
  },
  {
    "name": "sympify_wrapper",
    "text": "def sympify_wrapper(s):\n    if test(s, \"//\"):\n        s = join(map_templater(split(s, \"//\"), \"($1)\"), \" / \")\n    return sub(s, \"(\\w)x\", lambda x: x.group(1) + \" * x\")\n"
  },
  {
    "name": "replace_quotes",
    "text": "def replace_quotes(s, fn):\n    return sub(s, \"\\\"(.*?)\\\"\", lambda x: quote(fn(x.group(1))))\n"
  },
  {
    "name": "map_templater",
    "text": "def map_templater(items, template):\n    def fn(item):\n        return templater(template, item.strip())\n    return [fn(item) for item in items]\n\n"
  },
  {
    "name": "most_recent_file_groups",
    "text": "def most_recent_file_groups(dir=dldir, minutes=3):\n    base_files = Path(dir).glob(\"*\")\n    paths = reverse(sort(base_files, lambda f: f.stat().st_mtime))\n    store = []\n    last_date = 0\n    ignore = []\n\n    for path in paths:\n        if test(path.name, '\\(\\d\\)') or path.name in ignore:\n            continue\n        file_date = path.stat().st_mtime\n        d = abs(file_date - last_date)\n        limit = to_seconds(minutes=minutes)\n        passes = d < limit or last_date == 0\n        if passes:\n            store.append(path)\n        else:\n            return reverse(map(store, str))\n        last_date = file_date\n"
  },
  {
    "name": "to_seconds",
    "text": "def to_seconds(\n    minutes=0, hours=0, seconds=0, days=0, weeks=0, months=0"
  },
  {
    "name": "merge_objects_if_key_missing",
    "text": "def merge_objects_if_key_missing(objects, key = \"chinese\"):\n    store = []\n\n    last_object_with_key = None\n\n    for obj in objects:\n        if key in obj:\n            store.append(obj)\n            last_object_with_key = obj\n        else:\n            if last_object_with_key is not None:\n                last_object_with_key.update(obj)\n            else:\n                store.append(obj)\n\n    return store\n\n"
  },
  {
    "name": "dot_backup",
    "text": "def dot_backup(file):\n    outpath = str(head(file)) + \".\" + str(tail(file))\n    copy_file(file, outpath)\n"
  },
  {
    "name": "walk",
    "text": "def walk(x, fn):\n    def walker(x, key=None, depth=0):\n        new_depth = depth + 1\n        \n        if is_array(x):\n            items = [walker(y, key, new_depth) for y in x]\n            return [item for item in items if item is not None]\n\n        if is_object_literal(x):\n            o = {}\n            for a, b in x.items():\n                new_value = walker(b, a, new_depth)\n                if new_value is not None:\n                    o[a] = new_value\n            return o if o else None\n\n        value = fn(x, key, depth)\n        return value if value is not None else x\n\n    return walker(x)\n"
  },
  {
    "name": "is_object_literal",
    "text": "def is_object_literal(x):\n    return isinstance(x, dict)\n"
  },
  {
    "name": "remove_javascript_comments",
    "text": "def remove_javascript_comments(s):\n    return sub(s, \"^ *//.*\", \"\", flags = re.M)\n\n"
  },
  {
    "name": "merge",
    "text": "def merge(*input):\n    base = input if len(input) > 1 else input[0]\n    assert base\n    array = is_array(base[0])\n    store = [] if array else {}\n\n    for arg in base:\n        if not arg:\n            continue\n        store.extend(arg) if array else store.update(arg)\n    return store\n\n"
  },
  {
    "name": "splice",
    "text": "def splice(items, start, delete_count=None):\n    \"\"\"\n    Removes elements from a list and returns the removed elements.\n\n    :param items: The list from which elements will be removed.\n    :param start: The zero-based location in the list from which to start removing elements.\n    :param delete_count: The number of elements to remove.\n    :return: A list containing the removed elements.\n    \"\"\"\n    # Adjust negative start index\n    if start < 0:\n        start = max(0, start + len(items))\n\n    # Determine the end index for removal\n    if delete_count is not None:\n        end = start + delete_count\n    else:\n        end = len(items)\n\n    # Extract the elements to be removed\n    removed_elements = items[start:end]\n\n    # Remove the elements from the original list\n    items[start:end] = []\n\n    return removed_elements\n"
  },
  {
    "name": "text_getter",
    "text": "def text_getter(s):\n    return read(s) if is_file(s) else s\n\n"
  },
  {
    "name": "dictify",
    "text": "def dictify(x, regex = None):\n    s = text_getter(x).strip()\n    regexes = [\n        \"^(\\S+):\", \n        \"^[#/]+ *(\\S+)\",\n    ]\n\n    if regex == None:\n        regex = find(regexes, lambda regex: test(s, regex))\n\n    items = partition(split(s, regex, flags = re.M))\n    return dict(items)\n"
  },
  {
    "name": "copy_files",
    "text": "def copy_files(files, dest):\n    mkdir(dest)\n    map(files, lambda x: copy_file(x, dest))\n"
  },
  {
    "name": "remove_files",
    "text": "def remove_files(files):\n    map(files, remove_file)\n"
  },
  {
    "name": "file_creator",
    "text": "def file_creator(file):\n    dir = \"/home/kdog3682/2024-writing/math/\"\n    mkdir(dir)\n    cd(dir)\n\n    if is_file(npath(dir, file)):\n        print(\"the file already exists in this directory\")\n        print(\"early return\")\n\n    data = {\n        **multi_prompt(\"grade\", \"name\", \"topic\", \"desc\", \"prereqs\"),\n        'file': file,\n    }\n    append_json(\"index.json\", [data])\n    mkdir(dir)\n"
  },
  {
    "name": "multi_prompt",
    "text": "def multi_prompt(*args, **kwargs):\n    return {k: prompt(\"choose a value for: \" + str(k)) for k in args}\n\n\n"
  },
  {
    "name": "cpdir",
    "text": "def cpdir(src, to):\n    src = os.path.expanduser(src)\n    to = os.path.expanduser(to)\n    shutil.copytree(src, to)\n    print(f\"copying directory: {src} to {to}\")\n"
  },
  {
    "name": "typst_manager",
    "text": "def typst_manager():\n    a = \"/home/kdog3682/GITHUB/typst-packages/packages/preview/\"\n    package = choose(listdir(a))\n    name = tail(package)\n    version = tail(most_recent_file(package))\n    srcpath = str(Path(package, version))\n    outpath = f\"/home/kdog3682/.cache/typst/packages/preview/{name}/{version}\"\n    if is_dir(outpath):\n        print(\"outpath already exists\", outpath)\n        prompt(\"are you sure you want to continue?\")\n    cpdir(srcpath, outpath)\n\n"
  },
  {
    "name": "get_path",
    "text": "def get_path(x):\n    x = sub(x, \"~\", \"/home/kdog3682\")\n    if is_dir(x):\n        return x\n    print(x)\n    return \n"
  },
  {
    "name": "copy",
    "text": "def copy(x):\n    return json.loads(json.dumps(x))\n\n"
  },
  {
    "name": "copy_recently_downloaded_files_to_dir",
    "text": "def copy_recently_downloaded_files_to_dir():\n    dir = \"/home/kdog3682/2024-typst/emoji-assets/\"\n    mkdir(dir)\n    files = most_recent_file_groups()\n    map(files, lambda file: copy_file(file, npath(dir, rename_file(file))))\n"
  },
  {
    "name": "checkpointf",
    "text": "def checkpointf(**kwargs):\n    \n    exts = []\n    r = None\n    seconds = 0\n    time = datetime.now().timestamp()\n\n    ignore = [\".git\", \"node_modules\", \"tests\", \"dist\"]\n\n\n    durations = [\n        \"minutes\",\n        \"seconds\",\n        \"hours\",\n        \"weeks\",\n        \"months\",\n        \"days\",\n    ]\n\n    before = kwargs.get(\"before\", False)\n    folders = 0 #default is files\n    public = 0\n    bigger = 0 # default is smaller\n    size = 0\n    empty = 0\n    name = 0\n\n    for k,v in kwargs.items():\n        if not v:\n            continue\n        if k in commonExtensions:\n            exts.append(k)\n        elif k in durations:\n            seconds += to_seconds(**dict({k: v}))\n        elif k == \"bigger\":\n            bigger = 1\n        elif k == \"empty\":\n            empty = 1\n\n        elif k == \"name\":\n            name = v\n\n        elif k == \"size\":\n            size = v\n        elif k == \"public\":\n            public = 1\n        elif k == \"private\":\n            public = 0\n        elif k == \"files\":\n            folders = 0\n        elif k == \"folders\":\n            folders = 1\n        elif k == \"r\":\n            r = v\n        elif k == \"image\":\n            exts.extend([\"png\", \"jpg\", \"svg\"])\n\n    def checkpoint(file):\n        filename = tail(file)\n        if name and filename != name:\n            return 0\n        if exts and get_extension(file) not in exts:\n            return 0\n        if public and is_private(file):\n            return 0\n        if filename in ignore:\n            return 0\n        if folders:\n            if is_file(file):\n                return 0\n            if empty and not is_empty_dir(file):\n                return 0\n        else:\n            if not is_file(file):\n                return 0\n\n        if seconds:\n            a = mdate(file) < time - seconds\n            if before:\n                if not a: return 0\n            else:\n                if a: return 0\n        if size:\n            if folders:\n                pass\n            else:\n                if bigger:\n                    if fsize(file) <= size:\n                        return 0\n                else:\n                    if fsize(file) > size:\n                        return 0\n        if kwargs.get('no_duplicates') and test(filename, \"\\(\\d+\\)\"):\n            return 0\n        if r and not test(filename, r):\n            return 0\n        return 1\n\n    return checkpoint\n\n"
  },
  {
    "name": "get_files_recursive",
    "text": "def get_files_recursive(root, **kwargs):\n    checkpoint = checkpointf(**kwargs)\n\n    def runner(dir):\n        p = Path(dir)\n        if p.is_dir():\n            children = [runner(child) for child in p.glob(\"*\")]\n            return children\n        elif checkpoint(p):\n            return p\n\n    if kwargs.get(\"recursive\"):\n        return flat(runner(abspath(root)))\n    else:\n        return filter(absdir(root), checkpoint)\n\n"
  },
  {
    "name": "getter",
    "text": "def getter(file):\n    return {\n        \"file\": str(file),\n        \"filename\": tail(file),\n        \"import_type\": \"star\",\n        \"exports\": get_javascript_exports(read(file)),\n    }\n"
  },
  {
    "name": "get_javascript_exports",
    "text": "def get_javascript_exports(s):\n    m = match(s, \"(?:^|\\s)export\\s*{([\\w\\W]+?)}\")\n    m = remove_javascript_comments(m)\n    items = unique(findall(m, \"[a-zA-Z]\\w{2,}\"))\n    return items\n"
  },
  {
    "name": "is_empty_quote",
    "text": "def is_empty_quote(x):\n    return is_string(x) and test(x.strip(), '^(?:\"\"|\\'\\')$')\n"
  },
  {
    "name": "move_to_downloads",
    "text": "def move_to_downloads(files):\n    prompt(files)\n    map(files, lambda x: move_file(x, dldir))"
  },
  {
    "name": "merge_folders",
    "text": "def merge_folders(a, b):\n    existant = []\n    fresh = []\n    files = listdir(b)\n    for item in files:\n        p = npath(a, item)\n        if path_exists(p):\n            existant.append(item)\n        else:\n            fresh.append(item)\n\n    for item in fresh:\n        cp(item, a)\n\n    for item in existant:\n        if item.is_file():\n            print(\"cannot copy the file over because it already exists\")\n        elif item.is_dir():\n            print(\"cannot copy dir because it exists\")\n            print(\"going recursive\")\n            merge_folders(npath(a, item), str(item))\n"
  },
  {
    "name": "edit",
    "text": "def edit(x, key, fn, *args):\n    if is_array(x) or is_object(x):\n        p = x[key]\n        v = fn(p, *args)\n        if is_defined(v):\n            x[key] = v\n    return x\n"
  },
  {
    "name": "path_join",
    "text": "def path_join(*args, **kwargs):\n    mapped = [sub(arg, \"/+$\", \"\") for arg in args]\n    if kwargs.get(\"ext\"):\n        edit(mapped, -1, add_extension, kwargs.get(\"ext\"))\n    return \"/\".join(mapped)\n"
  },
  {
    "name": "copy_npm_package_to_global",
    "text": "def copy_npm_package_to_global(name):\n    panic(\"permission is denied\")\n    source = path_join(nodedir, name)\n    print(source)\n    assert is_dir(source)\n    cp(source, path_join(globalnpmdir, name))\n    "
  },
  {
    "name": "pause",
    "text": "def pause(*args):\n    print(*args)\n    print(\"\")\n    print(\"press anything to continue\")\n    input(\"\")\n"
  },
  {
    "name": "rename_dir",
    "text": "def rename_dir(a, b):\n    assert is_dir(a)\n    if not is_absolute_path(b):\n        b = npath(head(a), b)\n        pause(\"src\", a, \"to\", b)\n    cpdir(a, b)\n    rmdir(a)\n\n"
  },
  {
    "name": "is_absolute_path",
    "text": "def is_absolute_path(b):\n    return test(b, \"^/\")\n\n"
  },
  {
    "name": "pause",
    "text": "def pause(*args, **kwargs):\n    print(*args)\n    print(**kwargs)\n    input(\"press anything to continue\")\n\n\n"
  },
  {
    "name": "multi_market_query",
    "text": "def multi_market_query(s):\n    query = sub(s, \" \", \"+\")\n    amazon = \"https://www.amazon.com/s?k=\"\n    walmart = \"https://www.walmart.com/search?q=\"\n    google = \"https://www.google.com/search?q=\"\n    urls = [amazon, walmart, google]\n    urls = map(urls, lambda x: x + query)\n    urls = map(urls, ofile)\n        "
  },
  {
    "name": "abspath",
    "text": "def abspath(b):\n    return os.path.expanduser(b)\n"
  },
  {
    "name": "mv",
    "text": "def mv(a, b):\n    b = abspath(b)\n    if is_dir(b):\n        b = npath(b, a)\n\n    move_file(a, b)\n"
  },
  {
    "name": "mkdir",
    "text": "def mkdir(path):\n    if debug:\n        return \n    path = os.path.expanduser(path)\n    if is_dir(path):\n        return \n\n    os.makedirs(path, exist_ok=False)\n    print(f\"Directory created: {path}\")\n"
  },
  {
    "name": "mkfile",
    "text": "def mkfile(path, known = {}):\n    name = os.path.basename(path)\n    if name in known:\n        source_path = known[name]\n        if not debug:\n            shutil.copy(source_path, path)\n            print(f\"File copied from {source_path} to {path}\")\n    else:\n        mkdir(head(path))\n        clear(path)\n"
  },
  {
    "name": "move_files",
    "text": "def move_files(files, dest):\n    mkdir(dest)\n    map(files, lambda x: move_file(x, dest))"
  },
  {
    "name": "abspath",
    "text": "def abspath(file=None):\n    if file == None:\n        return os.path.expanduser(\"~/\")\n    elif file == \".\":\n        return os.getcwd()\n    elif file.startswith(\"~\"):\n        return os.path.expanduser(file)\n    elif file.startswith(\"./\"):\n        return os.path.join(os.getcwd(), file[2:])\n    else:\n        return os.path.abspath(file)"
  },
  {
    "name": "listdir",
    "text": "def listdir(dir=\".\", *checkpoints):\n    if is_array(dir):\n        return dir\n    dir = abspath(dir)\n    return [os.path.join(dir, f) for f in os.listdir(dir)]\n\n"
  },
  {
    "name": "group",
    "text": "def group(items, callback):\n    storage = Storage()\n    for item in items:\n        storage.add(callback(item), item)\n    return storage\n"
  },
  {
    "name": "maybe_print",
    "text": "def maybe_print(x):\n    if x == None:\n        return \n    if is_primitive(x):\n        print(x)\n    else:\n        pprint(x)\n\n"
  },
  {
    "name": "append_lines",
    "text": "def append_lines(s):\n    return 123\n"
  },
  {
    "name": "capitalize",
    "text": "def capitalize(s):\n    if not s:\n        return s\n    return s[0].upper() + s[1:]\n"
  },
  {
    "name": "uncapitalize",
    "text": "def uncapitalize(s):\n    return s[0].lower() + s[1:]"
  },
  {
    "name": "camel_case",
    "text": "def camel_case(s):\n    parts = filter(re.split(\"[\\W_]+\", s))\n    return uncapitalize(join(map(parts, capitalize), \"\"))\n"
  },
  {
    "name": "pascal_case",
    "text": "def pascal_case(s):\n    return capitalize(camel_case(s))\n"
  },
  {
    "name": "snake_case",
    "text": "def snake_case(s):\n    s = re.sub('(?<=[a-z])(?=[A-Z])', '_', s)\n    s = re.sub(\"\\W+\", \"_\", s)\n    s = s.lower()\n    return s\n\n"
  },
  {
    "name": "sayhi",
    "text": "def sayhi(*args, **kwargs):\n    print(\"howdy\")\n"
  },
  {
    "name": "get_indent_and_text",
    "text": "def get_indent_and_text(raw):\n    text = raw.strip()\n    ind = len(raw)  - len(raw.lstrip())\n    assert ind % 4 == 0\n    return {'ind': int(ind / 4), 'text': text}\n"
  },
  {
    "name": "depluralize",
    "text": "def depluralize(s):\n    return sub(s, \"s$\", \"\")\n\n"
  },
  {
    "name": "sleep",
    "text": "def sleep(n):\n    import time\n    time.sleep(n)\n"
  },
  {
    "name": "js_comment",
    "text": "def js_comment(s):\n        return f\"// {s}\"\n"
  },
  {
    "name": "foo",
    "text": "def foo(s):\n    r = \"^#let +(\\S+).*?\\n// *export\"\n    m = [\"start\"] + findall(s, r, flags = re.M)\n    return map(m, js_comment)\n\n"
  },
  {
    "name": "rpw",
    "text": "def rpw(file, fn):\n    data = read_json(file) if get_extension(file) ==  \"json\" else read(file)\n    value = fn(data)\n    write(file, value, ask = 1)"
  },
  {
    "name": "rpa",
    "text": "def rpa(file, fn):\n    value = fn(read(file))\n    payload = join_lines(value) if is_array(value) else value\n    append(file, payload)\n"
  },
  {
    "name": "rpx",
    "text": "def rpx(file, fn, outpath = None, mode = \"w\"):\n    value = fn(read_json(file) if get_extension(file) ==  \"json\" else read(file))\n    if not value:\n        return \n    payload = join_lines(value) if is_array(value) and not get_extension(file)== \"json\" else value\n    outpath = outpath or file\n    if mode == \"a\":\n        append(outpath, payload)\n    elif mode == \"w\":\n        write(outpath, payload)\n"
  },
  {
    "name": "double_quote",
    "text": "def double_quote(s):\n    return f\"\\\"{s}\\\"\"\n"
  },
  {
    "name": "foo",
    "text": "def foo(s):\n    s = sub(s, \"#include\\((.*?)\\)\", lambda x: \"#\" + x.group(1))\n    return s\n    "
  },
  {
    "name": "write2",
    "text": "def write2(file, content):\n    if is_string(content):\n        with open(file, \"w\") as f:\n            f.write(content)\n            print(f\"wrote file: {file}\")\n    else:\n        with open(file, \"w\") as f:\n            json.dump(content, f, indent=2, ensure_ascii=False)\n            print(f\"wrote file: {file} as json\")\n          \n"
  },
  {
    "name": "difference",
    "text": "def difference(a, b):\n    store = []\n    for item in a:\n        if item not in b:\n            store.append(item)\n    return store\n"
  },
  {
    "name": "str_reduce",
    "text": "def str_reduce(items, fn):\n    return join_lines(map(items, fn))\n"
  },
  {
    "name": "absdir",
    "text": "def absdir(dir):\n    dir = os.path.expanduser(dir)\n    return [os.path.join(dir, f) for f in os.listdir(dir)]\n"
  },
  {
    "name": "entries",
    "text": "def entries(items):\n    return items.items() if is_object(items) else list(items)\n"
  },
  {
    "name": "npath",
    "text": "def npath(dir, file):\n    return os.path.join(expand(dir), tail(file))\n\n"
  },
  {
    "name": "expand",
    "text": "def expand(file):\n    return os.path.expanduser(file)\n\n"
  },
  {
    "name": "mget",
    "text": "def mget(s, regex, replacement=\"\", flags=0):\n    store = []\n\n    def parser(x):\n        m = get_match(x)\n        store.append(m)\n        return fparse(replacement, x)\n\n    a = sub(s, regex, parser, flags)\n    return a, smallify(store)\n"
  },
  {
    "name": "smallify",
    "text": "def smallify(x):\n    if x:\n        if is_array(x):\n            if len(x) == 1:\n                return x[0]\n            else:\n                return x\n        else:\n            return x\n    else:\n        return None\n\n"
  },
  {
    "name": "mconf",
    "text": "def mconf(s, r):\n    a, b = mget(s, r)\n    b = bool(b)\n    return a, b\n\n"
  },
  {
    "name": "fparse",
    "text": "def fparse(fn, *args):\n    if is_function(fn):\n        return fn(*args)\n    return fn\n\n"
  },
  {
    "name": "is_commented",
    "text": "def is_commented(s):\n    return test(s, \"^[#/-]\")\n\n"
  },
  {
    "name": "get_season_and_year",
    "text": "def get_season_and_year(date = None, template = \"$season $year\"):\n    date = date or datetime.today()\n\n    if date.month in range(3, 6):\n        season = 'spring'\n    elif date.month in range(6, 9):\n        season = 'summer'\n    elif date.month in range(9, 12):\n        season = 'autumn'\n    else:\n        season = 'winter'\n\n    year = date.year\n    return templater(template, {\"season\": season, \"year\": year})\n\n"
  },
  {
    "name": "get_first_name",
    "text": "def get_first_name(s):\n    return \" \".join(split(s, \" +\")[:-1])"
  },
  {
    "name": "camel_case",
    "text": "def camel_case(s):\n    def replacer(x):\n        return x.group(0).strip().upper()\n    return sub(s, \" \\w\", replacer)\n\n"
  },
  {
    "name": "modular_increment",
    "text": "def modular_increment(items, i, dir = 1):\n    if dir == 1:\n        if len(items) - 1 == i:\n            return 0\n        else:\n            return i + 1\n"
  },
  {
    "name": "index_getter",
    "text": "def index_getter(items, x):\n    if is_number(x):\n        return x\n    return items.index(x)\n\n"
  },
  {
    "name": "add_directory",
    "text": "def add_directory(file, dir):\n    if test(file, \"^[~/]\"):\n        return file\n    return npath(dir, file)\n"
  },
  {
    "name": "git_remove",
    "text": "def git_remove(file):\n    dir, filename = os.path.split(expand(file))\n    cmd = f\"\"\"\n        cd {dir}\n        git rm {filename} \n        git commit -m \"remove {filename}\"\n        git push\n    \"\"\"\n\n    system_command(cmd)\n  "
  },
  {
    "name": "ensure_dir_exists",
    "text": "def ensure_dir_exists(x):\n    if get_extension(x):\n        x = head(x)\n    mkdir(x)"
  },
  {
    "name": "confirm",
    "text": "def confirm(x):\n    prompt(f\" please confirm value: \\\"\\\"{x}\\\"\\\" by pressing enter.\")\n    return x"
  },
  {
    "name": "make_dir_from_str",
    "text": "def make_dir_from_str(s):\n    mkdir(confirm(head(line_getter(s)[-1])))"
  },
  {
    "name": "filelog",
    "text": "def filelog(file):\n    filelog_file = \"/home/kdog3682/2024/files.log\"\n    append(filelog_file, file)"
  },
  {
    "name": "is_empty_dir",
    "text": "def is_empty_dir(dir):\n    def runner(dir):\n        files = absdir(dir)\n\n        s = 0\n        for file in files:\n            if is_dir(file):\n                s += runner(file)\n            else:\n                s += 1\n\n            if s > 0:\n                break\n            \n        return s\n\n    return runner(dir) == 0\n\n"
  },
  {
    "name": "kill",
    "text": "def kill(status, message = \"\"):\n    if status:\n        return \n\n    if message:\n        print(message)\n\n    sys.exit(0)\n"
  },
  {
    "name": "rmdir",
    "text": "def rmdir(dir):\n    dir = sub(expand(dir), \"/$\", \"\")\n    assert not dir in protected_directories\n    shutil.rmtree(dir)\n    print(\"removing dir\", dir)\n\n"
  },
  {
    "name": "crostini_url_to_linux_url",
    "text": "def crostini_url_to_linux_url(s):\n    return sub(s, \".*?termina_penguin\", \"\", count=1)\n\n"
  },
  {
    "name": "count_parameters",
    "text": "def count_parameters(fn):\n    params = inspect.signature(fn).parameters\n    return len(params)\n\n"
  },
  {
    "name": "write_temp_file",
    "text": "def write_temp_file(s):\n    write(g.files.temp, stringify(s))\n\n"
  },
  {
    "name": "temp",
    "text": "def temp(arg, open=0):\n    write(\"/home/kdog3682/2024/temp.txt\", stringify(arg), open=open)\n\n"
  },
  {
    "name": "exit",
    "text": "def exit(*args):\n    if args:\n        print(*args)\n    sys.exit()\n\n"
  },
  {
    "name": "system",
    "text": "def system(s, mode=str, cwd=0, confirm=0):\n    from subprocess import Popen, PIPE\n\n    command = remove_comments(s)\n    if cwd:\n        command = f\"cd {expand(cwd)}\\n{command}\"\n\n    if confirm:\n        _confirm(command)\n\n    process = Popen(command, stdout=PIPE, stderr=PIPE, shell=True)\n    data = process.communicate()\n    a, b = data\n    success = trim(decode(a))\n    error = trim(decode(b))\n    if test(command, \"^git\", flags=re.M):\n        pprint({\"success\": success, \"error\": error})\n        if not \"fatal\" in error:\n            error = False\n\n    if mode == bool:\n        if error:\n            print(\"system command failed\")\n            return False\n        return True\n    if mode == str:\n        if error:\n            sys_exit(error)\n        return success\n    elif mode == dict:\n        return {\"success\": success, \"error\": error}\n\n"
  },
  {
    "name": "Dict",
    "text": "def Dict(o):\n    class _Dict:\n        def __init__(self, **kwargs):\n            for key, value in kwargs.items():\n                setattr(self, key, value)\n\n        def __repr__(self):\n            attrs = \", \".join(\n                f\"{k}={v!r}\" for k, v in self.__dict__.items()\n            )\n            return f\"{self.__class__.__name__}({attrs})\"\n\n    return _Dict(**o)\n\n"
  },
  {
    "name": "_confirm",
    "text": "def _confirm(message):\n    print(message)\n    a = input(\n        \"press [y] and only [y] to confirm ... otherwise system will abort.   \"\n    )\n    if a == \"y\":\n        return True\n    sys_exit(\"confirmation was not met. exiting.\")\n\n"
  },
  {
    "name": "confirm",
    "text": "def confirm(message, abort=0):\n    print(\"do you wish to\", message, \"?\")\n    a = input(\"press [y] to confirm   \")\n    if a == \"y\":\n        return True\n    if abort:\n        sys_exit(\"System Aborting because Confirmation was not met\")\n    return False\n\n"
  },
  {
    "name": "write_bash_commands_from_bash_history",
    "text": "def write_bash_commands_from_bash_history():\n    bash_history_file = \"~/.bash_history\"\n    bash_command_file = \"~/.bash_commands\"\n    checkpoint = lambda x: len(x) > 5\n    lines = sort(\n        unique(\n            filter(line_getter(read(bash_history_file)), checkpoint)\n        )\n    )\n    prompt(lines)\n    write(bash_command_file, join(lines, \"\\n\"), open=1)\n    if confirm(\"clear bash_history\"):\n        clear(bash_history_file)\n\n"
  },
  {
    "name": "abc",
    "text": "def abc():\n    \"\"\"\n    this function will replace *.test.js with *.example.js\n    used for removing experimentation tests\n    \"\"\"\n    files = listdir(\n        \"/home/kdog3682/@bkl/frontend/src/components/__tests__/\"\n    )\n\n    def runner(file):\n        new_name = file.replace(\"spec\", \"example\")\n        move_file(file, new_name)\n\n    files = map(files, runner)\n    files = listdir(\n        \"/home/kdog3682/@bkl/frontend/src/components/__tests__/\"\n    )\n    pprint(files)\n\n"
  },
  {
    "name": "get_path_from_text",
    "text": "def get_path_from_text(s):\n    parts = map(sort(split(trim(s), \" \"), reverse=1), expand)\n    return find(parts, os.path.exists)\n\n"
  },
  {
    "name": "vim_package_manager",
    "text": "def vim_package_manager():\n    key, vim = get_sys_args()\n    vim = Dict(vim)\n    if vim.file == \"/home/kdog3682/2024/files.log\":\n        s = line_getter(read(vim.file))[vim.lnum - 1]\n        vim.file = get_path_from_text(s)\n        prompt(vim.file)\n\n    g = globals()\n    if not key:\n        keys = get_local_functions()\n        key = choose(keys)\n\n    fn = g.get(key)\n    finish(fn(vim))\n\n"
  },
  {
    "name": "get_git_dir_from_path",
    "text": "def get_git_dir_from_path(x):\n    start = head(x) if get_extension(x) else x\n    p = Path(x)\n    while p and not is_dir(npath(str(p.parent), \".git\")):\n        p = p.parent\n\n    if not p:\n        return None\n    return str(p.parent)\n\n"
  },
  {
    "name": "cached",
    "text": "def cached(fn, get=identity):\n    cache = {}\n\n    def runner(key, *args):\n        key = get(key)\n        cached = cache.get(key, None)\n        if cached:\n            print(\"returning cached\", key)\n            return cached\n        value = fn(key, *args)\n        cache[key] = value\n        return value\n\n    return runner\n\n"
  },
  {
    "name": "create_git_message",
    "text": "def create_git_message(vim):\n    arg = vim.arg or \"autopush\"\n    file = vim.file\n    return arg\n\n"
  },
  {
    "name": "get_git_files",
    "text": "def get_git_files(vim):\n    b = system(\"git status\")\n    r = \"\\t(\\w+: +)?(.+)\"\n    m = findall(b, r)\n\n    def callback(k, file):\n        if key:\n            key = trim(k)[:-1]\n        else:\n            key = \"created\"\n        path = os.path.join(vim.dir, file)\n        return (key, path)\n\n    return map(m, callback)\n\n"
  },
  {
    "name": "vt",
    "text": "def vt(s, vim, *args):\n    arg_ref = args[0] if args and is_object(args[0]) else {}\n    ref = {\n        \"gitdir\": lambda vim: get_git_dir_from_path(vim.file),\n        \"arg\": lambda vim: to_argument(prompt(\"provide an arg:\")),\n        \"file\": lambda vim: vim.file,\n        \"create_git_message\": create_git_message,\n        \"gitfiles\": get_git_files,\n    }\n\n    def get(x):\n        key = x.group(1)\n        return key\n\n    def runner(key):\n        if is_number(key):\n            return args[int(key) - 1]\n        elif key in arg_ref:\n            return arg_ref[key]\n\n        elif key in ref:\n            return ref[key](vim)\n        else:\n            return globals().get(key)(vim)\n\n    s = smart_dedent(s)\n    regex = \"\\$(\\w+)\"\n    callback = cached(wrap(runner, str), get)\n    return sub(s, regex, callback)\n\n"
  },
  {
    "name": "wrap",
    "text": "def wrap(fn, gn):\n    def hn(*args, **kwargs):\n        return gn(fn(*args, **kwargs))\n\n    return hn\n\n"
  },
  {
    "name": "get_extended_extension",
    "text": "def get_extended_extension(file):\n    return join(split(tail(file), \"\\.\")[1:], \".\")\n\n"
  },
  {
    "name": "goola",
    "text": "def goola(vim):\n    cmd = vt(s, vim)\n    system_command(cmd)\n\n"
  },
  {
    "name": "fast",
    "text": "def fast(vim):\n    ref = {\n        \"gpcd\": gpcd,\n        \"temp\": temp,\n    }\n    key = vim.arg\n    cmd = vt(ref[key], vim)\n    prompt(cmd)\n    result = bash(cmd)\n    return result\n\n"
  },
  {
    "name": "bash",
    "text": "def bash(s):\n    result = system(s)\n    print(result.success)\n    print(result.error)\n\n"
  },
  {
    "name": "sys_exit",
    "text": "def sys_exit(message):\n    print(message)\n    sys.exit(1)\n\n"
  },
  {
    "name": "get_sys_args",
    "text": "def get_sys_args(n=2):\n    argv = sys.argv\n    if not len(argv) > 1:\n        sys_exit(\"requires shell\")\n\n    args = map(list(argv[1:]), shellunescape)\n    # raise Exception(json.dumps(args))\n    if not args:\n        sys_exit(\"no sys args\")\n    if len(args) != n:\n        sys_exit(\n            f\"incorrect number of args: expected {n} ... got {len(args)}\"\n        )\n    if len(args) == 1:\n        return args[0]\n    return args\n\n"
  },
  {
    "name": "finish",
    "text": "def finish(payload):\n    maybe_print(payload)\n\n"
  },
  {
    "name": "absdir",
    "text": "def absdir(dir):\n    dir = expand(dir)\n    return [os.path.join(dir, f) for f in os.listdir(dir)]\n\n"
  },
  {
    "name": "get_directory_files",
    "text": "def get_directory_files(vim):\n    files = absdir(vim.dir)\n    return files\n\n"
  },
  {
    "name": "get_today_files",
    "text": "def get_today_files(vim):\n    files = get_directory_files(vim)\n    return filter(files, checkpointf(after=\"8AM\"))\n\n"
  },
  {
    "name": "vim_module_manager",
    "text": "def vim_module_manager(vim):\n    filekey, fnkey, vim = get_sys_args(3)\n    module = __import__(filekey)\n    fn = getattr(module, fnkey)\n    finish(fn(vim))\n\n"
  },
  {
    "name": "python_migration",
    "text": "def python_migration():\n    dir = \"vimpykit\"\n\n"
  },
  {
    "name": "checkpointf",
    "text": "def checkpointf(**kwargs):\n    before = kwargs.get(\"before\")\n    after = kwargs.get(\"after\")\n\n    if before or after:\n        hour = 0\n        if before:\n            hour = int(match(before, \"\\d+\"))\n        if after:\n            hour = int(match(after, \"\\d+\"))\n        now = datetime.datetime.now()\n\n        if now.hour < hour:\n            now = now.replace(\n                hour=hour, minute=0, second=0, microsecond=0\n            ) - datetime.timedelta(days=1)\n        else:\n            now = now.replace(\n                hour=hour, minute=0, second=0, microsecond=0\n            )\n\n        if before:\n            checkpoints.append(lambda x: os.path.getmtime(x) < now)\n        if after:\n            checkpoints.append(lambda x: os.path.getmtime(x) > now)\n\n    def checkpoint(file):\n        for c in checkpoints:\n            if c(file):\n                continue\n            else:\n                return False\n        return True\n\n"
  },
  {
    "name": "get_function_identifiers",
    "text": "def get_function_identifiers(s):\n    return findall(s, \"^def (\\w+)\", flags=re.M)\n\n"
  },
  {
    "name": "abr",
    "text": "def abr(vim):\n    arg = vim.arg\n    s = read(\"/home/kdog3682/PYTHON/vim_package_manager.py\")\n    identifiers = get_function_identifiers(s)\n    # key =\n    globals().get(key)\n\n"
  },
  {
    "name": "add_extension",
    "text": "def add_extension(s, ext):\n    if not s:\n        return \"\"\n    if get_extension(s):\n        return s\n    return s + \".\" + ext\n\n"
  },
  {
    "name": "create_directory_from_files",
    "text": "def create_directory_from_files(dir, files, ref=\"~/PYTHON\"):\n    e = FileType(ref).ext\n\n    def runner(file):\n        file = add_extension(file, e)\n        base = npath(ref, file)\n        new = npath(dir, file)\n        assert is_file(base)\n        return (base, new)\n\n    files = map(files, runner)\n    maybe_print(files)\n\n"
  },
  {
    "name": "shellescape",
    "text": "def shellescape(s):\n    return s if is_primitive(s) else json.dumps(s)\n\n"
  },
  {
    "name": "entries",
    "text": "def entries(items):\n    return items.items() if is_object(items) else items\n\n"
  },
  {
    "name": "map",
    "text": "def map(items, fn):\n    store = []\n    gn = fn if count_parameters(fn) == 1 else lambda x: fn(*x)\n    for item in entries(items):\n        store.append(gn(item))\n    return store\n\n"
  },
  {
    "name": "flat",
    "text": "def flat(*args):\n    def runner(items):\n        for item in items:\n            if is_array(item):\n                runner(item)\n            elif is_defined(item):\n                store.append(item)\n\n    store = []\n    runner(args)\n    return store\n\n"
  },
  {
    "name": "node",
    "text": "def node(file, *args):\n    deno_expr = \"deno run --allow-all\"\n    items = flat(deno_expr, expand(file), *map(args, shellescape))\n    cmd = join(items)\n    result = system(cmd, mode=dict, confirm=1)\n    success = result.get(\"success\")\n    parsed = parse_json(success)\n    print(parsed)\n\n"
  },
  {
    "name": "write_json",
    "text": "def write_json(file, content):\n    if not content:\n        return\n    file = expand(file)\n    with open(file, \"w\") as f:\n        json.dump(content, f, indent=2, ensure_ascii=False)\n        print(f\"wrote file: {file} as json\")\n\n"
  },
  {
    "name": "read_write",
    "text": "def read_write(file, fn, raw=0, confirm=0, **kwargs):\n    file = expand(file)\n    if get_extension(file) == \"json\" and not raw:\n        value = fn(read_json(file), **kwargs)\n        if confirm:\n            if not value:\n                return print(\n                    f\"no value ... nothing to confirm for {file}\"\n                )\n            prompt(\"requesting confirmation\", value)\n        write_json(file, value)\n    else:\n        value = fn(read(file), **kwargs)\n        if confirm:\n            if not value:\n                return print(\n                    f\"no value ... nothing to confirm for {file}\"\n                )\n            prompt(\"requesting confirmation\", value)\n        write(file, value)\n\n"
  },
  {
    "name": "update_package_json",
    "text": "def update_package_json(dir, payload):\n    file = dir if is_file(dir) else npath(dir, \"package.json\")\n    assert is_file(file)\n\n    def callback(data):\n        data.update(payload)\n        return data\n\n    read_write(file, callback)\n\n"
  },
  {
    "name": "get_local_functions",
    "text": "def get_local_functions():\n    module = __import__(__name__)\n    names = module.__dict__.keys()\n    local_functions = [\n        name\n        for name in names\n        if inspect.isfunction(module.__dict__[name])\n        and inspect.getmodule(module.__dict__[name]).__file__\n        == module.__file__\n    ]\n    return local_functions\n\n"
  },
  {
    "name": "generate_changelog",
    "text": "def generate_changelog(vim, since_tag=None):\n    if since_tag:\n        range_spec = f\"{since_tag}..HEAD\"\n    else:\n        range_spec = \"\"\n\n    s = \"\"\"\n        cd $gitdir\n        git log --pretty=format:%s $range_spec\n    \"\"\"\n    success = system(vt, vim, {\"range_spec\": range_spec}, str)\n    temp(success)\n\n"
  },
  {
    "name": "rmcache",
    "text": "def rmcache(dir):\n    path = npath(dir, \"__pycache__\")\n    rmdir(path)\n\n"
  },
  {
    "name": "transform_to_raw_url",
    "text": "def transform_to_raw_url(url):\n    return url.replace(\n        \"github.com\", \"raw.githubusercontent.com\"\n    ).replace(\"/blob/\", \"/\")\n\n"
  },
  {
    "name": "dict_from_module",
    "text": "def dict_from_module(module):\n    context = {}\n    for setting in dir(module):\n        # you can write your filter here\n        if setting.islower() and setting.isalpha():\n            context[setting] = getattr(module, setting)\n\n    return context\n\n"
  },
  {
    "name": "parse_structure",
    "text": "def parse_structure(text: str) -> dict:\n    structure = {}\n    current_node = structure\n    path_stack = []\n    lines = text.strip().split(\"\\n\")\n\n    for line in lines:\n        if line.strip() == \"\":\n            continue\n\n        indent_level = len(line) - len(line.lstrip(\" \"))\n        assert indent_level % 4 == 0\n        item = line.strip()\n\n        current_depth = indent_level // 4\n\n        if current_depth > len(path_stack):\n            path_stack.append(current_node)\n        while current_depth < len(path_stack):\n            path_stack.pop()\n            current_node = path_stack[-1]\n\n        if get_extension(item):\n            current_node[item] = None\n        else:\n            current_node[item] = {}\n            current_node = current_node[item]\n\n    return structure\n\n"
  },
  {
    "name": "search_path_upwards",
    "text": "def search_path_upwards(path: str, target: str) -> str:\n    while true:\n        path = head(path)\n        if path == stop:\n            raise Exception(\n                f\"\"\"\n                Could not find any parent path ending in {target}.\n            \"\"\"\n            )\n        match = npath(path, target)\n        if os.path.exists(match):\n            return match\n\n"
  },
  {
    "name": "get_project_root_directory",
    "text": "def get_project_root_directory(file):\n    target = jspy(\"project_root_directory\", file)\n    return search_path_upwards(file, target)\n\n"
  },
  {
    "name": "push_config_files_to_github",
    "text": "def push_config_files_to_github(vim):\n    dir = get_project_root_directory(vim.file)\n    files = glob(dir, kind=\"config\")\n\n"
  },
  {
    "name": "checkpointf",
    "text": "def checkpointf(**kwargs):\n    kind = kwargs.get(\"kind\")\n    skip = kwargs.get(\"skip\")\n\n    def checkpoint(file):\n        name = tail(file)\n        return True\n\n    if skip:\n\n        def checkpoint(file):\n            name = tail(file)\n            if name in skip:\n                return False\n            return True\n\n    if kind:\n        always = [\"package.json\"]\n\n        def checkpoint(file):\n            name = tail(file)\n            if kind in always and name == kind:\n                return True\n\n    return checkpoint\n\n"
  },
  {
    "name": "deep_glob",
    "text": "def deep_glob(dir, **kwargs):\n    dir = expand(dir)\n    assert is_dir(dir)\n    file_checkpoint = checkpointf(**kwargs)\n    dir_checkpoint = checkpointf(skip=skippable_directories)\n\n    def runner(x):\n        if is_file(x):\n            if file_checkpoint(x):\n                return {\"file\": x}\n        elif is_dir(x):\n            if dir_checkpoint(x):\n                return {\n                    \"dir\": x,\n                    \"children\": filter(map(absdir(x), runner)),\n                }\n\n    return runner(dir)\n\n"
  },
  {
    "name": "glob",
    "text": "def glob(dir, **kwargs):\n    file_checkpoint = checkpointf(**kwargs)\n    dir_checkpoint = checkpointf(skip=skippable_directories)\n    store = []\n\n    def runner(dir):\n        files = absdir(dir)\n        for file in files:\n            if is_file(file):\n                if file_checkpoint(file):\n                    store.append(file)\n            elif is_dir(file):\n                if dir_checkpoint(file) and file_checkpoint(file):\n                    runner(file)\n\n    if kwargs.get(\"kind\") == \"dir\":\n\n        def runner(dir):\n            files = absdir(dir)\n            for file in files:\n                if is_dir(file):\n                    if dir_checkpoint(file):\n                        runner(file)\n\n    runner(dir)\n    return store\n\n"
  },
  {
    "name": "switch_pnpm_versions",
    "text": "def switch_pnpm_versions(dir, field: str, switchers: Iterable[str]):\n    package_json_files = glob(dir, kind=\"package.json\")\n    a, b = switchers\n\n    def inner(json):\n        pm = json.get(field)\n        if pm:\n            if pm == a:\n                json[\"packageManager\"] = b\n                print(\"updated field\", field, a, \"->\", b)\n            elif pm == b:\n                print(\"only switching\", a, \"to\", b)\n                return\n                json[\"packageManager\"] = a\n                print(\"updated field\", field, b, \"->\", a)\n            else:\n                return\n            return json\n\n    def callback(file):\n        read_write(file, inner)\n\n    map(package_json_files, callback)\n\n"
  },
  {
    "name": "view_hot_xdg_directories",
    "text": "def view_hot_xdg_directories():\n    for a, b in entries(XDG_DIRECTORY_MAP):\n        if b and is_dir(expand(b)):\n            while True:\n                a = choose(absdir(b))\n                if not a:\n                    break\n                prompt(absdir(a))\n\n"
  },
  {
    "name": "to_path",
    "text": "def to_path(x):\n    if is_string(x):\n        return Path(expand(x))\n    else:\n        return x\n\n"
  },
  {
    "name": "get_most_recent_file",
    "text": "def get_most_recent_file(x: Path | List | str) -> str:\n    if is_array(x):\n        files = x\n    else:\n        files = to_path(x).glob(\"*\")\n\n    target = max(files, key=lambda f: to_path(f).stat().st_mtime)\n    return str(target)\n\n"
  },
  {
    "name": "generate_common_domains",
    "text": "def generate_common_domains(data):\n    def parse(s):\n        return match(s, \"https://(.*?)/\")\n\n    urls = sort(unique(map(data, lambda x: parse(x[\"url\"]))))\n    return append_self(\"IGNORABLE_COMMON_WEBSITE_DOMAINS\", urls)\n\n"
  },
  {
    "name": "create_bookmarks_from_chrome_history",
    "text": "def create_bookmarks_from_chrome_history():\n    \"\"\"\n    the chrome history is retrieved from a chrome extension\n    the urls are those that have more than 5 visits\n    certain website domains are ignored\n\n    the payload is merged with cached_bookmark_file.\n    \"\"\"\n    checkpoint = testf(IGNORABLE_WEBSITE_DOMAINS, anti=1, key=\"url\")\n\n    file = get_most_recent_file(\n        filter(absdir(dldir), testf(\"history.json\"))\n    )\n    data = read_json(file)\n    data = filter(data, checkpoint)\n    data = filter(data, lambda x: x[\"visitCount\"] > 5)\n    data = map(data, lambda x: x[\"url\"])\n    data = sort(unique(data))\n    new_data = data\n    cached_bookmark_file = (\n        \"~/.cache/kdog3682/frequently_visited_chrome_bookmarks.json\"\n    )\n\n    def callback(data):\n        if data:\n            return unique(new_data + data)\n        else:\n            return new_data\n\n    read_write(cached_bookmark_file, callback)\n\n"
  },
  {
    "name": "rm",
    "text": "def rm(x, confirm=0):\n    x = os.path.expanduser(x)\n    if confirm:\n        prompt(\"removing:\", x)\n    if is_dir(x):\n        shutil.rmtree(x)\n        print(\"removing dir\", x)\n    elif is_file(x):\n        os.remove(x)\n        print(\"removing file\", x)\n\n"
  },
  {
    "name": "mv",
    "text": "def mv(a, b, confirm=0):\n    a = expand(a)\n    b = expand(b)\n    if confirm:\n        print(\"moving content from input to output\")\n        print(\"input\", a)\n        print(\"output\", b)\n        print(\"type [y] to confirm\")\n        print(\"\")\n        if not input(\"\") == \"y\":\n            return\n    if is_dir(a):\n        shutil.move(a, b)\n        print(\"moving dir\", a, \"to\", b)\n    elif is_file(a):\n        shutil.move(a, b)\n        print(\"moving file\", a, \"to\", b)\n\n\n\n"
  },
  {
    "name": "cp",
    "text": "def cp(a, b, confirm=0, silent=0):\n    a = expand(a)\n    if not os.path.exists(a):\n        return\n    b = expand(b)\n\n    if is_dir(a):\n        if os.path.exists(b):\n            return print(f\"ERROR: {b} already exists\")\n        shutil.copytree(a, b)\n    elif is_file(a):\n        if not os.path.exists(b) and not is_dot_file(b):\n            ensure_dir_exists(b)\n        shutil.copy(a, b)\n\n    if not silent:\n        print(\"copy success\", b)\n\n"
  },
  {
    "name": "redownload_repository",
    "text": "def redownload_repository():\n    system(\n        \"\"\"\n        cd ~/GITHUB\n        rm -rf ~/GITHUB/bkl\n        git clone https://github.com/kdog3682/bkl\n        cp -r ~/GITHUB/bkl/frontend ~/@bkl/frontend\n    \"\"\"\n    )\n\n"
  },
  {
    "name": "mkdir",
    "text": "def mkdir(dir):\n    dir = expand(dir)\n    if is_dir(dir):\n        print(f\"Directory '{dir}' already exists.\")\n    else:\n        os.makedirs(dir)\n        print(\"made dir\", dir)\n        return dir\n\n"
  },
  {
    "name": "callback",
    "text": "def callback(path: str):\n    pprint(files)\n    print(\"num_files\", len(files))\n    if confirm(f\"change path {path}\"):\n        pop(files, path)\n        mv(path, dest)\n\n"
  },
  {
    "name": "xdg_cache_revert",
    "text": "def xdg_cache_revert(file, confirm=0):\n    file = expand(file)\n    name = get_xdg_cache_backup_filename(file)\n    cp(name, file, silent=1)\n    print(f\"reverted {file} via xdg_backup_cache\")\n\n"
  },
  {
    "name": "get_xdg_cache_backup_filename",
    "text": "def get_xdg_cache_backup_filename(file):\n    return os.path.join(xdg_kdog_dir, \"backup\", sub(file, \"/\", \"___\"))\n\n"
  },
  {
    "name": "xdg_cache_backup",
    "text": "def xdg_cache_backup(file, confirm=0):\n    file = expand(file)\n    name = get_xdg_cache_backup_filename(file)\n    cp(file, name, silent=1)\n    print(\"backed up file\", file)\n    print(\"as\", name)\n    if confirm:\n        printdir(head(name))\n        input(\"press anything to continue\")\n\n"
  },
  {
    "name": "fix_json_file",
    "text": "def fix_json_file(file, confirm=0, data=0):\n    file = expand(file)\n    try:\n        s = read_json(file)\n        if data:\n            return s\n        return True\n    except Exception as e:\n        try:\n            s = eval(read(file))\n            if data:\n                return s\n            if confirm:\n                prompt(f\"{file} has been fixed!\")\n            write_json(file, s)\n            return True\n        except Exception as e:\n            if data:\n                sys_exit(f\"unable to fix {file}\")\n            print(str(e))\n            if confirm:\n                sys_exit(f\"unable to fix {file}\")\n            else:\n                print(f\"unable to fix {file}\")\n                log_file(file)\n\n"
  },
  {
    "name": "log_file",
    "text": "def log_file(file):\n    m = \"\\n\" + str(timestamp()) + \" \" + expand(file)\n    append(\"/home/kdog3682/2024/files.log\", m)\n\n"
  },
  {
    "name": "printdir",
    "text": "def printdir(dir):\n    pprint(absdir(dir))\n\n"
  },
  {
    "name": "print_directory_tree",
    "text": "def print_directory_tree(root):\n    def runner(obj):\n        s = \"\"\n        for a, b in entries(obj):\n            if a == \"dir\":\n                s = tail(b)\n            elif a == \"file\":\n                return tail(b)\n            elif a == \"children\":\n                return s + \":\\n\" + indent(join(map(b, runner), \"\\n\"))\n\n    obj = deep_glob(root)\n    s = runner(obj)\n    return s\n\n"
  },
  {
    "name": "write_string",
    "text": "def write_string(file, content):\n    with open(file, \"w\") as f:\n        f.write(content)\n        print(f\"wrote file: {file}\")\n\n"
  },
  {
    "name": "write",
    "text": "def write(file, content, mkdir=0, confirm=0, **kwargs):\n    if not content:\n        return\n    file = expand(file)\n\n    if kwargs.get(\"confirm\"):\n        print(content)\n        print(\"\")\n        confirm(f\"writing {file}\")\n    if mkdir:\n        ensure_dir_exists(head(file))\n\n    if is_string(content):\n        write_string(file, content)\n    else:\n        write_json(file, content)\n\n    if kwargs.get(\"save\"):\n        filelog(file)\n    if kwargs.get(\"open\"):\n        view(file)\n\n"
  },
  {
    "name": "filelog",
    "text": "def filelog(file):\n    append(\n        filelog_file,\n        \"\\n\" + str(iso8601()) + \" \" + expand(file),\n    )\n\n"
  },
  {
    "name": "xdg_cache_write",
    "text": "def xdg_cache_write(a, b):\n    ext = \"txt\" if is_primitive(b) else \"json\"\n    write(\n        npath(\"~/.cache/kdog3682\", add_extension(a, ext)), b, save=1\n    )\n\n"
  },
  {
    "name": "create_bkl_composables_directory",
    "text": "def create_bkl_composables_directory():\n    ref = \"/home/kdog3682/@bkl/packages/shared\"\n    dir = \"/home/kdog3682/@bkl/packages/composables\"\n\n"
  },
  {
    "name": "get_indent_and_text",
    "text": "def get_indent_and_text(s):\n    a, b = match(s, \"^( *)(.*)\")\n    return (len(a), b)\n\n"
  },
  {
    "name": "go_to_file_via_file_tree",
    "text": "def go_to_file_via_file_tree(vim):\n    indent, text = get_indent_and_text(vim.line)\n    start = vim.index\n\n"
  },
  {
    "name": "update_package_jsons",
    "text": "def update_package_jsons(callback):\n    files = glob(\"~/@bkl\", kind=\"package.json\")\n\n    def inner(data):\n        data.update(payload)\n        return data\n\n    def runner(file):\n        read_write(file, callback)\n\n    map(files, runner)\n\n"
  },
  {
    "name": "xdg_cache_read",
    "text": "def xdg_cache_read(name):\n    my_xdg_cache_path = \"/home/kdog3682/.cache/kdog3682/\"\n    path = npath(my_xdg_cache_path, add_extension(name, \"json\"))\n    return (\n        read_json(path) if get_extension(path, \"json\") else read(path)\n    )\n\n"
  },
  {
    "name": "create_new_bkl_package",
    "text": "def create_new_bkl_package(name, files=[]):\n    j = copy(reference_package_json)\n    j[\"name\"] = f\"@bkl/{name}\"\n    j = json.dumps(j, indent=4)\n    dirpath = f\"~/@bkl/packages/{name}\"\n    package_json_path = npath(dirpath, \"package.json\")\n    entry_path = npath(os.path.join(dirpath, \"src\"), \"index.js\")\n    entry_content = smart_dedent(f\"\"\" export * from \"./\" \"\"\")\n\n    cp(\"~/@bkl/packages/env/vite.config.js\", os.path.join(dirpath))\n    # this is a safe reference\n    write(entry_path, entry_content, mkdir=1, save=1, confirm=1)\n    write(package_json_path, j, mkdir=1, save=1, confirm=1)\n\n    if files:\n        dir = npath(dirpath, \"src\")\n        mkdir(dir)\n\n        def callback(file):\n            cp(file, npath(dir, file))\n\n        map(files, callback)\n\n"
  },
  {
    "name": "tail",
    "text": "def tail(x):\n    return os.path.basename(x)\n\n"
  },
  {
    "name": "head",
    "text": "def head(x):\n    return os.path.dirname(x)\n\n"
  },
  {
    "name": "filetree_matcher",
    "text": "def filetree_matcher(vim):\n    lines = vim.lines\n    line = vim.line\n    index = vim.index\n    effective_lines = filter(lines[0 : index - 1], testf(\": *$\"))\n    dirs = map(effective_lines, trim)\n    path = os.path.join(root, *dirs, trim(line))\n    return path\n\n"
  },
  {
    "name": "dict_getter",
    "text": "def dict_getter(base, *args):\n    length = len(args)\n    if length == 1:\n        return base[args[0]]\n    if length == 2:\n        return base[args[0]][args[1]]\n    if length == 3:\n        return base[args[0]][args[1]][args[2]]\n    unreachable(\"depth 3 is the max for now\")\n\n"
  },
  {
    "name": "jspy",
    "text": "def jspy(filetype, key):\n    try:\n        return jspyref[filetype][key]\n    except Exception as e:\n        return None\n\n"
  },
  {
    "name": "get_dir_from_filetype",
    "text": "def get_dir_from_filetype(filetype):\n    try:\n        return jspy(filetype, \"base_directory\")\n    except Exception as e:\n        return \"/home/kdog3682/2024/\"\n\n"
  },
  {
    "name": "filelog_matcher",
    "text": "def filelog_matcher(vim):\n    def omni_resolve(file):\n        if test(file, \"^\\w\"):\n            dir = get_dir_from_filetype(get_filetype(file))\n            return npath(dir, file)\n        return resolve(file)\n\n    candidates = split(vim.line, \" \")\n    return smallify(filter(map(candidates, local_resolver)))\n\n"
  },
  {
    "name": "packagejson_matcher",
    "text": "def packagejson_matcher(vim):\n    pass\n\n"
  },
  {
    "name": "str_wrap",
    "text": "def str_wrap(s, wrapper):\n    return wrapper + s + wrapper\n\n"
  },
  {
    "name": "pyvim_plugin_connector",
    "text": "def pyvim_plugin_connector():\n    def payload_wrapper(payload):\n        print(str_wrap(json.dumps(payload), \"~~~\"))\n\n    def wrapper(fn, vim):\n        payload = {\n            \"open\": 0,\n            \"error\": 0,\n            \"action\": 0,\n            \"empty\": 0,\n            \"status\": 0,\n            \"success\": 0,\n            \"replace\": 0,\n            \"write\": 0,\n            \"create\": 0,\n            \"build\": 0,\n            \"generate\": 0,\n            \"value\": 0,\n            \"result\": 0,\n        }\n\n        result = None\n        try:\n            result = fn(vim)\n            payload[\"success\"] = 1\n            if is_array(result):\n                payload[\"command\"] = pascal_case(result[0])\n                payload[\"args\"] = result[1:]\n            else:\n                payload[\"args\"] = (\n                    [result[\"arg\"]]\n                    if \"arg\" in result\n                    else result[\"args\"]\n                )\n                payload[\"command\"] = pascal_case(result[\"command\"])\n        except Exception as e:\n            result = str(e)\n            payload[\"error\"] = 1\n            payload[\"message\"] = result\n\n        return payload\n\n    vim = VimState(get_sys_args(1))\n    api = __import__(\"api\")\n    fn = getattr(api, snake_case(vim.command))\n    payload = wrapper(fn, vim)\n    payload_wrapper(payload)\n\n"
  },
  {
    "name": "run_cmd_from_str",
    "text": "def run_cmd_from_str(s):\n    funcs = globals()\n\n    def runner(s):\n        items = split(s, \"\\s+\")\n        fnkey, *args = items\n\n        blue_colon(\"running command from str\", s)\n        blue_colon(\"fnkey\", fnkey)\n        blue_colon(\"args\", args)\n\n        fn = funcs.get(fnkey)\n        args = map(args, to_argument)\n        fn(*args)\n\n    items = split(s, \"\\n\\n+\")\n    item = items[-1]\n    runner(item)\n    sys_exit(\"\")\n\n"
  },
  {
    "name": "dump_json",
    "text": "def dump_json(s):\n    return json.dumps(s, indent=4, ensure_ascii=True)\n\n"
  },
  {
    "name": "chdir",
    "text": "def chdir(dir):\n    dir = expand(dir)\n    os.chdir(dir)\n    print(f\"changing dir to {dir}\")\n\n"
  },
  {
    "name": "create_new_app",
    "text": "def create_new_app(name):\n    dir = expand(f\"~/@bkl/apps/examples/{name}\")\n    mkdir(dir)\n    # print(system(\"pnpm create vite\", confirm = 1, cwd = \"~/LOREMDIR\"))\n\n"
  },
  {
    "name": "quick",
    "text": "def quick(s):\n    prefix, a, b = match(\n        trim(s),\n        \"^(delete|read|file|write|append): *(.+)(?:\\s+([\\w\\W]+))?\",\n        flags=re.I,\n    )\n    prompt((prefix, a, b))\n    a = expand(a)\n    b = trim(b)\n    fn = None\n    if prefix == \"append\":\n        fn = append\n    elif prefix == \"delete\" and is_file(a):\n        return rm(a)\n    elif prefix == \"read\":\n        return print(b)\n    else:\n        fn = write\n\n    print(b)\n    prompt(\"file\", a)\n    fn(a, b)\n\n"
  },
  {
    "name": "iterate_thru_bkl",
    "text": "def iterate_thru_bkl(callback, **kwargs):\n    paths: list[str] = iterate_thru_paths(\"~/@bkl\", **kwargs)\n    return map(paths, callback)\n\n"
  },
  {
    "name": "iterate_thru_paths",
    "text": "def iterate_thru_paths(root, exclude=[], include=[], type=None):\n    store = []\n    runner = None\n    include = flat(include)\n    exclude = flat(exclude)\n    if not type and not include:\n        raise Exception(\n            \"either a type (file or dir) or include is required\"\n        )\n\n    if not type and get_extension(include[0]):\n        type = \"file\"\n    else:\n        type = \"dir\"\n\n    if type == \"dir\":\n\n        def runner(path):\n            for entry in os.listdir(path):\n                entry_path = os.path.join(path, entry)\n                if is_dir(entry_path):\n                    if entry in skippable_directories:\n                        continue\n                    if entry in exclude:\n                        continue\n\n                if not include or include and entry in include:\n                    store.append(entry_path)\n                runner(entry_path)\n\n    else:\n\n        def runner(path):\n            for entry in os.listdir(path):\n                entry_path = os.path.join(path, entry)\n                if is_dir(entry_path):\n                    if entry in skippable_directories:\n                        continue\n                    runner(entry_path)\n                else:\n                    if entry in exclude:\n                        continue\n\n                    if not include or include and entry in include:\n                        store.append(entry_path)\n\n    runner(expand(root))\n    return store\n\n"
  },
  {
    "name": "_get_directories",
    "text": "def _get_directories(root, exclude=[], include=[]):\n    store = []\n\n    def runner(path):\n        directories = []\n        for entry in os.listdir(path):\n            entry_path = os.path.join(path, entry)\n            if is_dir(entry_path):\n                if entry in skippable_directories:\n                    continue\n                if entry in exclude:\n                    continue\n\n                if not include or include and entry in include:\n                    store.append(entry_path)\n                runner(entry_path)\n\n    runner(expand(root))\n    return store\n\n"
  },
  {
    "name": "iterate_thru_package_jsons",
    "text": "def iterate_thru_package_jsons(callback):\n    files = glob(\"~/@bkl\", kind=\"package.json\")\n    map(\n        files,\n        lambda file: read_write(\n            file, lambda data: callback(file, data)\n        ),\n    )\n\n"
  },
  {
    "name": "callback",
    "text": "def callback(file, data):\n    if \"packageManager\" not in data:\n        data[\"packageManager\"] = \"pnpm@9.0.6\"\n        return data\n\n"
  },
  {
    "name": "callback",
    "text": "def callback(x):\n    # print(x)\n    fix_json_file(x)\n\n"
  },
  {
    "name": "is_dir",
    "text": "def is_dir(x):\n    if type(x) == str:\n        return os.path.isdir(os.path.expanduser(x))\n\n"
  },
  {
    "name": "is_file",
    "text": "def is_file(x):\n    if type(x) == str:\n        return os.path.isfile(os.path.expanduser(x))\n\n"
  },
  {
    "name": "download_folder_within_repository",
    "text": "def download_folder_within_repository(path, dest):\n    if is_dir(dest):\n        if confirm(\n            f\"remove directory {dest} before copying new directory\",\n            abort=1,\n        ):\n            rmdir(dest)\n\n    temp_github_dir = \"~/GITHUB/temp\"\n    # if is_dir(temp_github_dir):\n    # rmdir(temp_github_dir)\n\n    path = sub(path, \"^https://github.com/\", \"\")\n    path = sub(path, \"tree/master/\", \"\")\n    path = sub(path, \"(src|public|dist)$\", \"\")\n    parts = split(path, \"/\")\n    assert len(parts) == 3\n    owner, repo, subdirectory = parts\n    url = f\"https://github.com/{owner}/{repo}\"\n    system(f\"git clone {url} {temp_github_dir}\")\n    print(\"system step complete\")\n    time.sleep(1)\n    path = os.path.join(temp_github_dir, subdirectory)\n    prompt(path, dest)\n    cp(path, dest)\n\n"
  },
  {
    "name": "rn",
    "text": "def rn(file, name, confirm=0):\n    new_name = npath(head(file), name)\n    if confirm:\n        prompt(\n            f\"\"\"\n            renaming source: {file} \n            to {new_name}\n        \"\"\"\n        )\n    os.rename(file, new_name)\n\n"
  },
  {
    "name": "get_package_json_file",
    "text": "def get_package_json_file(dir):\n    return npath(dir, \"package.json\")\n\n"
  },
  {
    "name": "get_root_package_json_file",
    "text": "def get_root_package_json_file(x):\n    dir = get_git_dir_from_path(x)\n    return get_package_json_file(dir)\n\n"
  },
  {
    "name": "boundary_replace",
    "text": "def boundary_replace(s, a, b):\n    return dreplace(s, {a: b}, template=\"\\\\b(?:$1)\\\\b\")\n\n"
  },
  {
    "name": "alabaster",
    "text": "def alabaster(dir, new_name, confirm=1):\n    def second(data):\n        data[\"name\"] = new_name\n        return data\n\n    def first(s):\n        name = tail(dir)\n        if test(s, \"\\\\b\" + name + \"\\\\b\"):\n            return boundary_replace(s, name, new_name)\n\n    read_write(\n        get_root_package_json_file(dir), first, raw=1, confirm=confirm\n    )\n    read_write(get_package_json_file(dir), second, confirm=confirm)\n    rn(dir, new_name, confirm=confirm)\n\n"
  },
  {
    "name": "check_package_jsons_lineup_in_bkl",
    "text": "def check_package_jsons_lineup_in_bkl(target):\n    root_package_json = \"/home/kdog3682/@bkl/package.json\"\n    frontend_package_json = (\n        \"/home/kdog3682/@bkl/frontend/brooklynlearning/package.json\"\n    )\n    newcomer = fix_json_file(target, data=1)\n    newcomer[\"packageManager\"] = \"pnpm@9.0.6\"\n\n    a = read_json(root_package_json)\n    b = read_json(frontend_package_json)\n    jsons = [a, b]\n\n    fields = [\n        \"dependencies\",\n        \"devDependencies\",\n    ]\n    mistakes = {}\n    error = 0\n    for field in fields:\n        sample = newcomer.get(field, {})\n        for json in jsons:\n            ref = json.get(field, {})\n            for k, v in ref.items():\n                if k in sample:\n                    if sample[k] != v:\n                        error = 1\n                        print(k)\n                        print(\"we have an error in the newcomer!\")\n                        print(\"expected:\", v)\n                        print(\"got:\", sample[k])\n                        newcomer[field][k] = v\n    if error:\n        if confirm(\"rewrite the package.json with new edited values\"):\n            write_json(target, newcomer)\n    else:\n        print(\"all good! all dependencies match!\")\n\n"
  },
  {
    "name": "abrev",
    "text": "def abrev(s):\n    r = \"\\W|(\\d)\"\n    items = filter(re.split(r, s))\n    return \"\".join(map(items, lambda x: x[0])).lower()\n\n"
  },
  {
    "name": "iso8601",
    "text": "def iso8601():\n    return datetime.now().isoformat()[0:10]\n\n"
  },
  {
    "name": "get_fish_abbreviations",
    "text": "def get_fish_abbreviations():\n    s = filter(line_getter(read(\"~/.bash_commands\")))\n\n    def callback(line):\n        cmd, alias = match(line, \"^(\\S.*?) (\\S+)$\")\n        if alias == \"!\":\n            alias = abrev(cmd)\n        return alias, cmd\n\n    items = map(s, callback)\n    return items\n    # append(get_note_file())\n\n"
  },
  {
    "name": "write_fish_abbreviations",
    "text": "def write_fish_abbreviations():\n    callback = lambda x: f\"abbr {x[0]} '{x[1]}'\"\n    items = map(get_fish_abbreviations(), callback)\n    append(fish_config_file, join(items))\n    confirm(\"a\")\n    clear(\"~/.bash_history\")\n\n"
  },
  {
    "name": "get_note_file",
    "text": "def get_note_file():\n    return expand(f\"~/NOTES/{iso8601()}.txt\")\n\n"
  },
  {
    "name": "clip",
    "text": "def clip(x):\n    write(\"/home/kdog3682/2023/clip.js\", x, open=1)\n\n"
  },
  {
    "name": "increment_path",
    "text": "def increment_path(path):\n    path = expand(path)\n    base = path\n    count = 2\n    while os.path.exists(path):\n        h = head(path)\n        name = remove_extension(tail(path))\n        e = get_extension(path)\n        path = h + name + str(count) + \".\" + e\n        count += 1\n    return path\n\n"
  },
  {
    "name": "download_repository",
    "text": "def download_repository(path, targets=[], dest=None):\n    owner, repo = match(path, \"github.com/(\\S+?)/(\\S+?)(?:/|$)\")\n    outdir = expand(f\"~/github/{repo}\")\n    # if is_dir(outdir):\n    # outdir = f\" {increment_path(outdir)}\"\n    # else:\n    # outdir = \" \" + outdir\n    # url = f\"https://github.com/{owner}/{repo}\"\n    # if not system(f\"git clone {url}{outdir}\", mode=bool):\n    # return\n\n    if dest:\n        if targets:\n            target_files = map(targets, lambda x: npath(outdir, x))\n            assert every(target_files, os.path.exists)\n            map(target_files, lambda x: cp(x, npath(dest, x)))\n            printdir(dest)\n            return dest\n    else:\n        filelog(outdir)\n        return outdir\n\n"
  },
  {
    "name": "request",
    "text": "def request(url):\n    from requests import get\n\n    BROWSER_AGENT = \"Mozilla/5.0 (X11; CrOS aarch64 13310.93.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.133 Safari/537.36\"\n    # r = get(url), {\"user-agent\": BROWSER_AGENT})\n    # return parse_json(r.text) if r.status_code == 200 else \"\"\n\n"
  },
  {
    "name": "symlink",
    "text": "def symlink(path, to):\n    path = expand(path)\n    to = expand(to)\n    assert os.path.exists(path)\n\n    if os.path.exists(to):\n        rm(to, confirm=1)\n\n    cmd = f\"ln -s {path} {to}\"\n    print(cmd)\n    system(cmd)\n\n"
  },
  {
    "name": "setup_dot_files",
    "text": "def setup_dot_files():\n    return\n\n    mkdir(\"~/dotfiles\")\n    mkdir(\"~/dotfiles/bash\")\n    mkdir(\"~/dotfiles/vim\")\n\n    # copy the fully formed nvim directory\n    # https://github.com/xero/dotfiles\n    # cp(\"~/GITHUB/dotfiles/neovim/.config/nvim\", \"~/dotfiles/nvim\")\n\n    # copy bash stuff\n    cp(\"~/.bashrc\", \"~/dotfiles/bash/.bashrc\")\n    cp(\"~/.bash_aliases\", \"~/dotfiles/bash/.bash_aliases\")\n    cp(\"~/.profile\", \"~/dotfiles/bash/.profile\")\n\n    cp(\"~/.vim\", \"~/dotfiles/vim/.vim\")\n    cp(\"~/.vimrc\", \"~/dotfiles/vim/.vimrc\")\n    cp(\"~/.config/fish\", \"~/dotfiles/fish\")\n\n    # bash\n    # vim\n    # fish\n\n"
  },
  {
    "name": "is_dot_file",
    "text": "def is_dot_file(b):\n    return tail(b).startswith(\".\")\n\n"
  },
  {
    "name": "invoke_dot_files",
    "text": "def invoke_dot_files():\n    return\n    # symlink(\"~/dotfiles/nvim\", \"~/.config/nvim\") # done\n    # symlink(\"~/dotfiles/fish\", \"~/.config/fish\") # done\n    # symlink(\"~/dotfiles/vim/.vimrc\", \"~/.vimrc\")\n    # symlink(\"~/dotfiles/vim/.vim\", \"~/.vim\")\n\n"
  },
  {
    "name": "revert_dot_file",
    "text": "def revert_dot_file(file):\n    name = sub(file, \"^.*?dotfiles/\", \"\")\n    # return print(name)\n    base = os.path.join(\n        \"/home/kdog3682/GITHUB/dotfiles/neovim/.config\", name\n    )\n    shutil.copy(base, file)\n    print(\"reverted to base dot file!\")\n\n"
  },
  {
    "name": "write_tsconfig",
    "text": "def write_tsconfig():\n    data = {\n        \"compilerOptions\": {\n            \"plugins\": [{\"name\": \"@vue/typescript-plugin\"}]\n        }\n    }\n    write_json(\"~/tsconfig.json\", data)\n\n"
  },
  {
    "name": "copy_dir_to_dir",
    "text": "def copy_dir_to_dir(a, b):\n    a = expand(a)\n    b = expand(b)\n    shutil.copytree(a, b)\n\n"
  },
  {
    "name": "file_mover",
    "text": "def file_mover(dir):\n    files = absdir(dir)\n    for file in files:\n        name = tail(file)\n        if test(name, \"^kdog3682\"):\n            pass\n        else:\n            mv(file, npath(dest, file))\n"
  },
  {
    "name": "modular_state",
    "text": "def modular_state(o, key):\n    ref = o[key]\n    current = ref[\"current\"]\n    choices = ref[\"choices\"]\n    next = modular_increment(choices, current)\n    ref[\"current\"] = next\n    print(\"new value:\", next)\n    \n\n\n"
  },
  {
    "name": "pop",
    "text": "def pop(iterable, key=None):\n    if is_array(iterable):\n        if key == None:\n            return iterable.pop(-1)\n        return iterable.pop(iterable.index(key))\n    if is_object(iterable):\n        return iterable.pop(key)\n\n"
  },
  {
    "name": "parse_json",
    "text": "def parse_json(x):\n    try:\n        return json.loads(x)\n    except:\n        return x\n"
  },
  {
    "name": "to_argument",
    "text": "def to_argument(x):\n    if is_number(x):\n        return int(x)\n    return parse_json(x)\n\n"
  },
  {
    "name": "append_self",
    "text": "def append_self(data):\n    append(\n        \"/home/kdog3682/PYTHON/chatgpt_vim_python_executor.py\",\n        dump_json(data),\n    )\n\n"
  },
  {
    "name": "read_write",
    "text": "def read_write(file, fn, raw=0, confirm=0, **kwargs):\n    file = expand(file)\n    if get_extension(file) == \"json\" and not raw:\n        value = fn(read_json(file), **kwargs)\n        write_json(file, value)\n    else:\n        value = fn(read(file), **kwargs)\n        assert is_string(value)\n        vim_write_file(file, value)\n\n"
  },
  {
    "name": "confirm",
    "text": "def confirm(message):\n    print(message)\n    blue(\"Do you wish to confirm? press [y]\")\n    a = input(\"\\n\")\n    return True if a == \"y\" else False\n\n"
  },
  {
    "name": "is_loaded",
    "text": "def is_loaded(file):\n    return vim.funcs.bufloaded(file)\n\n"
  },
  {
    "name": "get_buffer_info",
    "text": "def get_buffer_info():\n    return vim.funcs.getbufinfo()\n\n"
  },
  {
    "name": "open_buffer",
    "text": "def open_buffer(file, path_must_exist=False):\n    raise Exception(\"asdf\")\n    if not file:\n        return\n    file = expand(file)\n\n    if is_url(file):\n        return webbrowser.open(file)\n    if not os.path.exists(file):\n        if path_must_exist:\n            ensure_dir_exists(head(file))\n        else:\n            return\n\n    execute(\"edit\", file)\n\n"
  },
  {
    "name": "templatef",
    "text": "def templatef(template):\n    def wrapper(*args):\n        return templater(template, args)\n\n    return wrapper\n\n"
  },
  {
    "name": "close_non_essential_buffers",
    "text": "def close_non_essential_buffers():\n    buffers = get_buffers(testf(\"\"))\n    cmd = join(map(buffers, templatef(\"bd $1\")))\n    execute(cmd)\n\n"
  },
  {
    "name": "maybe_fix_col",
    "text": "def maybe_fix_col(col, line):\n    if line[col].isspace():\n        # Scan left for the nearest non-whitespace character\n        left = col\n        while left > 0 and line[left].isspace():\n            left -= 1\n        # Scan right for the nearest non-whitespace character\n        right = col\n        while right < len(line) and line[right].isspace():\n            right += 1\n        # Adjust column to the closest non-whitespace side\n        if col - left <= right - col and left > 0:\n            col = left\n        elif right < len(line):\n            col = right\n    return col\n\n"
  },
  {
    "name": "get_yaml",
    "text": "def get_yaml(s):\n    import yaml\n\n    if is_file(s):\n        with open(s, \"r\") as file:\n            return yaml.safe_load(file)\n    else:\n        return yaml.safe_load(s)\n\n"
  },
  {
    "name": "get_function_name",
    "text": "def get_function_name(fn):\n    if is_function(fn):\n        return fn.__name__\n    return match(get_line(), jspy(\"patterns.func_name\"))\n\n"
  },
  {
    "name": "noremap",
    "text": "def noremap(key, cmd):\n    return generate_vim_command(key, cmd)\n\n"
  },
  {
    "name": "generate_vim_command",
    "text": "def generate_vim_command(\n    key,\n    cmd,\n    mode=\"normal\",\n    leader=0,\n    silent=0,\n    nowait=0,\n    buffer=0,\n    export=0,\n    save_before_call = 0,\n    save=0,\n    expr=0,"
  },
  {
    "name": "setline",
    "text": "def setline(a, b):\n    vim.funcs.setline(a, b)\n\n"
  },
  {
    "name": "replace_word_under_cursor",
    "text": "def replace_word_under_cursor(payload):\n    s = get_line()\n    c, a, b = get_word_boundaries(\"[-\\W]\")\n    if a == b:\n        a -= 2\n    left_part = s[0 : a + 1]\n    right_part = s[b : len(s)]\n    text = left_part + payload + right_part\n    setline(\".\", text)\n\n    # t  = foobar + payload + right_part\n    # text = left_part + payload + foobar\n    # text = left_part + foobar + right_part\n    # foobar = left_part + payload + right_part\n\n"
  },
  {
    "name": "GetVisualSelection",
    "text": "def GetVisualSelection():\n    start_pos = vim.funcs.getpos(\"'<\")\n    end_pos = vim.funcs.getpos(\"'>\")\n\n    # Check if selection is on the same line\n    if start_pos[1] == end_pos[1]:\n        line_num = start_pos[1]\n        start_col, end_col = start_pos[2], end_pos[2]\n\n        # Swap if start_col is greater than end_col\n        if start_col > end_col:\n            start_col, end_col = end_col, start_col\n\n        # Get the line text\n        line_text = vim.fn.getline(\".\")\n        visual_selection = line_text[\n            start_col - 1 : end_col\n        ]  # Adjusting because Python uses 0-based indexing\n        return visual_selection\n    return \"\"\n\n"
  },
  {
    "name": "assertion",
    "text": "def assertion():\n    return\n\n"
  },
  {
    "name": "select_multiple",
    "text": "def select_multiple(items, message=None, display=identity):\n    indexes = []\n    while True:\n        for i, item in enumerate(items):\n            key = str(i + 1) + \". \"\n            if i in indexes:\n                print(key, \"YES\", item)\n            else:\n                print(key, \"NIL\", item)\n        print(\"\")\n        a = getchar()\n        if a == None:\n            break\n        if is_number(a):\n            indexes.append(a - 1)\n\n    return map(indexes, lambda x: items[x])\n\n"
  },
  {
    "name": "select",
    "text": "def select(items, message=None, display=identity):\n    if len(items) == 0:\n        return\n    if len(items) == 1:\n        return items[0]\n\n    if message:\n        print(message)\n        print(\"\")\n\n    for i, item in enumerate(items):\n        print(str(i + 1) + \".  \", display(item))\n\n    try:\n        if len(items) < 10:\n            a = getchar()\n            if a == None:\n                return None\n        else:\n            a = vim.funcs.input(\"\")\n        return items[int(a) - 1]\n    except Exception as e:\n        return None\n\n"
  },
  {
    "name": "get_word",
    "text": "def get_word():\n    return vim.funcs.expand(\"<cword>\")\n\n"
  },
  {
    "name": "help",
    "text": "def help(key=None):\n    if not key:\n        key = get_word()\n    if key in known:\n        print(\"hi\")\n    execute(f\"help {key}\")\n\n"
  },
  {
    "name": "getchar",
    "text": "def getchar():\n    a = vim.funcs.getchar()\n    if not is_number(a):\n        return\n\n    a = chr(a)\n    if a == \"\\r\" or a == \"\\l\" or a == \"\\j\":\n        return\n    return to_argument(a)\n\n"
  },
  {
    "name": "create_iab",
    "text": "def create_iab(s=None):\n    if not s:\n        s = vim.funcs.getline(\".\")\n\n"
  },
  {
    "name": "data_write",
    "text": "def data_write(data):\n    if not data:\n        print(\"no data\")\n        return\n\n    print(data[0]) if is_array(data) else data[data.keys()[0]]\n    name = request(\"name for data\", None)\n    ext = \"json\"\n    outpath = add_extension(npath(\"~/scratch/data\", name), ext)\n    vim_write_file(outpath, data)\n\n"
  },
  {
    "name": "set_var",
    "text": "def set_var(key, value):\n    if value == None:\n        return\n    execute(f\"let {key} = {json.dumps(value, ensure_ascii = True)}\")\n\n"
  },
  {
    "name": "get_var",
    "text": "def get_var(key):\n    try:\n        return to_argument(attempt(vim.eval, key))\n    except Exception as e:\n        return None\n\n"
  },
  {
    "name": "dict_getter",
    "text": "def dict_getter(base, *keys):\n    args = keys[0].split(\".\") if len(keys) == 1 else keys\n    try:\n        for arg in args:\n            base = base[arg]\n        return base\n    except Exception as e:\n        return\n\n"
  },
  {
    "name": "jspy",
    "text": "def jspy(key=None, source=None):\n    filetype = get_filetype(source)\n    try:\n        if not key:\n            return jspyref[filetype]\n        return dict_getter(jspyref[filetype], key)\n    except Exception as e:\n        return None\n\n"
  },
  {
    "name": "run_file",
    "text": "def run_file(\n    file=None, args=None, normalize_directory=False, use_buffer=False"
  },
  {
    "name": "otemp",
    "text": "def otemp(arg):\n    line = vim.funcs.getline(\".\")\n    dir = \"~/scratch/temp\"\n    name = prompt(\n        f\"current_line: {line}\\nchoose a name for otemp:\", require=1\n    )\n    name = snake_case(name)\n    name = add_extension(name, \"json\")\n    path = npath(dir, name)\n    write(path, json.dumps(arg, indent=2, ensure_ascii=True), open=1)\n\n"
  },
  {
    "name": "get_keymaps",
    "text": "def get_keymaps(mode=\"n\", buffer=0):\n    if buffer:\n        return vim.api.buf_get_keymap(0, mode)\n    else:\n        return vim.api.get_keymap(mode)\n\n"
  },
  {
    "name": "press_to_continue",
    "text": "def press_to_continue():\n    vim.funcs.input(\"\\npress anything to continue\\n\")\n\n"
  },
  {
    "name": "attempt",
    "text": "def attempt(fn, *args, fix=None, silent=1):\n    try:\n        return fn(*args)\n    except Exception as e:\n        if fix:\n            return fix(e, args)\n        if silent:\n            return\n        else:\n            return\n            print(\"Error:\", e)\n            print(\"\")\n            for i, arg in enumerate(args):\n                print(f\"arg {i + 1}:\", arg)\n\n            press_to_continue()\n\n"
  },
  {
    "name": "unmap",
    "text": "def unmap(lhs, buffer=0, mode=\"n\"):\n    prefix = mode + \"unmap\" if len(mode) == 1 else mode\n    buffer = \"buffer\" if buffer else None\n    cmd = join(flat(prefix, buffer, lhs))\n    attempt(execute, cmd)\n\n"
  },
  {
    "name": "noop",
    "text": "def noop(*args, **kwargs):\n    pass\n\n"
  },
  {
    "name": "get_var_keys",
    "text": "def get_var_keys(var):\n    a = get_var(var)\n    if is_object(a):\n        return list(a.keys())\n\n"
  },
  {
    "name": "see",
    "text": "def see(x):\n    return x\n\n"
  },
  {
    "name": "ec",
    "text": "def ec(*args):\n    def transform(arg):\n        return \"ec \" + json.dumps(arg, ensure_ascii=True, indent=2)\n\n    cmd = join(map(args, transform), \"\\n\")\n    execute(cmd)\n\n"
  },
  {
    "name": "chalk",
    "text": "def chalk(*args, fg=\"blue\", bg=None, bold=None, hi=None):\n    name = \"MyCustomColor\"\n    if hi:\n        name = hi\n    else:\n        execute(f\"highlight {name} ctermfg={fg} ctermbg={bg}\")\n    execute(f\"echohl {name}\")\n    ec(*args)\n    execute(\"echohl None\")\n\n"
  },
  {
    "name": "set",
    "text": "def set(cmd):\n    cmd = f\"set {cmd}\"\n    value = attempt(execute, cmd)\n    return value\n\n"
  },
  {
    "name": "curry",
    "text": "def curry(fn, **kwargs):\n    def wrapper(*args):\n        return fn(*args, **kwargs)\n\n    return wrapper\n\n"
  },
  {
    "name": "unsetup",
    "text": "def unsetup(reset=0, silent=1):\n    if not reset and get_var(\"g:unmapped\"):\n        if silent:\n            return\n        return gray(\"g:unmapped already exists ... early return\")\n    set_var(\"g:unmapped\", 1)\n\n    unmap(\"is\", mode=\"iuna\", buffer=1)\n    unmap(\"be\", mode=\"iuna\", buffer=1)\n    unmap(\"[%\")\n    unmap(\"]%\")  # for better scrolling\n    set(\"noshowcmd\")  # this stops ~@k\n    set(\"indentexpr=\")  # this stops weird auto indentation\n\n    inoreab(\"zb\", \"<><left>\")  # iab_eat esc operations\n    # toggle_debug() # toggles the debug line\n    # cursor(find_line_index(\"#marker\", count = 2, start = 1318))\n    # qe() # working\n\n    snippeteer_items = []\n    highlight_wrapper(snippeteer_items, \"blue\", \"snippeteer\")\n\n"
  },
  {
    "name": "get_file",
    "text": "def get_file(file=None):\n    return file if file else vim.funcs.expand(\"%:p\")\n\n"
  },
  {
    "name": "get_filetype",
    "text": "def get_filetype(file=None):\n    if file:\n        m = match(file, extended_filetype_re)\n        if m:\n            return extended_filetypes[m]\n        return env.filetype_aliases.get(get_extension(file))\n    else:\n        return vim.eval(\"&filetype\")\n\n"
  },
  {
    "name": "get_line",
    "text": "def get_line(n=\".\"):\n    if n == None:\n        n = \".\"\n    return vim.funcs.getline(get_lnum(n))\n\n"
  },
  {
    "name": "vt",
    "text": "def vt(s):\n    ref = {\n        \"line\": get_line,\n        \"filetype\": get_filetype,\n        \"file\": get_file,\n    }\n\n    def replacer(x):\n        key = x.group(1)\n        return str(ref[key]())\n\n    return sub(s, \"\\$(\\w+)\", replacer)\n\n"
  },
  {
    "name": "shunt_to_references",
    "text": "def shunt_to_references():\n    append(g.files.text_references, vt(\"$filetype $line\"))\n    vim.api.del_current_line()\n\n"
  },
  {
    "name": "parse_candidate_file",
    "text": "def parse_candidate_file(s):\n    s = resolve_path(s)\n    if is_file(s):\n        return s\n\n"
  },
  {
    "name": "get_dir",
    "text": "def get_dir(dir=None):\n    return expand(dir) if dir else vim.funcs.expand(\"%:h\")\n\n"
  },
  {
    "name": "resolve_path",
    "text": "def resolve_path(path):\n    if not path:\n        return\n    s = \"\"\"\n        given a path like \"./abc.js\"\n        it should resolve to the directory of the current file\n        ~/2023/abc.js would be wrong\n        because we might not be in the ~/2023 directory\n    \"\"\"\n\n    cwd = get_dir()\n\n    def resolver(x):\n        nonlocal cwd\n        count = len(x.group(0).split(\"/\"))\n        for i in range(count):\n            cwd = head(cwd)\n        return cwd + \"/\"\n\n    if test(path, \"^~/\"):\n        return expand(path)\n    if test(path, \"^\\./[\\w.-_]\"):\n        return os.path.join(cwd, path[2:])\n    if test(path, \"^\\.?[a-z][\\w.-_]+$\", flags=re.I):\n        return os.path.join(cwd, path)\n    if test(path, \"^/\"):\n        return path\n    if test(path, \"^\\.\\./\"):\n        return sub(path, \"^(?:\\.\\./)+\", resolver, count=1)\n\n    # unreachable(f\"what path could this be? it is not handled: {path}\")\n\n"
  },
  {
    "name": "comment",
    "text": "def comment(s, filetype=\"python\"):\n    if is_string(s):\n        s = smart_dedent(s)\n    else:\n        s = dump_json(s)\n    lines = split(s, \"\\n\")\n    prefix = jspy(filetype, \"comment\")\n    callback = lambda line: prefix + (\" \" + line if len(line) else \"\")\n    return join(map(lines, callback), \"\\n\")\n\n"
  },
  {
    "name": "get_col",
    "text": "def get_col():\n    return vim.funcs.col(\".\")\n\n"
  },
  {
    "name": "filelog_matcher",
    "text": "def filelog_matcher(s):\n    name = get_filetype()\n    # if name ==\n\n"
  },
  {
    "name": "get_buffer_names",
    "text": "def get_buffer_names():\n    \"\"\"Retrieve the names of all open buffers in Vim.\"\"\"\n    buffer_names = [\n        vim.buffers[i + 1].name for i in range(len(vim.buffers) - 1)\n    ]\n    return buffer_names\n\n"
  },
  {
    "name": "is_filetree",
    "text": "def is_filetree(file):\n    return get_filetype(file) == \"filetree\"\n\n"
  },
  {
    "name": "goto_open_filetree_buffer",
    "text": "def goto_open_filetree_buffer():\n    return open_buffer(find(get_buffer_names(), is_filetree))\n\n"
  },
  {
    "name": "unreachable",
    "text": "def unreachable(message=\"\"):\n    raise Exception(message)\n\n"
  },
  {
    "name": "process_text",
    "text": "def process_text(s, matchers, default_callback):\n    for matcher in matchers:\n        callback = (\n            matcher[\"callback\"]\n            if \"callback\" in matcher\n            else default_callback\n        )\n        if \"regex\" in matcher:\n            m = match(s, matcher[\"regex\"])\n            if m:\n                return callback(*to_array(m))\n        else:\n            m = callback(s)\n            if m:\n                return m\n\n"
  },
  {
    "name": "get_file_from_line",
    "text": "def get_file_from_line(s):\n    return process_text(s, file_line_matchers, resolve_path)\n\n"
  },
  {
    "name": "sort_buffers",
    "text": "def sort_buffers():\n    buffers = get_buffer_info()\n    buffers = sort(buffers, lambda buffer: buffer[\"lastused\"])\n    return buffers\n\n"
  },
  {
    "name": "close_hidden_buffers",
    "text": "def close_hidden_buffers():\n    buffers = filter(get_buffer_info(), lambda x: x[\"h\"])\n    # vim\n\n"
  },
  {
    "name": "create_file_group",
    "text": "def create_file_group():\n    buffers = select_multiple(\n        sort_buffers(), display=lambda x: x[\"name\"]\n    )\n\n"
  },
  {
    "name": "get_lnum",
    "text": "def get_lnum(n=\".\"):\n    if is_number(n):\n        return n\n    return vim.funcs.line(n)\n\n"
  },
  {
    "name": "get_lines",
    "text": "def get_lines(x):\n    a, b = get_line_indexes(x) if is_string(x) else x\n    return vim.funcs.getline(a, b)\n    return vim.api.buf_get_lines(0, a - 1, b, False)\n\n"
  },
  {
    "name": "set_lines",
    "text": "def set_lines(indexes, payload):\n    if is_array(indexes):\n        a, b = indexes\n        a = a - 1\n    else:\n        lnum = get_lnum(indexes)\n        a = lnum - 1\n        b = lnum\n    vim.api.buf_set_lines(0, a, b, False, to_lines(payload))\n\n"
  },
  {
    "name": "to_lines",
    "text": "def to_lines(s):\n    return s if is_array(s) else s.split(\"\\n\")\n\n"
  },
  {
    "name": "get_set_lines",
    "text": "def get_set_lines(indexes, x):\n    prev = get_lines(indexes)\n    if is_function(x):\n        payload = map(prev, x)\n    else:\n        payload = to_lines(x)\n    set_lines(indexes, payload)\n\n"
  },
  {
    "name": "getter",
    "text": "def getter(key):\n    up, down = ref[key]\n\n"
  },
  {
    "name": "get_indent",
    "text": "def get_indent(s):\n    ind = len(match(s, \"^ *\"))\n    assert ind % 4 == 0\n    return int(ind / 4)\n\n"
  },
  {
    "name": "get_linecount",
    "text": "def get_linecount():\n    return vim.api.buf_line_count(0)\n\n"
  },
  {
    "name": "xfli",
    "text": "def xfli(up, down, limit=100):\n    max_line = get_linecount()\n    start = get_lnum()\n    a = start - 1\n\n    c = 0\n    state = LineState(a)\n    while c < limit:\n        if a == 0:\n            break\n        if up(state):\n            break\n        a -= 1\n\n    c = 0\n    state = LineState(b)\n    while c < limit:\n        if b == max_line:\n            break\n        if down(state):\n            break\n        b += 1\n    return a, b\n\n"
  },
  {
    "name": "testf",
    "text": "def testf(x, flags=0, anti=0, key=0):\n    if is_function(x):\n        return x\n    if is_array(x):\n        regex = \"|\".join(x)\n        fn = lambda s: test(s, regex, flags=flags)\n    elif is_string(x):\n        fn = lambda s: test(s, x, flags=flags)\n\n    if anti and key:\n        return lambda x: not fn(x[key])\n    elif anti:\n        return lambda x: not fn(x)\n    elif key:\n        return lambda x: fn(x[key])\n    else:\n        return fn\n\n"
  },
  {
    "name": "find_line_index",
    "text": "def find_line_index(\n    query=None,\n    start=\".\",\n    dir=1,\n    backtrack=None,\n    limit=300,\n    anti=False,\n    must_pass_start=False,\n    skip_newlines=False,\n    strict=False,\n    move_to_last_match=0,\n    source=None,\n    count=0,\n    offset=0,"
  },
  {
    "name": "copy_file_to_dir",
    "text": "def copy_file_to_dir(file, dir):\n    dest = npath(dir, file)\n    shutil.copy(file, dest)\n    print(f\"copied {tail(file)} to {dest}\")\n\n"
  },
  {
    "name": "do_local_file_backup",
    "text": "def do_local_file_backup():\n    return copy_file_to_dir(get_file(), g.dirs.local_backup)\n\n"
  },
  {
    "name": "do_drive_file_backup",
    "text": "def do_drive_file_backup():\n    return copy_file_to_dir(get_file(), g.dirs.drive_backup)\n\n"
  },
  {
    "name": "early_exit",
    "text": "def early_exit(file, payload):\n    if DEBUG or CONFIRM:\n        print(\"file:\", file)\n        print(\"payload:\", payload)\n        if DEBUG:\n            return True\n        else:\n            prompt(\"press anything to continue\")\n            return False\n\n"
  },
  {
    "name": "vim_append_file",
    "text": "def vim_append_file(file, payload):\n    if not payload:\n        return\n    if early_exit(file, payload):\n        return\n\n    file = expand(file)\n    append(file, payload)\n    set_var(\"g:last_touched_file\", file)\n    return file\n\n"
  },
  {
    "name": "open_last_touched_file",
    "text": "def open_last_touched_file():\n    file = get_var(\"g:last_touched_file\")\n    open_buffer(file)\n\n"
  },
  {
    "name": "get_indent_and_text",
    "text": "def get_indent_and_text(s):\n    return (get_indent(s), s.lstrip())\n\n"
  },
  {
    "name": "calculate_indent",
    "text": "def calculate_indent(index, mode):\n    ind, text = get_indent_and_text(get_line(index))\n    if mode == \"above\":\n        if test(text, \"[\\}\\]]$\"):\n            return ind + 1\n        else:\n            return ind\n    elif mode == \"below\":\n        if test(text, \"[\\[\\{]$\"):\n            return ind + 1\n        else:\n            return ind\n\n"
  },
  {
    "name": "prepend_block",
    "text": "def prepend_block(i, payload):\n    ind = calculate_indent(i, \"above\")\n    payload = indent(to_array(payload), ind)\n    vim.funcs.append(i - 1, payload)\n\n"
  },
  {
    "name": "indent",
    "text": "def indent(x, indentation=1):\n    def runner(x):\n        return sub(x, \"^\", \" \" * indentation * 4, flags=re.M)\n\n    return map(x, runner) if is_array(x) else runner(x)\n\n"
  },
  {
    "name": "auto_indent",
    "text": "def auto_indent(i, payload):\n    payload = to_lines(payload)\n    ind = calculate_indent(i, \"below\")\n    payload = indent(payload, ind)\n    return payload\n\n"
  },
  {
    "name": "set_block",
    "text": "def set_block(i, payload):\n    payload = auto_indent(i, payload)\n    set_lines(i, payload)\n\n"
  },
  {
    "name": "append_block",
    "text": "def append_block(i, payload):\n    payload = auto_indent(i, payload)\n    vim.funcs.append(i, payload)\n\n"
  },
  {
    "name": "get_capture",
    "text": "def get_capture(x):\n    if not x:\n        return \"\"\n\n    groups = x.groups()\n    if groups:\n        return smallify(groups)\n    return x.group(0)\n\n"
  },
  {
    "name": "replacef",
    "text": "def replacef(fn):\n    def wrapper(x):\n        return fn(get_capture(x))\n\n    return wrapper\n\n"
  },
  {
    "name": "smallify",
    "text": "def smallify(x):\n    return x[0] if len(x) == 1 else x\n\n"
  },
  {
    "name": "toggle_debug",
    "text": "def toggle_debug():\n    r = \"(?<=^DEBUG = )(\\w+)\"\n    i = find_line_index(\n        r, start=1, dir=1, limit=10, move_to_last_match=1\n    )\n    payload = sub(\n        get_line(i), r, lambda x: str(opposite(get_capture(x)))\n    )\n    append_block(i, payload)\n\n"
  },
  {
    "name": "vim_write_file",
    "text": "def vim_write_file(file, data, open=1):\n    file = expand(file)\n    if not data:\n        return\n    if early_exit(file, data):\n        return\n\n    write(file, data, mkdir=True)\n\n    if open:\n        time.sleep(0.5)\n        open_buffer(file)\n\n    set_var(\"g:last_touched_file\", file)\n    return file\n\n"
  },
  {
    "name": "create_project_from_template",
    "text": "def create_project_from_template(key):\n    pass\n    # ref simple-vue\n\n"
  },
  {
    "name": "keyboard_movement",
    "text": "def keyboard_movement():\n    pass\n\n"
  },
  {
    "name": "inoreab",
    "text": "def inoreab(a, b):\n    generate_vim_command(a, b, mode=\"inoreab\")\n\n"
  },
  {
    "name": "opposite",
    "text": "def opposite(x):\n    return opposites[str(x)]\n\n"
  },
  {
    "name": "join_spaces",
    "text": "def join_spaces(args):\n    return join(args, \" \")\n\n"
  },
  {
    "name": "execute",
    "text": "def execute(*args):\n    vim.command(join_spaces(args))\n\n"
  },
  {
    "name": "is_even",
    "text": "def is_even(n):\n    return n % 2 == 0\n\n"
  },
  {
    "name": "is_odd",
    "text": "def is_odd(n):\n    return n % 2 == 1\n\n"
  },
  {
    "name": "convert_python_regex",
    "text": "def convert_python_regex(regex):\n    count = 0\n\n    def replacer(x):\n        nonlocal count\n        count += 1\n        if is_even(count):\n            return \">\"\n        else:\n            return \"<\"\n\n    regex = sub(regex, \"\\\\\\\\b\", replacer)\n    regex = regex.replace(\"(?:\", \"%(\")\n    regex = regex.replace(\".*?\", \".{-}\")\n    regex = regex.replace(\"=\", \"\\\\=\")\n    regex = f\"\\\\v{regex}\"\n    return regex\n\n"
  },
  {
    "name": "highlight",
    "text": "def highlight(name, regex, fg=None, bg=None):\n    foreground = f\"ctermfg = {fg}\" if fg else None\n    background = f\"ctermbg = {bg}\" if bg else None\n    color_definition_cmd = join(\n        flat(\"highlight\", name, foreground, background)\n    )\n    regex = convert_python_regex(regex)\n\n    execute(color_definition_cmd)\n    vim.funcs.matchadd(name, regex)\n\n"
  },
  {
    "name": "ncg",
    "text": "def ncg(items):\n    return \"|\".join(map(items, re.escape))\n\n"
  },
  {
    "name": "rewrap",
    "text": "def rewrap(items, template=\"\\\\b(?:$1)\\\\b\"):\n    nested = is_nested_array(items)\n\n    def replacer(x):\n        if nested:\n            index = int(x.group(1)) - 1\n            return ncg(items[index])\n        else:\n            return ncg(items)\n\n    regex = \"\\$(\\d+)\"\n    return sub(template, regex, replacer)\n\n"
  },
  {
    "name": "highlight_wrapper",
    "text": "def highlight_wrapper(query, color=\"blue\", name=\"untitled\"):\n    if not query:\n        return\n    regex = rewrap(query) if is_array(query) else query\n    highlight(name, regex, color)\n\n"
  },
  {
    "name": "get_identifier_above",
    "text": "def get_identifier_above():\n    r = \"(\\w+) *=\"\n    i = find_line_index(r)\n    m = match(get_line(i), r)\n    return m\n\n"
  },
  {
    "name": "replace_word_between_word",
    "text": "def replace_word_between_word(confirm=0):\n    payload = prompt(f\"choose a partial replacement for {word}\")\n    word = get_word()\n    s = get_line()\n    c, left, right = get_word_boundaries(\"\\W\")\n    c, a, b = get_word_boundaries(\"[-\\W_]\")\n    left_part = s[left : a + 1]\n    right_part = s[b:right]\n    new_word = left_part + payload + right_part\n    execute_replace(word, new_word, confirm=confirm)\n\n"
  },
  {
    "name": "insert_word_between_word",
    "text": "def insert_word_between_word(confirm=0):\n    payload = prompt(\"choose a word to insert\")\n    s = get_line()\n    c, a, b = get_word_boundaries(\"\\W\")\n    before = s[a + 1 : c - 1]\n    after = s[c - 1 : b]\n    if test(before[-1], \"[_-]\"):\n        payload += before[-1]\n\n    elif test(after[0], \"[_-]\"):\n        payload = after[0] + payload\n\n    new_word = before + payload + after\n    execute_replace(get_word(), new_word, confirm=confirm)\n\n"
  },
  {
    "name": "get_word_boundaries",
    "text": "def get_word_boundaries(back_re, forward_re=None):\n    if not forward_re:\n        forward_re = back_re\n    s = get_line()\n    max = len(s)\n    count = 0\n    c = get_col()\n    a = c - 1\n    b = c\n    while True:\n        count += 1\n        # ($1)\n        # ($1)\n        # ($$1)\n        # ($1)\n        ch = s[a]\n        if test(ch, back_re):\n            if count == 1:\n                max = len(s)\n                if max - c >= c:\n                    a += 2\n                    b += 2\n                else:\n                    a -= 1\n                    b -= 1\n                continue\n            break\n        elif a == 0:\n            break\n        else:\n            a -= 1\n\n    while True:\n        ch = s[b]\n        if test(ch, forward_re):\n            break\n        else:\n            b += 1\n            if b == max:\n                break\n\n    return (c, a, b)\n\n"
  },
  {
    "name": "if_test_snippeteer_fallback",
    "text": "def if_test_snippeteer_fallback(args):\n    if len(args) == 0:\n        pass\n    if len(args) == 1:\n        arg = args[0]\n        if test(arg, asd):\n            pass\n        return\n\n"
  },
  {
    "name": "snippeteer",
    "text": "def snippeteer():\n    return vim.funcs.setline(\".\", \"aaaa\")\n    return TextState().append(\"howdy\", move=1)\n    s = get_line()\n    items = filter(split(s, \"\\s+\"))\n    key, args = split_once(items)\n    ref = snippeteer_ref[key]\n\n    template = ref[\"template\"]\n    nargs = ref[\"nargs\"]\n    fallback = ref[\"fallback\"]\n\n    if len(args) < nargs:\n        args.extend(to_array(fallback(args)))\n\n    snippet = templater(template, args)\n    set_lines(\".\", indent(snippet, get_indent(get_line())))\n    normal('/\\\\v\\\\$c/e\\<CR>\"_x\"_x\\<RIGHT>')\n    start_insert()\n\n"
  },
  {
    "name": "get_text_state",
    "text": "def get_text_state():\n    return TextState()\n\n"
  },
  {
    "name": "qw",
    "text": "def qw():\n    state = get_text_state()\n    insert = \"\\t\" * (state.ind + 1)\n    state.append(insert, move=1, startinsert=1)\n\n"
  },
  {
    "name": "normal",
    "text": "def normal(cmd, insert = 0):\n    execute(f\"normal! {cmd}\")\n    if insert:\n        execute(\"startinsert!\")\n"
  },
  {
    "name": "qe",
    "text": "def qe():\n    state = get_text_state()\n    start_ind = state.ind\n    if start_ind == 0:\n        return normal(\"o\")\n\n    def callback(line):\n        ind = get_indent(line)\n        if ind < start_ind:\n            return True\n\n    ind_index = find_line_index(\n        callback, dir=-1, skip_newlines=False, must_pass_start=False\n    )\n    ind = get_indent(get_line(ind_index))\n    prompt((ind_index, ind))\n    insert = \"\\t\" * ind\n    state.append(insert, move=1, startinsert=1)\n\n"
  },
  {
    "name": "cursor",
    "text": "def cursor(a, b=1000):\n    vim.funcs.cursor(a, b)\n\n"
  },
  {
    "name": "python_func_handler",
    "text": "def python_func_handler(name=None, *args):\n    if not name:\n        name = fzf(fruits)\n\n    return print(name)\n\n    name = \"chatgpt_vim_python_executor.\" + name\n    args = join(map(args, to_argument), \", \")\n    cmd = f\":python3 {name}({args})<cr>\"\n    execute(cmd)\n\n"
  },
  {
    "name": "fzf",
    "text": "def fzf(items=None, sink=\"\", dir=\"\"):\n    if dir:\n        # set_var(\"g:fzf_dir\", dir)\n        # chdir(dir)\n        ignore = [\n            \"fonts\",\n            \".git\",\n            \"node_modules\",\n            \"log\",\n            \"temp\",\n            \"package\",\n            \"dist\",\n        ]\n\n        ignore = rewrap(ignore, \"($1)\")\n        source = f\"find $(pwd) -regextype posix-extended -type f | grep -vE '{ignore}'\"\n        obj = {\"source\": source, \"dir\": expand(dir)}\n        obj = json.dumps(obj)\n        s = f\"call fzf#run(fzf#wrap({obj}))\"\n        return execute(s)\n    if sink:\n        # sink = f\"funcref('mod.{sink}')\"\n        sink = f\"{{x -> :python3 mod.{sink}(x)}}\"\n    else:\n        sink = \"'edit'\"\n    obj = {\n        \"source\": items,\n        \"sink\": \"<sink>\",\n    }\n    obj = json.dumps(obj)\n    obj = obj.replace('\"<sink>\"', sink)\n    s = f\"call fzf#run(fzf#wrap({obj}))\"\n    # return print(s)\n    execute(s)\n\n"
  },
  {
    "name": "get_comment_indexes",
    "text": "def get_comment_indexes(start):\n    d = jspy(\"comment\")\n    query = f\"^ *{d}\"\n    a = find_line_index(\n        start=start, dir=-1, query=query, anti=1, offset=1\n    )\n    b = find_line_index(\n        start=start, dir=1, query=query, anti=1, offset=1\n    )\n    return a, b\n\n"
  },
  {
    "name": "get_line_indexes",
    "text": "def get_line_indexes(key, start = \".\"):\n    ref = {\n        \"page\": (\"^\", \"$\"),\n        \"window\": (\"w^\", \"w$\"),\n    }\n\n    if key in ref:\n        return map(ref[key], vim.funcs.line)\n\n    if key == \"block\":\n        key = get_filetype()\n\n    presets = {\"comment\": get_comment_indexes}\n\n    if key in presets:\n        return presets[key](get_lnum())\n\n    ref = fli_options_ref[key]\n\n    up = ref[\"up\"]\n    down = ref[\"down\"]\n\n    start = get_lnum(start)\n    a = find_line_index(start=start - 1, dir=-1, **up)\n    b = find_line_index(start=start + 1, dir=1, **down)\n    return (a, b)\n\n"
  },
  {
    "name": "execute_replace",
    "text": "def execute_replace(\n    regex,\n    replacement,\n    flags=\"g\",\n    sensitive=0,\n    boundary=1,\n    range=\"%\",\n    confirm=0,"
  },
  {
    "name": "update_json",
    "text": "def update_json(f, **kwargs):\n    def callback(data):\n        if not kwargs:\n            return\n        data.update(kwargs)\n        return data\n\n    read_write(f, callback)\n\n"
  },
  {
    "name": "create_new_project",
    "text": "def create_new_project(name, ref=None, git=False):\n    dir = \"~/projects\"\n    path = npath(dir, name)\n\n    if not ref:\n        # ref = \"/home/kdog3682/projects/starterkit\"\n        ref = \"/home/kdog3682/@bkl/apps/examples/ViteHelloWorld\"\n\n    if is_dir(path):\n        return go_directory_tree(path)\n    cp(ref, path)\n    assert is_dir(path)\n\n    package_json_file = npath(path, \"package.json\")\n    if os.path.exists(package_json_file):\n        update_json(package_json_file, name=name)\n\n    if git and is_dir(path):\n        from GithubController import initialize_local_directory\n\n        initialize_local_directory(path)\n\n    # action_log(type=\"project\", name=name)\n    go_directory_tree(path)\n\n"
  },
  {
    "name": "get_gitdir_from_path",
    "text": "def get_gitdir_from_path(x):\n    dir = head(x) if get_extension(x) else x\n    c = 0\n    while True:\n        c += 1\n        if c == 10:\n            return None\n        if dir == \"/home/kdog3682\":\n            return None\n        if is_dir(npath(dir, \".git\")):\n            return dir\n        dir = head(dir)\n\n"
  },
  {
    "name": "go_directory_tree",
    "text": "def go_directory_tree(path=None):\n    dir_path = get_gitdir_from_path(get_dir(path))\n    if not dir_path:\n        dir_path = path\n\n    outpath = f\"~/scratch/data/filetrees/{tail(path)}.tree.txt\"\n    directory_tree = print_directory_tree(dir_path)\n    vim_write_file(outpath, directory_tree)\n\n"
  },
  {
    "name": "extend",
    "text": "def extend(a, b):\n    if is_object(a):\n        a.update(b)\n    else:\n        a.extend(b)\n    return a\n\n"
  },
  {
    "name": "some",
    "text": "def some(items, fn):\n    for item in items:\n        if fn(item):\n            return True\n\n"
  },
  {
    "name": "action_log",
    "text": "def action_log(**kwargs):\n    base = {\n        \"date\": iso8601(),\n    }\n    data = extend(kwargs, base)\n\n    def callback(prev):\n        return [data]\n        prompt(type(prev))\n        if some(prev, lambda x: x[\"name\"] == data[\"name\"]):\n            if not confirm(\n                f\"g.files.action_log already contains an item with name {name}\"\n            ):\n                prev.append(data)\n            else:\n                return\n        else:\n            prev.append(data)\n        return prev\n\n    read_write(g.files.action_log, callback)\n\n"
  },
  {
    "name": "append",
    "text": "def append(file, content):\n    if not content:\n        return\n    file = expand(file)\n    if is_string(content):\n        with open(file, \"a\") as f:\n            f.write(\"\\n\" + content)\n            print(\"appended\", file)\n    else:\n        append_json(file, content)\n\n    set_var(\"g:last_touched_file\", file)\n\n"
  },
  {
    "name": "register_path",
    "text": "def register_path(name, value, mode):\n    if not test(value, \"/\"):\n        value = npath(\"~/scratch/data\", value)\n    else:\n        value = expand(value)\n    vim_append_file(f\"~/PYTHON/g/{mode}.py\", f'{name} = \"{value}\"')\n\n"
  },
  {
    "name": "register_file",
    "text": "def register_file(value, desc=None):\n    desc = desc or prompt(f\"write a description for {value}\")\n    name = remove_extension(value)\n    return register_path(name, value, \"files\")\n\n"
  },
  {
    "name": "register_dir",
    "text": "def register_dir(name, value):\n    return register_path(name, value, \"dirs\")\n\n"
  },
  {
    "name": "unregister_file",
    "text": "def unregister_file(name):\n    file = os.path.join(g.dirs.python, \"g/files.py\")\n    touched = False\n\n    def checkpoint(s):\n        nonlocal touched\n        regex = f'^{name} = \"(.+?)\"'\n        m = match(s, regex)\n        if m:\n            touched = True\n            if is_file(m[1]):\n                rm(m[1])\n            return False\n        return True\n\n    def callback(s):\n        s = filter(line_getter(s), checkpoint)\n        if touched:\n            return join(s)\n\n    read_write(file, callback)\n\n"
  },
  {
    "name": "start_insert",
    "text": "def start_insert():\n    execute(\"startinsert!\")\n\n"
  },
  {
    "name": "keyboard",
    "text": "def keyboard(s):\n    normal(templater(s, keyboard_dict))\n    start_insert()\n\n"
  },
  {
    "name": "get_function_from_line",
    "text": "def get_function_from_line(s):\n    def create_regex(s):\n        return f\"(?:^|[ ,\\(\\[\\]])({word})\\\\(\"\n\n    word = get_word()\n\n    regex = create_regex(word)\n    if test(s, regex):\n        return word\n    return select(findall(s, create_regex(\"[a-z][\\w-]+\"), flags=re.I))\n\n"
  },
  {
    "name": "execute_regex",
    "text": "def execute_regex(r, backwards=0, from_end=0):\n    s = \"silent! \"\n    s += \"?\" if backwards else \"/\"\n    s += \"\\\\v\"\n    s += r\n    s += \"e\" if from_end else \"\"\n    execute(s)\n\n"
  },
  {
    "name": "open_function",
    "text": "def open_function(name):\n    regex = f\"^def {name}\"\n    success = execute_regex(regex)\n    if success:\n        return\n    # return fnlib[filetype][name]\n\n"
  },
  {
    "name": "go_function_from_line",
    "text": "def go_function_from_line():\n    name = get_function_from_line(get_line())\n    return open_function(name)\n\n"
  },
  {
    "name": "register_hot_file",
    "text": "def register_hot_file(file=None):\n    append(g.files.hot, get_file(file))\n\n"
  },
  {
    "name": "request",
    "text": "def request(message, fallback):\n    t = f\"request: {message}\\nfallback: {fallback}\\n\"\n    m = prompt(t)\n    if m == None:\n        m = fallback\n    a = to_argument(m)\n    return a\n\n"
  },
  {
    "name": "add_current_directory_to_fish",
    "text": "def add_current_directory_to_fish():\n    dir = get_dir()\n    name = request(\"dirname\", tail(dir))\n    s = f\"abbr cd{name} 'cd {dir}'\"\n    vim_append_file(g.files.fish, s)\n\n"
  },
  {
    "name": "get_visible_buffers",
    "text": "def get_visible_buffers():\n    buffers = get_buffer_info()\n    return filter(buffers, lambda x: x[\"hidden\"] == 0)\n\n"
  },
  {
    "name": "get_name",
    "text": "def get_name(x):\n    if is_object(x):\n        if \"name\" in x:\n            return x[\"name\"]\n        elif \"foo\" in x:\n            return x[\"foo\"]\n\n    raise Exception(\"todo\")\n\n"
  },
  {
    "name": "register_file_from_line",
    "text": "def register_file_from_line():\n    s = match(get_line(), \"g.files.(\\w+)\")\n    if not s:\n        return\n    buffers = get_visible_buffers()\n    names = map(buffers, get_name)\n    file = select(names)\n    print(file)\n\n"
  },
  {
    "name": "has_newline",
    "text": "def has_newline(s):\n    return test(s, \"\\n\")\n\n"
  },
  {
    "name": "bigjoin",
    "text": "def bigjoin(*args):\n    s = \"\"\n\n    def runner(input):\n        s = \"\"\n        args = flat(input)\n        for arg in args:\n            s += arg\n            if has_newline(arg):\n                s += \"\\n\\n\"\n            else:\n                s += \"\\n\"\n        return trim(s)\n\n    for arg in args:\n        s += runner(arg)\n        s += \"\\n\\n\"\n    return trim(s)\n\n"
  },
  {
    "name": "reduce",
    "text": "def reduce(items, fn):\n    store = {}\n\n    if is_object(items):\n        items = items.items()\n\n    for item in list(items):\n        value = fn(item)\n        if value:\n            if is_array(value) and len(value) == 2:\n                store[value[0]] = value[1]\n            else:\n                store[item] = value\n    return store\n\n"
  },
  {
    "name": "mm",
    "text": "def mm(s):\n    def callback(s):\n        name = match(s, \"^function (\\w+)\")\n        return name, s\n\n    r = \"^function [\\w\\W]+?\\nend\"\n    items = findall(s, r, flags=re.M)\n    store = reduce(items, callback)\n\n    functions = list(store.values())\n    keys = sort(list(store.keys()))\n\n    a = \"local M = {}\"\n    b = \"return M\"\n    exports = map(keys, lambda x: f\"M.{x} = {x}\")\n    return bigjoin(functions, a, exports, b)\n\n"
  },
  {
    "name": "foo",
    "text": "def foo(content):\n    s = \"\"\"\n        from chatgpt_vim_python_executor import *\n        def foo():\n            a = get_var(\"g:python_arg\")\n            print(a)\n            return a\n    \"\"\"\n    content = smart_dedent(s) + \"\\n\\n\" + smart_dedent(content)\n    key = match(s, \"def (\\w+)\")\n\n    path = \"~/PYTHON/test.py\"\n    path = increment_path(path)\n    num = findall(path, \"\\d+\")[-1]\n\n    cmd = smart_dedent(\n        f\"\"\"\n        function! PyTest{num}(arg = \"\")\n        let g:python_arg = arg\n        python3 << EOF\n\n        import test{num}\n        test{key}()\n        EOF\n\n        endfunction\n        let g:execRef[\"pt{num}\"]=\"PyTest{num}\"\n    \"\"\"\n    )\n\n    print(path, num, content, cmd)\n    return\n    # write(path, content)\n    # execute(cmd)\n\n"
  },
  {
    "name": "create_fish_executable",
    "text": "def create_fish_executable():\n    file = get_most_recent_file(dldir)\n    name = request(\n        \"name for the binary\", tail(remove_extension(file))\n    )\n    s = f\"abbr {name} '{file}'\"\n    print(s)\n    vim_append_file(\"/home/kdog3682/.config/fish/config.fish\", s)\n\n"
  },
  {
    "name": "foo",
    "text": "def foo(s):\n    # has to be done in insert mode\n    return \"aaa\"\n\n"
  },
  {
    "name": "register_hot_file",
    "text": "def register_hot_file():\n    vim_append_file(g.files.hot, get_file())\n\n"
  },
  {
    "name": "exec_lua",
    "text": "def exec_lua(s):\n    vim.exec_lua(smart_dedent(s))\n\n"
  },
  {
    "name": "register_hot_fuction",
    "text": "def register_hot_fuction():\n    lines = get_lines(\"block\")\n    name = get_function_name(lines[0])\n    vim_append_file(\"~/scratch/data/lua_functions.txt\", name)\n    s = bigjoin(\n        \"function {name}\", \"python3 << EOF\", lines, \"EOF\", \"end\"\n    )\n    vim.exec_lua(s)\n\n"
  },
  {
    "name": "toggle_comments",
    "text": "def toggle_comments(s, start_of_line=True, on=False, off=False):\n    a, b = jspy(\"comment\")\n    spaces = \"\" if start_of_line else \" *\"\n    space_re = \"\" if start_of_line else \" *\"\n    if test(s, f\"^{spaces}{a}\"):\n        if on:\n            return s\n        s = sub(s, f\"^{space_re}{a} *\", \"\")\n        if b:\n            s = sub(s, f\" *{b} *$\", \"\")\n        return s\n    else:\n        if off:\n            return s\n        if b:\n            b = \" \" + b\n        return a + \" \" + s + b\n\n"
  },
  {
    "name": "get_set_line",
    "text": "def get_set_line(index, fn):\n    ind, b = get_indent_and_text(get_line(index))\n    value = fn(b)\n    payload = indent(value, ind)\n    set_lines(index, payload)\n\n"
  },
  {
    "name": "toggle_line_comments",
    "text": "def toggle_line_comments():\n    get_set_line(\".\", toggle_comments)\n\n"
  },
  {
    "name": "toggle_block_comments",
    "text": "def toggle_block_comments():\n    if is_commented(trim(get_line())):\n        indexes = get_line_indexes(\"comment\")\n    else:\n        indexes = get_line_indexes(\"block\")\n    # return\n    get_set_lines(indexes, toggle_comments)\n\n"
  },
  {
    "name": "snip_fetch_example",
    "text": "def snip_fetch_example(s):\n    files = absdir(\"~/scratch/data\")\n    file = find(files, query)\n\n"
  },
  {
    "name": "scratch_write_vim_mappings",
    "text": "def scratch_write_vim_mappings(mode=\"n\"):\n    \"\"\"\n    we extract out function calls from the mappings\n\n    input:\n        nnoremap <silent> <buffer> qu :call NormalQU()<CR>\n    output:\n        (qu, NormalQU)\n    \"\"\"\n    data = get_keymaps(mode)\n\n    def callback(item):\n        if \"rhs\" not in item:\n            return\n\n        lhs = item[\"lhs\"].lower()\n        rhs = item[\"rhs\"]\n        func = match(rhs, \"(\\w+)\\(\")\n        if func:\n            return (lhs, func)\n\n    # name = \"\"\n    data_write(filter(map(data, callback)))\n\n"
  },
  {
    "name": "scratch_see_wpsnippets",
    "text": "def scratch_see_wpsnippets(lang=\"vim\"):\n    \"\"\"\n    this would b much better done via a web browser\n    \"\"\"\n    a = lang\n    b = (\n        ext_lang_map[lang]\n        if lang in ext_lang_map\n        else reverse(ext_lang_map)[lang]\n    )\n    g = get_var(\"g:\")\n    a = dict_getter(g, \"wpsnippets\", a)\n    b = dict_getter(g, \"wpsnippets\", b)\n    c = dict_getter(g, \"wpsnippets2\", a)\n    d = dict_getter(g, \"wpsnippets2\", b)\n\n    e = merge(a, b, c, d)\n    s = \"\"\n    for a, b in e.items():\n        if not b:\n            continue\n        s += a\n        s += \":\"\n        s += \"\\n\"\n        s += b\n        s += \"\\n-------------\\n\"\n\n    clip(s)\n\n"
  },
  {
    "name": "lines",
    "text": "def lines(s, start=0):\n    data = None\n    if is_array(s):\n        data = s\n    elif is_string(s):\n        if is_file(s):\n            s = read(s)\n        data = s.split(\"\\n\")\n\n    if start:\n        if is_string(start):\n            start = find_index(data, start)\n            return data[start:]\n        return data[start - 1 :]\n    return data\n\n"
  },
  {
    "name": "find_index",
    "text": "def find_index(iterable, fn):\n    fn = testf(fn)\n\n    for i, item in enumerate(list(iterable)):\n        if fn(item):\n            return i\n\n"
  },
  {
    "name": "joinlines",
    "text": "def joinlines(s):\n    return join(s, \"\\n\")\n\n"
  },
  {
    "name": "callback",
    "text": "def callback(s):\n    if test(s, \"--\"):\n        m = match(s, \"(\\w+) equivalent\")\n        s = sub(s, \"^--.+\", \"\", count=1)\n        s = sub(s, \"--.+\", \"$c\", count=1)\n        if not m:\n            m = abrev(match(s, \"[a-z]+_[a-z]+\"))\n        else:\n            m = match(s, \"(?:if|while) (\\w+)\")\n            m = abrev(m)\n\n        return (name, trim(s), needs_fix)\n\n"
  },
  {
    "name": "get_extension_from_content",
    "text": "def get_extension_from_content(s):\n    if is_primitive(s):\n        return \"txt\"\n    return \"json\"\n\n"
  },
  {
    "name": "temp_write",
    "text": "def temp_write(name, content, open=0):\n    vim_write_file(\n        get_scratch_path(name, content), content, open=open\n    )\n\n"
  },
  {
    "name": "get_scratch_path",
    "text": "def get_scratch_path(name, content):\n    ext = get_extension_from_content(content)\n    path = npath(\"~/scratch/temp\", add_extension(name, ext))\n    return path\n\n"
  },
  {
    "name": "preview",
    "text": "def preview(content=None):\n    if not content:\n        content = bigjoin(get_lines(\"block\"))\n    path = get_scratch_path(\"temp\", content)\n    write(path, content, open=1)\n\n"
  },
  {
    "name": "run_file",
    "text": "def run_file(file, *args):\n    filetype = get_filetype(file)\n    ref = executors[filetype]\n    special_files = ref[\"files\"]\n    executor = ref[\"executor\"]\n    if special_files and file in special_files:\n        executor[file]\n\n    shell = jspy(filetype, \"shell\")\n\n    if not test(file, \"/\"):\n        dir = jspy(filetype, \"base_directory\")\n        file = npath(dir, file)\n\n    cmd = join(flat(shell, file, *map(flat(args), shellescape)))\n    return attempt(execute, cmd)\n\n"
  },
  {
    "name": "ensure_file",
    "text": "def ensure_file(fn):\n    def wrapper(file=None, *args, **kwargs):\n        return fn(get_file(file), *args, **kwargs)\n\n    return wrapper\n\n"
  },
  {
    "name": "remove_file_from_listing",
    "text": "def remove_file_from_listing(file):\n    print(file)\n    # a bookmarking systemO\n\n"
  },
  {
    "name": "add_file_to_listing",
    "text": "def add_file_to_listing(file):\n    print(file)\n\n\n\n\n"
  },
  {
    "name": "get_word_under_cursor",
    "text": "def get_word_under_cursor():\n    s = get_line()\n    word_boundary = jspy(\"word_boundary\")\n    c, a, b = get_word_boundaries(word_boundary)\n    word = s[a:b]\n    return word\n\n"
  },
  {
    "name": "search",
    "text": "def search(regex, flags=\"wn\"):\n    return vim.funcs.search(convert_python_regex(regex), flags)\n\n"
  },
  {
    "name": "mget",
    "text": "def mget(s, regex, replacement=\"\", flags=0):\n    store = []\n\n    m = \"\"\n\n    def parser(x):\n        nonlocal m\n        m = get_match(x)\n        return fparse(replacement, x)\n\n    a = sub(s, regex, replacement, flags)\n    return a, m\n\n"
  },
  {
    "name": "is_typst_word",
    "text": "def is_typst_word(s):\n    return False\n\n"
  },
  {
    "name": "is_javascript_word",
    "text": "def is_javascript_word(s):\n    return False\n\n"
  },
  {
    "name": "format_argument",
    "text": "def format_argument(payload):\n    \"\"\"\n    the new version of to_string_argument\n    possibly change the name\n\n    \"\"\"\n    s = ArgumentFormatter(get_filetype())\n    return s.parse(payload)\n\n"
  },
  {
    "name": "create_var",
    "text": "def create_var(a):\n    prefix = jspy(\"var\")\n    if prefix:\n        prefix += \" \"\n    before = f\"{prefix}{a} = \"\n    return before\n\n"
  },
  {
    "name": "create_variable",
    "text": "def create_variable(a, b):\n    return f\"{create_var(a)}{format_argument(b)}\"\n\n"
  },
  {
    "name": "outbound_chatgpt",
    "text": "def outbound_chatgpt():\n    s = read(\"/home/kdog3682/scratch/temp/chatgpt.inbound.txt\")\n    t = \"\"\"\n        please add the following additional fields to each item:\n        \"None undefined empty_quotes true false\"\n    \"\"\"\n    preview(s + t)\n\n"
  },
  {
    "name": "inbound_chatgpt",
    "text": "def inbound_chatgpt():\n    return read(\"/home/kdog3682/scratch/temp/chatgpt.inbound.txt\")\n\n"
  },
  {
    "name": "map",
    "text": "def map(items, fn):\n    store = []\n    items = entries(items)\n    normal = not is_nested_array(items) and count_parameters(fn) != 2\n    gn = fn if normal else lambda x: fn(*x)\n    for item in items:\n        store.append(gn(item))\n    return store\n\n"
  },
  {
    "name": "deep_equal",
    "text": "def deep_equal(a, b):\n    if a is b:\n        return True\n\n    if type(a) != type(b):\n        return False\n    if is_primitive(a) and is_primitive(b):\n        return a == b\n\n    if len(a) != len(b):\n        return False\n\n    if is_object(a):\n        for key in a:\n            if key not in b or not deep_equal(a[key], b[key]):\n                return False\n    else:  # Assuming 'a' is a collection that supports iteration by index\n        for i in range(len(a)):\n            if not deep_equal(a[i], b[i]):\n                return False\n\n    return True\n\n"
  },
  {
    "name": "create_tests",
    "text": "def create_tests(fn, x, production=0):\n    filetype = get_filetype()\n    name = get_function_name(fn)\n    create = False\n    if is_string(x):\n        r = \"(^[a-z]+ [a-z]+.+)\"\n        items = split(x, r, flags=re.M)\n        create = True\n\n    def fix(e, args):\n        return str(e)\n\n    if create:\n\n        def callback(desc, input):\n            desc = trim(desc)\n            input = to_argument(trim(input))\n            output = attempt(fn, input, fix=fix)\n            return {\n                \"input\": input,\n                \"input_type\": type(input).__name__,\n                \"output\": output,\n                \"desc\": desc,\n            }\n\n        data = map(partition(items), callback)\n        if production:\n            path = xpath(\n                f\"~/scratch/snapshots/{filetype}\", name, \"json\"\n            )\n            merge_json(path, data)\n            return data\n        else:\n            pprint(data)\n    else:\n\n        def callback(item):\n            input = item[\"input\"]\n            output = attempt(fn, input, fix=fix)\n            return {\n                \"input\": input,\n                \"output\": output,\n                \"expected\": item[\"output\"],\n                \"desc\": item[\"desc\"],\n                \"matches\": deep_equal(output, item[\"output\"]),\n            }\n\n        results = map(x, callback)\n        success = every(results, lambda x: x[\"matches\"] == True)\n        return {\n            \"results\": results,\n            \"success\": success,\n        }\n\n"
  },
  {
    "name": "get_variable_declarators",
    "text": "def get_variable_declarators():\n    r = \"^ *\" + create_var(\"(\\w+)\")\n    i = find_line_index(r, limit=5, dir=-1)\n    if i == None:\n        return\n    store = []\n    push(store, match(get_line(i), r))\n    while True:\n        i -= 1\n        m = match(r, get_line(i))\n        if m:\n            push(store, m)\n        else:\n            return store\n\n"
  },
  {
    "name": "backspace",
    "text": "def backspace(s):\n    return s[:-1]\n\n"
  },
  {
    "name": "str_object_format",
    "text": "def str_object_format(items, mode):\n    ref = jspy()\n    delimiters = ref[mode + \"_delimiters\"]\n    quotes = ref[\"object_quotes\"]\n    indent = \" \" * 4\n    s = delimiters[0] + \"\\n\"\n    if mode == \"array\":\n        items = unique(items)\n        for item in items:\n            s += f\"{indent}{item},\\n\"\n    else:\n        for item in items:\n            a, b = item if is_array(item) else (item, item)\n            s += f\"{indent}{quotes}{a}{quotes}: {b},\\n\"\n\n    s += delimiters[1]\n    return s\n\n"
  },
  {
    "name": "generate_return_statement",
    "text": "def generate_return_statement():\n    # a, b = get_line_indexes(\"block\")\n    b = get_lnum()\n    i = find_line_index(\"\\S\", dir=-1, start=b, limit=5)\n    start = i\n    r = \"^ *\" + create_var(\"(\\w+)\")\n    s = get_line(i)\n    if not test(s, r):\n        return\n\n    store = []\n    push(store, match(s, r))\n    while True:\n        i -= 1\n        m = match(get_line(i), r)\n        if m:\n            push(store, m)\n        else:\n            break\n\n    payload = str_object_format(store, \"object\")\n    s = f\"return {payload}\"\n    append_block(start, s, auto_indent=1)\n\n"
  },
  {
    "name": "xpath",
    "text": "def xpath(*args):\n    args = list(args)\n    last = pop(args)\n    if last in extensions:\n        name = add_extension(tail(pop(args)), last)\n        return expand(os.path.join(*args, name))\n    else:\n        return expand(os.path.join(*args, tail(last)))\n\n"
  },
  {
    "name": "tsa_format",
    "text": "def tsa_format(mode):\n    s = toggle_comments(get_line(), off=True, start_of_line=False)\n    name, *args = split(s, \" +\")\n    if mode == \"object\":\n        args = partition(args)\n    before = create_var(name)\n    after = str_object_format(args, mode)\n    s = before + after\n    set_block(\".\", s)\n\n"
  },
  {
    "name": "filepoint",
    "text": "def filepoint(\n    include=None,\n    exclude=None,\n    size=0,\n    after=0,\n    before=0,\n    smaller=0,\n    bigger=0,\n    **extensions,"
  },
  {
    "name": "get_today_files",
    "text": "def get_today_files(dir, **kwargs):\n    sorter = lambda x: os.path.getmtime(x)\n    return sort(filter(absdir(dir), filepoint(**kwargs)), sorter)\n\n"
  },
  {
    "name": "to_timestamp",
    "text": "def to_timestamp(s=None, **kwargs):\n    if is_string(s) and test(s, \"=\"):\n        a, b = findall(s, \"\\w+\")\n        kwargs[a] = b\n\n    today = datetime.today()\n    if kwargs:\n        h = 0\n        ref = {\n            \"days\": 24,\n            \"hours\": 1,\n            \"weeks\": 168,\n            \"months\": 672,\n        }\n        for k, v in kwargs.items():\n            h += ref[k] * v\n        return today - timedelta(hours=h)\n\n    date_formats = [\n        \"%Y-%m-%d\",  # ISO 8601 format\n        \"%Y/%m/%d\",  # ISO 8601 format\n        \"%m/%d/%y\",  # US date format with slashes\n        \"%m-%d-%y\",  # US date format with dashes\n        \"%I%p\",  # Time format like 9AM or 9PM\n    ]\n\n    for format in date_formats:\n        try:\n            if format == \"%I%p\":\n                dt = datetime.combine(\n                    today, datetime.strptime(s, format).time()\n                )\n            else:\n                dt = datetime.strptime(s, format)\n            return int(datetime.timestamp(dt))\n        except ValueError:\n            continue\n\n    raise Exception(\"could not parse the date\")\n\n"
  },
  {
    "name": "mv",
    "text": "def mv(a, b, confirm=0):\n    a = expand(a)\n    b = expand(b)\n    if confirm:\n        print(\"moving content from input to output\")\n        print(\"input\", a)\n        print(\"output\", b)\n        print(\"type [y] to confirm\")\n        print(\"\")\n        if not input(\"\") == \"y\":\n            return\n    if is_dir(a):\n        shutil.move(a, b)\n        print(\"moving dir\", a, \"to\", b)\n    elif is_file(a):\n        shutil.move(a, b)\n        print(\"moving file\", a, \"to\", b)\n\n"
  },
  {
    "name": "ensure_dir_exists",
    "text": "def ensure_dir_exists(x):\n    if get_extension(x):\n        x = head(x)\n    mkdir(x)\n\n"
  },
  {
    "name": "parse_structure",
    "text": "def parse_structure(text: str) -> dict:\n    structure = {}\n    current_node = structure\n    path_stack = []\n    lines = text.strip().split(\"\\n\")\n\n    for line in lines:\n        if line.strip() == \"\":\n            continue\n\n        indent_level = len(line) - len(line.lstrip(\" \"))\n        assert indent_level % 4 == 0\n        item = line.strip()\n\n        current_depth = indent_level // 4\n\n        s = len(path_stack)\n        if current_depth > s:\n            path_stack.append(current_node)\n\n        print(structure)\n        pause({\"item\": item, \"depth\": current_depth, 'path_stack_len': s})\n        while current_depth < s:\n            path_stack.pop()\n            current_node = path_stack[-1]\n\n        current_node[item] = {}\n        current_node = current_node[item]\n\n    return structure\n"
  },
  {
    "name": "csv_to_json",
    "text": "def csv_to_json(file):\n    reader = csv.reader(open(file))\n    headers = None\n    store = []\n    for i, row in enumerate(reader):\n        if i == 0:\n            headers = map(row, lambda x: sub(x, \" \", \"_\"))\n        else:\n            data = dict(zip(headers, row))\n            if data.get(\"full_name\"):\n                data[\"first_name\"] = get_first_name(data[\"full_name\"])\n            store.append(data)\n    return store\n\n\n\n"
  },
  {
    "name": "capitalize_names",
    "text": "def capitalize_names(name):\n    return name.strip().title()\n\n"
  },
  {
    "name": "split_and_lowercase",
    "text": "def split_and_lowercase(tag):\n    return tag.strip().lower()\n\n"
  },
  {
    "name": "prepare",
    "text": "def prepare(fn):\n    def func(x):\n        if is_string(x):\n            x = map(split(x, \",\"), trim)\n        return map(x, fn)\n\n    return func\n\n"
  },
  {
    "name": "do_title",
    "text": "def do_title(x):\n    return x.title()\n\n"
  },
  {
    "name": "extract_frontmatter",
    "text": "def extract_frontmatter(s):\n    s, m = mget(s, \"^\\n*---\\n([\\w\\W]+?)\\n---\\n*\")\n\n    if not m:\n        return s, {}\n    fm = yaml.safe_load(m)\n\n    for t in transformers:\n        k = t.get(\"key\")\n        if k in fm:\n            value = t.get(\"transform\")(fm[k])\n            if value != None:\n                fm[k] = value\n\n    return s, fm\n\n"
  },
  {
    "name": "remove_emojis",
    "text": "def remove_emojis(s):\n    regex = \" *#emoji(?:\\.\\w+)+\"\n    s = sub(s, regex, \"\")\n    return s\n\n"
  },
  {
    "name": "fix_math_symbols",
    "text": "def fix_math_symbols(s):\n    \"\"\"\n        fixes plus, dot equals, arrows into hash entities via math.marks\n    \"\"\"\n    scope = {\n        \"+\": \"plus\",\n        \"*\": \"dot\",\n        \"=\": \"equals\",\n        \"->\": \"arrow\",\n    }\n    template = \" +($1) +\"\n    transform = lambda x: f\" #{x} \"\n    return dreplace(s, scope, template=template, transform=transform)\n"
  },
  {
    "name": "convert_emoji_symbols_to_png",
    "text": "def convert_emoji_symbols_to_png(s):\n    regex = \" *#emoji((?:\\.\\w+)+)\"\n    # iconize\n\n    images = iconize(\"\")\n    def replacer(x):\n        key = sub(x.group(1)[1:], \".\", \"-\")\n\n    return sub(s, regex, replacer)\n    "
  },
  {
    "name": "get_wechat_emojis",
    "text": "def get_wechat_emojis(s):\n    \n    regex = \"#emoji((?:\\.\\w+)+)\"\n    def replacer(x):\n        key = sub(x.group(1)[1:], \"-\", \"_\")\n        return f\"#iconize(\\\"{key}\\\")\"\n\n    return sub(s, regex, replacer)\n"
  },
  {
    "name": "do_dialogue",
    "text": "def do_dialogue(file):\n\n    roster = read_json(\"~/projects/hammymath/roster.json\")\n\n    \"\"\"\n        this be the main runner\n    \"\"\"\n    s = text_getter(file)\n    # s = convert_emoji_symbols_to_png(s)\n    s = get_wechat_emojis(s)\n    s, frontmatter = extract_frontmatter(s)\n    s = fix_math_symbols(s)\n    speakers = frontmatter.get(\"speakers\")\n\n    def get_student(name):\n        def finder(ref):\n            return ref.get(\"first_name\") == name\n\n        student = find(roster, finder)\n        return student.get(\"full_name\")\n\n    frontmatter[\"students\"] = map(speakers, get_student)\n    frontmatter[\"season\"] = get_season_and_year()\n\n    d = Dialogue(s, speakers)\n    dialogue = d.json()\n    return {\n        \"dialogue\": dialogue,\n        \"meta\": frontmatter,\n    }\n\n"
  },
  {
    "name": "typst",
    "text": "def typst(file, outpath=None, open=True):\n    out = outpath or \"/home/kdog3682/2023/test.pdf\"\n    out = add_extension(add_directory(out, dldir), \"pdf\")\n    shell = \"compile\"\n    openStr = \"--open\" if open else \"\"\n    prefix = \"typst\"\n    template = \"{} {} {} {} {} --root /\"\n    cmd = template.format(prefix, shell, file, out, openStr)\n    pprint(system_command(cmd))\n\n"
  },
  {
    "name": "compile",
    "text": "def compile(outpath=None, subject = \"\", debug = 0, reset = 0):\n\n    dir = f\"/home/kdog3682/projects/hammymath/dialogues/{subject}/\"\n    out = \"/home/kdog3682/projects/hammymath/compiled.typ\"\n    chdir(dir)\n\n    if not is_recent_file(\"compiled.typ\") or reset:\n        s = f\"\"\"\n            #import \"@local/mathematical:0.1.0\"\n            #import \"dialogue.typ\": dialogue\n            #dialogue(module: mathematical, subject: \"{subject}\")\n        \"\"\"\n        text = smart_dedent(s)\n        write2(out, text)\n\n    if debug:\n        dialogue = do_dialogue(\"raw.txt\")\n        s = str_reduce(dialogue.get(\"dialogue\"), lambda x: x.get(\"text\"))\n        write2( \"/home/kdog3682/2024/temp.typ\", s )\n        return typst(\"/home/kdog3682/2024/temp.typ\")\n\n    if is_recent_file(out, minutes = 10):\n        return typst(out, outpath=outpath)\n        \n    dialogue = do_dialogue(\"raw.txt\")\n\n    write2(f\"~/projects/hammymath/dialogues/{subject}/dialogue.json\", dialogue)\n    # write2(f\"~/projects/hammymath/dialogues/exponents/dialogue.json\", dialogue)\n    return typst(out, outpath=outpath)\n\n"
  },
  {
    "name": "f",
    "text": "def f(s):\n    return sub(s, \"^speaker: +\\w+\\n+\", \"\", flags=re.M)\n\n"
  },
  {
    "name": "git_clone",
    "text": "def git_clone(url, dest = None):\n    if not test(url, \"https\"):\n        url = \"https://github.com/\" + url\n    if not dest:\n        dest = url.split(\"/\")[-1]\n    pprint(system_command(f\"git clone {url} ~/github/{dest}\"))\n\n"
  },
  {
    "name": "grep",
    "text": "def grep(dir, pattern, boundary=False):\n    excluded_directories = [\n        \"git\",\n        \"node_modules\",\n    ]\n    if boundary:\n        pattern = \"\\\\b\" + pattern + \"\\\\b\"\n\n    # -o prints just the matching part of the line\n    cmd = f'grep -r -P --exclude-dir={{{\",\".join(excluded_directories)}}} \"{pattern}\" {dir}'\n    result = system_command(cmd)\n    s = result.get(\"success\")\n    if s:\n        return split(s, \"\\n\")\n\n"
  },
  {
    "name": "see_missing_entities",
    "text": "def see_missing_entities(subject):\n    dir = f\"/home/kdog3682/projects/hammymath/dialogues/{subject}/\"\n    asset_file = npath(dir, \"assets.typ\")\n    raw_file = npath(dir, \"raw.txt\")\n    r = \"^#let ([\\w-]+)\"\n    ignore = [\"emph\", \"homework-question\", \"emoji\", \"sym\"]\n    assets = findall(read(asset_file), r, flags=re.M) + ignore\n\n    m = read(raw_file)\n    used = unique(findall(m, \"#([\\w-]+)\", flags=re.M))\n    diff = difference(used, assets)\n    pprint(diff)\n\n"
  },
  {
    "name": "temp_fix_typst_directory",
    "text": "def temp_fix_typst_directory():\n    dir = \"/home/kdog3682/.cache/typst/packages/local/stdlib/0.1.0/\"\n    src_dir = npath(dir, \"src\")\n    files = absdir(dir)\n    mkdir(src_dir)\n    map(files, lambda x: mv(x, src_dir))\n    toml_file = \"/home/kdog3682/.cache/typst/packages/local/stdlib/0.1.0/typst.toml\"\n    s = \"\"\"\n        [package]\n        name = \"stdlib\"\n        version = \"0.1.0\"\n        entrypoint = \"lib.typ\"\n    \"\"\"\n    write(toml_file, smart_dedent(s))\n\n"
  },
  {
    "name": "create_typst_project",
    "text": "def create_typst_project(name, desc=\"\", version=\"0.1.0\"):\n    dir = f\"~/projects/typst/{name}/{version}\"\n    mkdir(dir)\n    create_toml(name, desc, version)\n    dir = npath(dir, \"src\")\n    mkdir(dir)\n    path = npath(dir, \"index.typ\")\n    write2(path, f\"// {name}\")\n    files = [\n        path,\n    ]\n    append(\"/home/kdog3682/2024/files.log\", join_lines(files))\n    symlink(dir, f\"/home/kdog3682/.local/share/typst/packages/local/{name}\")\n\n"
  },
  {
    "name": "symlink",
    "text": "def symlink(path, to):\n    path = expand(path)\n    to = expand(to)\n    assert os.path.exists(path)\n\n    # if os.path.exists(to):\n        # rm(to, confirm=1)\n\n    cmd = f\"ln -s {path} {to}\"\n    print(cmd)\n    system_command(cmd)\n"
  },
  {
    "name": "create_toml",
    "text": "def create_toml(name, description, version):\n    dir = f\"~/projects/typst/{name}/{version}/\"\n    path = npath(dir, \"typst.toml\")\n    s = f\"\"\"\n        [package]\n        name = \"{name}\"\n        version = \"{version}\"\n        compiler = \"0.11.0\"\n        repository = \"https://github.com/kdog3682/{name}\"\n        entrypoint = \"src/index.typ\"\n        description = \"{description}\"\n        authors = [\n          \"Kevin Lee <https://github.com/kdog3682>\",\n        ]\n        license = \"MIT\"\n    \"\"\"\n    write2(path, smart_dedent(s))\n\n\n\n"
  },
  {
    "name": "mmgg_txt_to_typ",
    "text": "def mmgg_txt_to_typ(s):\n    def replacer(x):\n        m = len(x.group(0))\n        if m == 1:\n            return \"\\n\\n\"\n        else:\n            return f\"\\n\\n#v(20pt)\\n\\n\"\n\n    s = trim(s)\n    # matches chinese characters\n\n    s = sub(s, \"\\.\", \"。\")\n    # fixing stray question marks\n\n    s = sub(s, \"\\n+(?=[^\\s-])\", replacer)\n    # s = sub(s, \"\\n+(?=[\\u4e00-\\u9fa5])\", replacer)\n    s = sub(s, \"\\n+-{5,} *\\n*\", \"\\n\\n#dashbreak()\\n\\n\", flags=re.M)\n    return s\n\n"
  },
  {
    "name": "mmgg",
    "text": "def mmgg(story, version):\n    \"\"\"\n    applies the mmgg_txt_to_typ transform\n    story: morning_walk or sushi_party et cetera\n    version: v1.txt v2.txt et cetera\n    \"\"\"\n    inpath = f\"~/projects/mmgg/{story}/v{version}.txt\"\n    outpath = f\"~/projects/mmgg/{story}/v{version}.typ\"\n    rpx(inpath, mmgg_txt_to_typ, outpath=outpath)\n\n"
  },
  {
    "name": "outbound",
    "text": "def outbound(name):\n    \"\"\"\n    renames the current test.pdf file to a dldir pdf file\n    \"\"\"\n    out = npath(drivedir, add_extension(name, \"pdf\"))\n    cp(\"/home/kdog3682/2023/test.pdf\", out)\n    view(out)\n\n"
  },
  {
    "name": "colon_note_shunter",
    "text": "def colon_note_shunter():\n    file = \"/home/kdog3682/2024/code_notes.txt\"\n    s = read(file)\n    matches = findall(s, \"^shunt$\", flags=re.M)\n    if len(matches) == 1:\n        a, b = map(split(s, \"^shunt\", flags=re.M), trim)\n        out = f\"~/documents/notes/colon/{strftime()}.txt\"\n        append(out, b)\n        write(file, a)\n"
  },
  {
    "name": "move_within_dir",
    "text": "def move_within_dir(name, dir):\n    assert is_dir(dir)\n    dest = npath(dir, name)\n    mkdir(dest)\n    files = absdir(dir)\n    map(files, lambda x: mv(x, dest))\n"
  },
  {
    "name": "find_emojis",
    "text": "def find_emojis(text):\n    return emoji_pattern.findall(text)\n"
  },
  {
    "name": "f",
    "text": "def f(s):\n    pat = \"^// *(.+)\"\n    a, b = mget(s, pat, flags = re.M)\n    pat = \"^#let (\\w+(?:-\\w+)*)\\(\"\n    m = findall(s, pat, flags = re.M)\n    items = map(m, lambda x: f\"# {x}()\")\n    value = join_lines(a, b, items)\n    return value"
  },
  {
    "name": "compile2",
    "text": "def compile2(outpath=None, subject = \"\"):\n\n   out = \"/home/kdog3682/projects/hammymath/compiled.typ\"\n   dialogue = do_dialogue(\"raw.txt\")\n   payload = create_typst_payload(dialogue)\n\n   write2(out, payload)\n   return typst(out, outpath=outpath)\n"
  },
  {
    "name": "file_from_subject",
    "text": "def file_from_subject(subject, file = \"raw.txt\"):\n    return f\"{hammymath_dir}{subject}/{file}\"\n"
  },
  {
    "name": "versionate",
    "text": "def versionate(subject, name):\n    file = file_from_subject(subject)\n    path = path_join(hammymath_dir, subject, \"drafts\", name, ext = \"txt\")\n    ensure_dir_exists(path)\n    cp(file, path)\n\n"
  },
  {
    "name": "colon_note_shunter",
    "text": "def colon_note_shunter():\n    file = \"/home/kdog3682/2024/code_notes.txt\"\n    out = f\"~/documents/notes/colon/{strftime()}.txt\"\n    append(out, read(file))\n    print(\"appended\", out)\n    clear(file)\n  "
  },
  {
    "name": "rename",
    "text": "def rename(file, dir = None):\n    e = get_extension(file)\n    name = tail(file)\n    new_name = prompt(f\"write a name for {name}\")\n    return npath(dir, add_extension(new_name, e))\n\n"
  },
  {
    "name": "maker",
    "text": "def maker(name):\n    a, b = name.split(\"/\")\n    dir = os.path.join(hammy_dialogue_dir, a, \"drafts\")\n    mkdir(dir)\n    files = absdir(dir)\n    num = len(files)\n    i = \"I\" * num\n    filename = f\"{i}-{capitalize(b)}.typ\"\n    filepath = os.path.join(dir, filename)\n    prompt(filepath)\n    frontmatter = \"\"\"\n        ---\n        speakers: aaron, evangeline, elina\n        requisites: canceling fractions\n        spacing: 25pt\n        ---\n        \n    \"\"\"\n    write(filepath, smart_dedent(frontmatter))\n    filelog(filepath)\n    hammymath_dialogue_call = f\"// hammyMathDialogue({topic}, {name})\"\n    append(\"/home/kdog3682/2024-javascript/txflow/tests/typst.a.js\", hammymath_dialogue_call)\n"
  },
  {
    "name": "interactive_jsoner",
    "text": "def interactive_jsoner():\n    file = get_most_recent_file()\n    data = read(file)\n    keys = list(data[0].keys())\n    keys = split(s, \"\\s\")\n    return map(read(file), lambda x: reduce(keys, lambda k: x.get(k)))\n\n\n"
  },
  {
    "name": "get_last_digit",
    "text": "def get_last_digit(x):\n    return int(str(x)[-1])"
  },
  {
    "name": "foo",
    "text": "def foo(n):\n    reversed_atom = reverse(n)\n    if len(str(reversed_atom)) != len(str(n)):\n        return False\n\n    answer = n * n\n    answer_reversed = reverse(answer)\n    reversed_atom_squared = reversed_atom * reversed_atom\n    if get_last_digit(answer_reversed) == get_last_digit(reversed_atom_squared):\n        print(n, answer_reversed, reversed_atom_squared)\n        return True\n    return False\n    if answer_reversed == reversed_atom_squared:\n        print(n, answer_reversed, reversed_atom_squared)\n        return True\n"
  },
  {
    "name": "suite",
    "text": "def suite(fn, start = 1, end = 100):\n    numbers = range(start, end + 1)\n    results = filter(numbers, fn)\n    pprint(results)\n  "
  },
  {
    "name": "dashbreak",
    "text": "def dashbreak(n = 50, newlines = 1):\n    newlines = \"\\n\" * newlines\n    return newlines + \"-\" * n + newlines"
  },
  {
    "name": "smart_split",
    "text": "def smart_split(s):\n    s = trim(s)\n    m = findall(s, \"\\n+\")\n    n = max(m, key = lambda x: len(x))\n    return map(re.split(n, s), trim)\n"
  },
  {
    "name": "speakify_raw_dialogue_portion",
    "text": "def speakify_raw_dialogue_portion(s, speakers):\n\n    def callback(item):\n        i, s = item\n        speaker = speakers[i % length]\n        t = \"speaker: $1\\n\\n$2\"\n        return templater(t, (speaker, s))\n\n    length = len(speakers)\n    items = smart_split(s)\n    p = dashbreak() + join(map(enumerate(items), callback), dashbreak())\n    append_self(p)\n\n"
  },
  {
    "name": "abc",
    "text": "def abc(s):\n    \n    store = []\n    def replacer(x):\n        k = x.group(0)\n        store.append(f\"circler({k}, name: \\\"{k}\\\")\")\n        return f\"let {x.group(0)} = ()\"\n    p = sub(s, \"^\\S+\", replacer, flags = re.M)\n    p += \"\\n\\n\" + \"\\n\".join(store)\n    append_self(p)"
  },
  {
    "name": "escape_quotes",
    "text": "def escape_quotes(s):\n    return sub(s, \"\\\"\", \"\\\\\\\"\")"
  },
  {
    "name": "escape_newlines",
    "text": "def escape_newlines(s):\n    return sub(s, \"\\n\", \"\\\\\\\\n\")"
  },
  {
    "name": "do_typst_vim_snippeteer",
    "text": "def do_typst_vim_snippeteer(s):\n    def callback(s):\n        a, b = split_once(s)\n        return a, escape_newlines(escape_quotes(b))\n\n    items = map(split(s, \"\\n(?=[a-zA-Z])\"), callback)\n    template = \"\"\"let g:wpsnippets2[\"typst\"][\"$1\"] = \"$2\" \"\"\"\n    templates = [templater(template, x) for x in items]\n    return join(templates, \"\\n\")\n"
  },
  {
    "name": "is_word",
    "text": "def is_word(s):\n    return test(s, \"^[\\w-]+$\")"
  },
  {
    "name": "move_files_into_directory",
    "text": "def move_files_into_directory(dir, dest):\n    \"\"\"\n        \n    \"\"\"\n    if is_word(dest):\n        dest = npath(dir, dest)\n\n\n    files = filter(absdir(dir), is_file)\n    pause({\"dest\": dest, \"files\": files})\n\n    mkdir(dest)\n    for file in files:\n        mv(file, dest)\n"
  },
  {
    "name": "swap_directories_of_file",
    "text": "def swap_directories_of_file(file):\n    \"\"\"\n        no\n        do it manually\n    \"\"\"\n    parts = file.split(\"/\")\n    a, b = parts[-2:]\n    dir = parts[:-2]\n    return (a, b)\n    \n    parts = os.path.split(a)\n    return print(parts)\n    a = head(file)\n    b = head(a)\n\n    assert(is_dir(a))\n\n    src = b\n    to = npath(head(a), b)\n\n\n"
  },
  {
    "name": "combiner",
    "text": "def combiner(name, regex = None):\n    dir = \"~/PYTHON\"\n    new_dir = npath(dir, name)\n\n    if name.endswith(\"s\"):\n        key = name[:-1]\n    else:\n        key = name\n    \n\n    r = regex or name\n    files = filter(filter(absdir(dir), is_file), lambda x: test(x, r))\n    if not files:\n        return print(\"no active files\")\n\n    prompt(files, new_dir)\n\n    mkdir(new_dir)\n    map(files, lambda x: mv(x, new_dir))\n"
  },
  {
    "name": "cleaner",
    "text": "def cleaner():\n    destinations = get_files_recursive(\"~/PYTHON\", folders = 1, private = 1)\n    files = get_files_recursive(\"~/PYTHON\", files = 1, months = 2, size = 1000, private = 1, before = 1, py = 1)\n    for file in files:\n        s = read(file)\n        if len(trim(s)) < 3:\n            trash(file)\n            continue \n        os.system(\"clear\")\n        print(s)\n        print(\"----\")\n        print(file)\n        a = input(\"press [d] to delete ... [m] to move\")\n        if a == \"d\":\n            trash(file)\n\n        elif a == \"m\":\n            dest = choose(destinations)\n            mv(file, dest)\n            pause(\"press anything to continue\")\n"
  },
  {
    "name": "mvfiles",
    "text": "def mvfiles(files, dir):\n    prompt(files, dir)\n    mkdir(dir)\n    map(files, lambda file: mv(file, dir))\n"
  },
  {
    "name": "foo",
    "text": "def foo():\n    # files = get_files_recursive(\"~/\", folders = 1, empty = 1, public = 1)\n\n\n    # files = get_files_recursive(\"~/documents/notes\", files = 1, public = 1, txt = 1)\n    # mvfiles(files, \"~/documents/notes/dated\")\n  \n    files = get_files_recursive(\"~/PYTHON\", files = 1, months = 2, before = 1, py = 1)\n    pprint(files)"
  },
  {
    "name": "bash",
    "text": "def bash(s, cwd = None):\n    cmd = smart_dedent(s)\n    try:\n        value = subprocess.check_output(cmd, shell=True, text = True, cwd = cwd)\n        print(value)\n    except subprocess.CalledProcessError as e:\n        print(f\"Error executing command: {e}\")\n\n"
  },
  {
    "name": "find_file",
    "text": "def find_file(*args, **kwargs):\n    return choose(get_files_recursive(*args, **kwargs))"
  }
]